 # 第二章 BIOS与MBR

## 载入内存

- cpu的硬件电路只能运行处于内存中的程序
  - 优点:速度快,容量大,统一不同的存储介质
- 程序载入内存的步骤
  1. 程序被加载器加载到内存某个区域
  2. CPU的cs:ip寄存器指向该程序的起始地址

---

---

## ★★ BIOS

- Base Input & Output System，即基本输入输出系统。
- Intel 8086 有 20 条地址线，可以访问 1MB 的内存空间，即 2 的 20 次方=1048576=1MB，地址范围是 0x00000 到 0xFFFFF
  - 但这20条地址总线**不是全部都给内存条使用**
  - 20条中一部分给外设，一部分给显存，一部分给...剩下的可用地址给内存条，也就是物理内存
  - 所以：32位机，就算安装了4GB内存条，但显示其内存也只有3.8GB左右
- **实模式下的 1MB 内存**布局
  - ![image-20240730204222074](/home/ZMR/.config/Typora/typora-user-images/image-20240730204222074.png)
  - 顶部的 0xF0000～0xFFFFF，这 64KB 的内存是 ROM，存的是 **BIOS 的代码**
  - BIOS 的主要工作是**检测、初始化硬件**（硬件自己提供了一些初始化的功能调用，BIOS 直接调用就好了）
  - BIOS 在内存中的 0x000 至 0x3FF 区域**建立中断向量表**，可以通过**int 中断号**来实现相关的**硬件调用**，这是**`对硬件的 IO 操作，也就是输入输出`** ----> （解释了为什么 BIOS 叫做基本输入输出系统）

---

### BIOS的加载过程

1. BIOS是**计算机启动时第一个运行的软件**，它存储在只读存储器（ROM）中
2. **硬件加载**：BIOS 由硬件加载（ ROM 通过地址映射在低端 1MB 内存的顶部（地址 0xF0000 至 0xFFFFF））
3. **入口地址**：BIOS 的入口地址是 0xFFFF0。开机时，CPU 的**段寄存器（cs）和指令指针（ip）被强制初始化为 0xF000 和 0xFFF0**
4. **实模式下的地址计算**：在实模式下，段地址需要乘以 16，0xF000:0xFFF0 的**物理地址为 0xFFFF0**

### BIOS初始化过程

5. **跳转指令**：在 0xFFFF0 处的**跳转指令**（如 `jmp far f000:e05b`）指向 BIOS 代码的**实际位置**
6. **硬件检测**：BIOS 初始化后，会检测内存、显卡等硬件，当检测通过并初始化好硬件后，在内存中的 0x000 至 0x3FF 区域**建立中断向量表（IVT）**

### BIOS最后一项任务

7. 校验启动盘的**MBR**（主引导记录）
8. 检查MBR末尾的两个字节（魔数0x55和0xaa）来确认该扇区中存在可执行程序

---

---

## ★★ MBR

- 一开始位于启动盘**0盘 0道 1扇区**（固定该位置是为了节省启动时间）

- **MBR加载的位置**: 选择32KB内存的**最后1KB（即0x7c00）为MBR的加载地址**，确保不会覆盖系统的其他重要数据。

  - 32KB：**最小内存要求**: 操作系统（如DOS）需要32KB内存。

  - 1KB：MBR 的大小必须是 512 字节（但还要为其所用的栈分配点空间，就干脆给1KB）

    - 所以**0x55 和 0xaa 这两个魔数分别位与510和511字节处**

      ```assembly
      ;mbr.s文件
      SECTION MBR vstart=0x7c00 
      
      	...
      
          message db "hello MBR"      ;定义打印的字符串为hello MBR
          times 510-($-$$) db 0       ;$为本代码行的地址,$$为本section的起始地址,$-$$为本行到本 section的偏移量
                                      ;因为MBR 的最后两个字节是固定的内容，分别是 0x55 和 0xaa，要预留出这 2 个字节
                                      ;故本扇区内前 512-2=510 字节要填满, 所以db 0是用 0 将本扇区剩余空间填充
          db 0x55,0xaa                ;最后两个字节为固定的魔数,BIOS会检查这两个字节来识别这是一个有效的MBR
      ```

  - 0x7c00：与IBM PC 5150的BIOS设计有关，该位置是在BIOS中断处理程序（INT 19H）中硬编码的，旨在为加载MBR提供一个可靠的地址

### ▶ 代码（通过BIOS输出hello MBR）

```assembly
;主引导程序 
SECTION MBR vstart=0x7c00       ;本程序在编译时，告诉编译器，把我的起始地址编译为 0x7c00
    mov ax,cs                   ;此时cs寄存器为0，可以用来将ax寄存器置0
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00               ;将栈指针sp寄存器初始化为0x7c00,让栈有足够的空间向低地址方向扩展。

    ;清屏
    ;利用0x06号功能，上卷全部行，则可清屏
    mov ax, 0x600               ;ah中输入功能号
    mov bx, 0x700               ;设置上卷行属性，0x70表示用黑底白字的属性填充空白行
    mov cx, 0                   ;左上角: (0, 0)
    mov dx, 0x184f	            ;右下角: (80,25),
			                    ;VGA文本模式中,一行只能容纳80个字符,共25行,下标从0开始,所以0x18=24,0x4f=79
    int 0x10                    

    ;下面这三行代码是获取光标位置
    mov ah, 3		            ;输入: 3号子功能是获取光标位置,需要存入ah寄存器
    mov bh, 0		            ;bh寄存器存储的是待获取光标的页号

    int 0x10		            ;执行BIOS 0x10号中断,输出: ch=光标开始行,cl=光标结束行,dh=光标所在行号,dl=光标所在列号

    ;打印字符串
    ;还是用10h中断,不过这次是调用13号子功能打印字符串
    mov ax, message 
    mov bp, ax		           
    mov cx, 9		            ;要打印的字符串的长度
    mov ax, 0x1301	            ;ah=13h,al=01h,表示要打印字符串
    mov bx, 0x2		            ;bh存储要显示的页号,此处是第0页,bl中是字符属性, 属性黑底绿字(bl = 02h,07是黑底白字)
    int 0x10		            ;执行BIOS 0x10 号中断,打印字符串

    jmp $		                ;使程序悬停在此,即死循环

    message db "hello MBR"      ;定义打印的字符串为hello MBR
    times 510-($-$$) db 0       ;$为本代码行的地址,$$为本section的起始地址,$-$$为本行到本 section的偏移量.
                                ;因为MBR 的最后两个字节是固定的内容，分别是 0x55 和 0xaa，要预留出这 2 个字节
                                ;故本扇区内前 512-2=510 字节要填满, 所以db 0是用 0 将本扇区剩余空间填充
    db 0x55,0xaa                ;最后两个字节为固定的魔数,BIOS会检查这两个字节来识别这是一个有效的MBR

```

### BIOS与MBR

#### 地址类型

1. **0xFFFF0**（BIOS 入口点）
   - **类型**：物理地址。
   - **说明**：在实模式下，BIOS 的入口地址通常为 0xFFFF0。这是 BIOS 固件在启动时的加载位置。
2. **0x7C00**（MBR）
   - **类型**：物理地址。
   - **说明**：MBR通常在磁盘的第一个扇区，加载到内存时的地址为 0x7C00。

#### 地址关系

- 都在物理内存：在计算机启动时，BIOS 会将 MBR 从磁盘中读取到物理内存的 0x7C00 位置

---

## ★★★计算机启动过程

**电源开启**：计算机通电，BIOS 开始执行。

**BIOS 初始化**：BIOS 执行上电自检（POST），初始化硬件，并查找引导设备。

**BIOS 加载 MBR**：BIOS 读取引导设备的 MBR，将其加载到内存，并将控制权转交给 MBR 中的引导代码。

**MBR 执行引导代码**：MBR 中的引导代码执行，加载操作系统的引导加载程序或操作系统本身。

---

---

---

# 第三章 完善MBR

## ★★★ CPU工作原理

![image-20240731102328181](/home/ZMR/.config/Typora/typora-user-images/image-20240731102328181.png)

- **控制单元**要取下一条待运行的指令，该指令的地址在**程序计数器 PC** 中，在 x86CPU 上，程序计数器就是 **cs：ip**
- 读取 **ip 寄存器**后，将此地址送上地址总线，CPU 根据此地址便得到了指令，并将其存入到**指令寄存器 IR** 中
- 这时候轮到**指令译码器**上场了，它根据指令格式检查指令寄存器中的指令，先确定操作码是什么，再检查操作数类型，若是在内存中，就将相应**操作数**从内存中取到自己的存储单元，若操作数是在寄存器中就直接用了，免了取操作数这一过程
- 操作码有了，操作数也齐了，**操作控制器**给运算单元下令，开工，于是**运算单元**便真正开始执行指令了。ip 寄存器的值被加上当前指令的大小，于是 ip 又指向了下一条指令的地址
- 接着控制单元又要取下一条指令了，流程回到了本段开头

---

## 实模式下 CPU 内存寻址方式

- 寄存器寻址
- 立即数寻址
- 内存寻址
  - 直接寻址
  - 基址寻址
  - 变址寻址
  - 基址变址寻址

### 寄存器寻址

```assembly
mov ax, 0x10
mov dx, 0x9
mul dx
```

- 第一、二条指令源操作数都是立即数，所以也属于立即数寻址

### 立即数寻址

```assembly
mov ax,0x18
mov ds, ax
mov ax, macro_selector ; 宏
mov ax, label_star 	   ; 标号
```

- 第一条指令中的源操作数 0x18 是立即数，目的操作数 ax 是寄存器，所以它既是立即数寻址，也是寄
  存器寻址

### 内存寻址

- 前面两种寻址方式，**操作数一个是在寄存器中，一个是在指令中直接给出，它们都不在内存中**。操作
  数在内存中的寻址方式称为内存寻址。
- ~~寄存器寻址弊端：CPU 给程序员用的寄存器并不是很多，所以操作数一多起来的时候，基本就倒腾不开了~~
- ~~立即数寻址弊端：得提前知道立即数是多少。而且，大多数时候操作数位于内存中的某个位置，只知道操作数所在的内存地址，不知道操作数的值~~

#### 直接寻址

- **数字作为内存地址**，通过中括号的形式告诉 CPU，取此地址中的值作为操作数

```assembly
mov ax, [0x1234]
mov ax, [fs:0x5678]
```

- 0x1234 是**段内偏移地址，默认的段地址是 DS**。这条指令是将内存地址 DS：0x1234 处的值写入 ax 寄存器
- 第二条指令中，由于使用了**段跨越前缀 fs**，0x5678 的**段基址则变成了 gs 寄存器**。最终的内存地址是gs 寄存器的值*16+0x5678，CPU 到此内存地址取值再存入 ax 寄存器

#### 基址寻址

- 使用 **BX** 或 **BP** 寄存器作为基址，进行内存地址的计算（实模式下只能用这两个，保护模式不限）
- **BX寄存器**：
  - 默认段寄存器为 **DS**（数据段）。
  - 例如：指令 `ADD WORD [BX], 0x1234` 意味着将内存地址 `DS:BX` 处的值与 `0x1234` 相加，并存回 `DS:BX`。
- **BP寄存器**：
  - 默认段寄存器为 **SS**（栈段）。
  - 主要用于栈的访问，尤其在函数调用和局部变量管理中。![image-20240731105233478](/home/ZMR/.config/Typora/typora-user-images/image-20240731105233478.png)
- 堆栈框架![image-20240731110313114](/home/ZMR/.config/Typora/typora-user-images/image-20240731110313114.png)

#### 变址寻址

- 和基址寻址类似，只是寄存器由 bx、bp 换成了 si 和 di，默认段寄存器是 ds

  ```assembly
  mov [di]，ax  		;将 AX 寄存器的值存储到由 DI 寄存器指向的内存地址
  mov [si+0x1234], ax  ;将 AX 寄存器的值存储到由 SI 寄存器加上偏移量 0x1234 计算得出的内存地址
  ```

#### 基址变址寻址

- 基址寄存器 bx 或 bp 加一个变址寄存器 si 或 di，默认段寄存器是 ds

  ```assembly
  mov [bx+di], ax  ;将 ax 中的值送入以 ds 为段基址，bx+di 为偏移地址的内存
  add [bx+si], ax  ;将 ax 与[ds：bx+si]处的值相加后存入内存[ds：bx+si]
  ```

---

## 实模式下的ret

### 近返回ret

1. ret（return）指令的功能：在栈顶（寄存器 ss：sp 所指向的地址）弹出 **2 字节**的内容来替换 **IP** 寄存器，并会使 sp 指针+2
2. 如果 call 是**近调用**，在目标函数中就要用 ret 来返回，因为**近调用的 call 只在栈中留下了 2 字节的返回地址**（IP 寄存器的值），ret 只是从栈顶取得 2 个字节作为偏移地址载入 IP 寄存器

### 远返回retf

1. retf（return far）：从栈顶取得 **4 字节**，栈顶处的 2 字节用来替换 **IP** 寄存器，另外的 2 字节用来替换**CS** 寄存器
2. 如果 call 是**远调用**，在目标函数中就要用 retf（ret far）来返回，因为**远调用的 call 指令在栈中留下了段基址和段内偏移地址**，retf 指令只会从栈中弹出 2 字节的偏移地址和 2 字节的段基址

---

## 实模式下的call

- 调用函数

### 16 位实模式相对近调用

**1. 相对近调用概述**

- 相对近调用是指在同一个代码段内（即同一个 64KB 空间内）进行函数调用。
- 由于目标函数和当前指令位于同一个段，因此只需要给出目标函数的段内偏移地址，无需给出段基址。
- 这种调用方式使用 `call near` 指令，其中 `near` 可以省略。
- 指令格式为 `call near 立即数地址`，操作数为立即数。

**2. 相对近调用的操作数**

- 操作数不是目标函数的绝对地址，而**是目标函数地址相对于当前 `call` 指令地址的偏移量，即地址差**。
- 具体计算方法为：**目标函数地址 - 当前 `call` 指令地址 - 指令长度（3 字节）**。
- 操作数是一个有符号数，范围为 -32768 到 32767。

**3. 相对近调用的执行过程**

- **CPU 遇到 `call near` 指令时，会将当前 IP 寄存器值（即当前指令地址）压入堆栈，然后将操作数（相对地址增量）加到 IP 寄存器值上，并将结果作为新的 IP 寄存器值，从而跳转到目标函数的地址。**
- **目标函数执行完毕后，使用 `ret` 指令返回。`ret` 指令会从堆栈中弹出之前保存的 IP 寄存器值，并将其赋值给 IP 寄存器，从而返回到 `call` 指令的下一条指令处继续执行。**

**4. 相对近调用的优势**

- 由于操作数是相对地址，因此代码位置的改变不会影响指令的执行，提高了代码的可移植性。
- 相对地址的计算由编译器完成，简化了开发人员的工作。

**5. 示例代码分析**

```assembly
call near near_proc
jmp $
addr dd 4
near_proc：
	mov ax， 0x1234
	ret
```

`call near_proc` 指令的机器码为 `e8 06 00`。

- `e8` 是 `call near` 指令的操作码。
- `06 00` 是操作数，表示目标函数 `near_proc` 的地址相对于当前 `call` 指令地址的偏移量为 6。

bochs 的反汇编结果验证了这一点：

- 当前指令地址为 `0x900`。
- 目标函数地址为 `0x909`。
- 操作数为 `0x06`，即 `0x909 - 0x900 - 3 = 0x06`。

### 16 位实模式间接绝对近调用

**1. 间接绝对近调用概述**

- 间接绝对近调用是指通过寄存器或内存地址间接获取目标函数的绝对地址，并在同一个代码段内进行函数调用。
- 与“16 位相对近调用”不同，这种调用方式**不使用相对地址，而是直接使用目标函数的绝对地址**。
- 由于是近调用，目标函数和当前指令位于同一个代码段，因此只需要给出目标函数的段内偏移地址，无需给出段基址。

**2. 指令格式**

- 指令格式为 `call 寄存器寻址` 或 `call 内存寻址`。
- `call 寄存器寻址` 指令使用寄存器存放目标函数的地址，例如 `call ax`。
- `call 内存寻址` 指令使用内存地址存放目标函数的地址，例如 `call [0x1234]`。

**3. 操作码**

- `call 内存寻址` 指令的操作码为 `ff16`，机器码为 `ff16 + 16 位内存地址`。
- 寄存器寻址的机器码与寄存器名称有关，例如 `call ax` 的机器码为 `ffd0`，`call cx` 的机器码为 `ffd1`。

**4. 执行过程**

- **CPU 遇到 `call` 指令时，会将当前 IP 寄存器值（即当前指令地址）压入堆栈。**
- **然后根据指令格式，从寄存器或内存中获取目标函数的地址，并将其赋值给 IP 寄存器。**
- **最后，CPU 跳转到目标函数地址执行。**

**5. 示例代码分析**

```assembly
section call_test vstart=0x900
mov word [addr], near_proc
call [addr]
mov ax, near_proc
call ax
jmp $
addr dd 4
near_proc:
	mov ax, 0x1234
	ret
```

`call [addr]` 和 `call ax` 分别演示了间接绝对近调用的两种方式。

- 第 3 行 `call [addr]` 使用内存地址 `addr` 存放目标函数 `near_proc` 的地址。
- 第 5 行 `call ax` 使用 `ax` 寄存器存放目标函数 `near_proc` 的地址。

### 16 位实模式直接绝对远调用

### 16 位实模式间接绝对远调用



---

## 实模式下的 jmp

- `相对于call：jmp有去无返`

1. **短相对跳转 (jmp short)**：这种跳转类型使用一个有符号 8 位立即数作为偏移量，允许在当前指令的 -128 到 +127 字节内进行相对跳转。这条指令的操作码是 0xEB。

   ```assembly
   jmp short start
   ...
   start：
   	...
   ```

2. **近相对跳转 (jmp near)**：这种跳转类型使用一个有符号 16 位立即数作为偏移量，允许在当前指令的 -32,768 到 +32,767 字节内进行相对跳转。这条指令的操作码是 0xE9。

   ```assembly
   jmp near start
   ...
   start:
   	...
   ```

3. **近寄存器间接跳转 (jmp near reg)**：这种跳转类型使用一个寄存器中的 16 位值，例如 AX。这条指令的操作码是 0xFF。

   ```assembly
   mov ax， start
   jmp near ax
   ...
   start:
   	...
   ```

4. **直接绝对远转移 (jmp far)**：这种跳转类型直接提供目标地址的段基址和段内偏移地址。操作数是立即数形式的。操作数会被直接加载到 CS 寄存器和 IP 寄存器中，从而实现转移。

   ```assembly
   jmp 0：start
   ...
   start:
   	...
   ```

5. **间接绝对远转移 (jmp far mem)**：这种跳转类型的操作数在内存中。当不使用段跨越前缀时，段基址寄存器默认为 DS。操作数需要访问内存才能得到，因此需要知道寻址方式。操作数包含 4 个字节：段内偏移地址（2 字节）和段基址（2 字节）。由于是远转移，因此 CPU 的 CS 寄存器和 IP 寄存器都要被修改成操作数中指定的值。

   ```assembly
   jmp far [addr]
   ...
   addr dw start，0
   start:
   	...
   ```

---

## 标志寄存器 flags

![image-20240731155453687](/home/ZMR/.config/Typora/typora-user-images/image-20240731155453687.png)

- 第 0 位的是 CF 位，即 Carry Flag，意为进位。它可用于检测**无符号**数加减法**是否有溢出**，因为 CF 为 1 时，也就是最高位有进位或借位，肯定是溢出。
- 第 2 位为 PF 位，即 Parity Flag，意为奇偶位。用于标记结果低 8 位中 1 的个数，如果为偶数，PF 位为 1，否则为 0。
- 第 4 位为 AF 位，即 Auxiliary carry Flag，意为辅助进位标志，用来记录运算结果低 4 位的进、借位情况，即若低半字节有进、借位，AF 为 1，否则为 0。
- 第 6 位为 ZF 位，即 Zero Flag，意为零标志位。若计算结果为 0，此标志为 1，否则为 0。
- 第 7 位为 SF 位，即 Sign Flag，意为符号标志位。若运算结果为负，则 SF 位为 1，否则为 0。
- 第 8 位为 TF 位，即 Trap Flag，意为陷阱标志位。此位若为 1，用于让 CPU 进入单步运行方式，若为0，则为连续工作的方式。(debug 程序，在单步调试时，原理上就是让 TF 位为 1)
- 第 9 位为 IF 位，即 Interrupt Flag，意为中断标志位。若 IF 位为 1，表示中断开启，CPU 可以响应外部可屏蔽中断。若为 0，表示中断关闭，CPU 不再响应来自 CPU 外部的可屏蔽中断，但 CPU 内部的异常还是要响应的.
- 第 10 位为 DF 位，即 Direction Flag，意为方向标志位。此标志位用于字符串操作指令中，当 DF 为1 时，指令中的操作数地址会自动减少一个单位，当 DF 为 0 时，指令中的操作数地址会自动增加一个单位，意即给地址的变化提供个方向。
- 第 11 位为 OF 位，即 Overflow Flag，意为溢出标志位。若 OF 为 1，表示有溢出，为 0 则未发生溢出。专门用于检测**有符号数**运算结果**是否有溢出**现象。
- ...

---

## 有条件转移

![image-20240731160330979](/home/ZMR/.config/Typora/typora-user-images/image-20240731160330979.png)

a表示 above
b表示 below
c表示 carry
e表示 equal
g表示 great
j表示 jmp
l表示 less
n表示 not
o表示 overflow
p表示 parity

---

## 实模式的缺点

1. 实模式下没有特权级，用户程序和操作系统平起平坐
2. 程序可以随意修改自己的段基址，可以随意访问任意物理内存，包括访问操作系统所在的内存数据

----

## IO接口

### 背景

CPU 与外部设备通信的挑战：

- 外部设备种类繁多，特性各异，数据格式、工作时序、信号电平等方面都存在差异。
- CPU 速度远高于外部设备，直接与每个设备交互会造成 CPU 等待时间过长，效率低下。

### 概述

IO 接口的引入：

- 作用： **CPU 和外部设备之间的代理，负责协调双方之间的差异，简化 CPU 的操作**。
- IO 接口可以是电路板、芯片或插槽，负责速度匹配、信号转换、数据格式转换、时序控制等功能。
- IO 接口可以分为硬件和软件两部分：
  - 硬件部分负责实际的协调转换工作。
  - 软件部分包括驱动程序和数据传输程序，控制接口电路的运作。

IO 接口的分类：

- 可编程接口芯片：可以根据需要设置工作模式，支持多种功能，允许多个设备共享同一个接口。
- 不可编程接口芯片：功能简单，不需要设定即可使用。

IO 接口的控制编程：

- 通过软件指令控制 IO 接口的功能和工作模式，实现定制化的功能。
- 使用端口读写指令 (in/out) 来实现 IO 接口的控制编程。

具体例子：

- ### USB 接口：用于连接外部设备，如键盘、鼠标、打印机等。

- ### PCI/PCIe 插槽：用于连接各种扩展卡，如显卡、网卡、声卡等。

### 功能

- 设置数据缓冲区，解决速度不匹配问题。
- 设置信号电平转换电路，解决信号电平差异问题。
- 设置数据格式转换电路，解决数据格式差异问题。
- 设置时序控制电路，同步 CPU 和外部设备的工作时序。
- 提供地址译码，实现对多个端口的访问。

### 其他

总线：

- 作用：**连接 CPU 和外部设备的物理链路，是一组电线，用于传输信号**。
- 主板上的各种插槽都是连接到总线上的。
- 总线可以分为不同的类型，如地址总线、数据总线、ISA 总线等。

南桥芯片：

- 作用：**仲裁 IO 接口的竞争，连接各种内部总线**。

- 南桥芯片负责连接各种低速设备，如硬盘、USB、PCI 设备等。

- 南桥芯片内部集成了一些 IO 接口，并提供 PCI 接口用于扩展其他设备。

  ![image-20240731200112351](/home/ZMR/.config/Typora/typora-user-images/image-20240731200112351.png)

端口：

- 作用：**是 IO 接口内部的寄存器，用于与 CPU 进行数据交互**。
- 为了区别于 CPU 内部的寄存器，IO 接口中的寄存器称为端口。
- in 指令用于从端口读取数据。
- out 指令用于向端口写入数据。

### ★★★ IO接口，cpu，外部设备，总线，南桥芯片，端口之间的关系

 IO 接口是连接 CPU 和硬件的桥梁，一端是 CPU，另一端是硬件。IO接口通过总线连接CPU和外部设备。当同时有很多的IO接口想与CPU通信时，需要南桥芯片来协调各个IO接口。而IO接口被设计成需要使用寄存器才能与CPU 通信，因此IO接口中的寄存器被称为端口，用于与 CPU 进行数据交互

---

## 显存、显卡、显示器

- 关系：**显卡（硬件组件，包括GPU）通过显存（显卡里的物理内存）进行图形数据的存取和处理，然后通过 I/O 接口（如PCI/PCIe 插槽）将处理后的图像输出到显示器**

- 黑白图形模式: 显存中的对应位置为 1，屏幕上的相应像素就被点亮，呈现的是白色。若该位为 0，该像素就不会被点亮，只要不管该像素就是黑色

- 真彩色: 24 个 bit 表示一个颜色，即24 位对应一个像素

### ▶ 代码（通过显卡输出hello MBR）

```assembly
;主引导程序 
SECTION MBR vstart=0x7c00      
    mov ax,cs                  
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00       

    ;往gs寄存器中存入段基址
    mov ax,0xb800   ;由于显存文本模式中，其内存地址是 0xb8000，实模式下内存分段访问策略是“段基址*16+段内偏移地址”
    mov gs,ax       ;所以由0xb8000得到的段基址是其除以16,也就是右移4位，得：0xb800

    mov ax, 0x600              
    mov bx, 0x700              
    mov cx, 0                  
    mov dx, 0x184f	           
			                   
    int 0x10
    
    ; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
    mov byte [gs:0x00],'h'              ; gs为段跨越前缀，指定gs为段基址
    mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色

    mov byte [gs:0x02],'e'
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'l'
    mov byte [gs:0x05],0xA4   

    mov byte [gs:0x06],'l'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'o'
    mov byte [gs:0x09],0xA4

    mov byte [gs:0x0a],' '
    mov byte [gs:0x0b],0xA4

    mov byte [gs:0x0c],'M'
    mov byte [gs:0x0d],0xA4

    mov byte [gs:0x0e],'B'
    mov byte [gs:0x0f],0xA4

    mov byte [gs:0x10],'R'
    mov byte [gs:0x11],0xA4

    jmp $

    times 510-($-$$) db 0
    db 0x55,0xaa
```

![image-20240801102626566](/home/ZMR/.config/Typora/typora-user-images/image-20240801102626566.png)

---

## bochs

### 简介

1. 是一个开源 x86 虚拟机软件，支持硬件级别上的调试
2. bochs 的调试风格参照 gdb 来设计
3. 八进制（零开头）：011
   十进制：11
   十六进制（0x开头）：0x11

### Bochs 调试命令分类

- **Debugger control** 类：控制调试器行为，例如退出调试状态、设置寄存器值、显示模式信息等。
- **Execution control** 类：控制程序执行，例如继续执行、单步执行、执行下一条指令等。
- **Breakpoint management** 类：管理断点，例如设置断点、删除断点、禁用/启用断点等。
- **CPU and memory contents** 类：查看 CPU 和内存内容，例如查看内存内容、查看寄存器值、查看堆栈信息等。

### 常用调试命令介绍

#### Debugger control类

- `q|quit|exit`: 退出调试状态，关闭虚拟机。
- `set`: 设置寄存器值或其他选项，例如 `set reg = val` 设置寄存器值，`set u on|off` 设置是否反汇编指令。
- `show`: 显示信息，例如 `show mode` 显示模式信息，`show int` 显示中断信息，`show call` 显示函数调用信息。
- `traceon|off`: 设置是否在单步调试时反汇编代码。
- `u|disasm`: 反汇编代码。
- `ctrl+c`: 中断执行，回到 Bochs 控制台。

#### Execution control类

- `c|cont|continue`: 继续执行。
- `s|step`: 单步执行。
- `p|n|next`: 执行下一条指令。

#### Breakpoint management类

- `vb|vbreak`: 设置虚拟地址断点。
- `lb|lbreak`: 设置线性地址断点。
- `pb|pbreak|b|break`: 设置物理地址断点。
- `sb`: 设置指令数断点。
- `sba`: 设置 CPU 执行指令数断点。
- `watch`: 设置读写断点。
- `blist`: 显示所有断点信息。
- `bpd|bpe`: 禁用/启用断点。
- `d|del|delete`: 删除断点。

#### CPU and memory contents类

- `x`: 显示线性地址的内容。
- `xp`: 显示物理地址的内容。
- `setpmem`: 设置物理内存内容。
- `r|reg|regs|registers`: 显示寄存器值。
- `ptime`: 显示 Bochs 自启动之后，总执行指令数。
- `print-stack`: 显示堆栈信息。
- `?|calc`: 内置计算器。
- `info`: 显示信息，例如 `info pb` 查看断点信息，`info CPU` 显示 CPU 所有寄存器值，`info idt` 显示中断向量表 IDT，`info gdt` 显示全局描述符表 GDT，`info flags` 显示状态寄存器，`info tab` 显示页表信息。

### 常见调试步骤

> 调试 `#GP General Protection Exception` 的步骤如下

1. 启动调试

   - 使用 `show int` 命令查看中断状态。

   - 运行程序，使用 `c` 命令继续执行。


2. 查找异常
   - 观察控制台输出，注意到 `exception (not softint)` 行，确定异常发生的位置（如 `0008:c0001e1b`）。


3. 确定中断处理函数

   - 使用 `nm` 命令查找中断处理函数的符号信息：
     ```bash
     nm build/kernel.bin | grep 1e1b
     ```

   - 确认函数名（如 `intr##0x0d##entry`），这表明是 GP 异常的处理。


4. 设置断点

   - 在异常处理函数入口设置断点：
     ```bash
     lb 0xc0001e1b
     ```

   - 使用 `c` 命令继续执行，捕获到断点。


5. 查看寄存器状态
   - 使用 `r` 命令查看寄存器状态，特别是 `ebx` 和 `gs` 的值，检查是否存在无效的内存访问。


6. 检查内存

   - 使用 `sreg` 查看段寄存器的状态，确认 `gs` 段的基址和限制。

   - 使用 `x gs:ax` 检查内存，观察是否有超出范围的访问。


7. 分析段描述符
   - 使用 `info gdt 3` 查看 GDT 中的段描述符，确认段的 `limit` 是否足够。


8. 执行并验证

   - 逐步执行引发异常的指令：
     ```bash
     s
     ```

   - 如果再次触发 GP 异常，回到中断处理函数，分析错误原因。


9. 修复错误
   - 根据调试信息，修正代码中的越界访问错误，确保访问的内存地址在合法范围内。


10. 重复测试
    - 重新编译并测试程序，确保问题已解决，不再引发 GP 异常。


---

## 硬盘

- **硬盘控制器属于 IO 接口**，cpu通过硬盘控制器来与硬盘交流
- 因此硬盘控制器拥有端口，也就是它里面的寄存器。让硬盘工作，我们就需要读写硬盘控制器的端口

### ★★ 硬盘操作方法

- **硬盘读或写操作**的基本顺序
  1. **选择通道**：指定要操作的硬盘通道。
  2. **写入扇区数**：将待操作的扇区数写入 sector count 寄存器。
  3. **设置 LBA 地址**：将扇区起始地址的低 24 位写入 LBA 寄存器，并在 device 寄存器中设置 LBA 模式及选择硬盘。
  4. **写入命令**：将具体的操作命令（如读或写）写入 command 寄存器。
  5. **检查状态**：读取 status 寄存器，判断硬盘是否完成操作。
  6. **判断操作类型**：如果是读操作，继续下一步；如果是写操作，则结束。
  7. **读取数据**：从硬盘将数据读出。

- 硬盘工作完成后，它已经准备好了数据，通过下面**五种方式进行数据传送**

  （1）**无条件传送方式**：随时准备好了数据，CPU 随时取随时拿都没问题（如：寄存器、内存）

  （2）**查询传送方式**：也称为程序 I/O、PIO，传输之前，每次都由程序先去检测设备的状态（CPU花在查询上的时间多，效率低）

  （3）**中断传送方式**：也称为中断驱动 I/O，当数据源设备准备好数据后，硬盘控制器通过发中断来通知 CPU 来拿数据（避免CPU浪费时间在查询上，效率较高。但中断时，CPU就需要压栈出栈，浪费其资源）

  （4）**直接存储器存取方式（DMA）**：“直接”体现在 不让 CPU参与传输，完全由数据源设备和内存直接传输。CPU 直接到内存中拿数据就好了。（和中断比，它方便快捷。但DMA由硬件实现，需要DMA控制器）

  （5）**I/O 处理机传送方式**：在DMA基础上再引入I/O 处理机，专门用于处理 IO。（CPU彻底不用管了）

---

## 让MBR使用硬盘

### ▶ 代码

mbr.s

```assembly
;主引导程序 
%include "boot.inc"     ;nasm 编译器中的预处理指令,让编译器在编译之前把 boot.inc 文件包含进来
SECTION MBR vstart=0x7c00         
    mov ax,cs      
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00
    mov ax,0xb800
    mov gs,ax

    ; 清屏
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0                      
    mov dx, 184fh		           		                   
				                   
    int 10h                        

    ; 输出字符串:MBR
    mov byte [gs:0x00],'1'
    mov byte [gs:0x01],0xA4

    mov byte [gs:0x02],' '
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'M'
    mov byte [gs:0x05],0xA4	        ;A表示绿色背景闪烁，4表示前景色为红色

    mov byte [gs:0x06],'B'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'R'
    mov byte [gs:0x09],0xA4
	 
    ;下面三行为rd_disk_m_16 函数传递参数（用寄存器传递，这里用到eax、bx、cx 寄存器）
    mov eax,LOADER_START_SECTOR	    ; 待读入的起始扇区lba地址
    mov bx,LOADER_BASE_ADDR         ; 数据从硬盘读进来后，将其写入的内存地址
    mov cx,1			            ; 待读入的扇区数，因为此时大小不会512字节，因此1扇区即可

    call rd_disk_m_16		        ; ★★★调用函数 rd_disk_m_16 读取硬盘的一个扇区，从硬盘读取 loader 程序到指定的内存地址
  
    jmp LOADER_BASE_ADDR            ; ★★★跳转到 loader 的起始地址，执行 loader 程序
       

; 功能: 读取硬盘 n 个扇区的函数
rd_disk_m_16:
    ; eax = LBA 扇区号
    ; ebx = 将数据写入的内存地址
    ; ecx = 读入的扇区数

    mov esi, eax  ; 备份 EAX 寄存器的值（LBA 扇区号）
    mov di, cx    ; 备份 ECX 寄存器的值（待读入的扇区数）

    ; 通过下面五步进行磁盘读取
    ; 第一步：选择特定通道的寄存器，设置要读取的扇区数
    mov dx, 0x1f2  ; 选择端口 0x1f2
    mov al, cl     ; 设置要读取的扇区数
    out dx, al     ; 写入到端口

    mov eax, esi   ; 恢复 EAX 寄存器的值

    ; 第二步：将 LBA 地址的各部分写入端口 0x1f3 ~ 0x1f6
    mov dx, 0x1f3  ; 设置 LBA 地址的低 8 位
    out dx, al     ; 写入到端口

    mov cl, 8      ; 将 EAX 寄存器右移 8 位，设置 LBA 地址的 15~8 位
    shr eax, cl
    mov dx, 0x1f4
    out dx, al

    shr eax, cl    ; 将 EAX 寄存器右移 8 位，设置 LBA 地址的 23~16 位
    mov dx, 0x1f5
    out dx, al

    shr eax, cl    ; 将 EAX 寄存器右移 8 位，设置 LBA 地址的 27~24 位
    and al, 0x0f   ; 只保留低 4 位
    or al, 0xe0    ; 设置高 4 位为 1110，表示 LBA 模式
    mov dx, 0x1f6
    out dx, al

    ; 第三步：向 0x1f7 端口写入读命令，0x20
    mov dx, 0x1f7
    mov al, 0x20  ; 设置读命令
    out dx, al   ; 写入到端口

    ; 第四步：检测硬盘状态，等待硬盘准备好数据传输
.not_ready:
    nop         ; 相当于 sleep，等待
    in al, dx   ; 从端口读取硬盘状态
    and al, 0x88  ; 检查第 4 位和第 7 位
    cmp al, 0x08  ; 如果第 4 位为 1，表示硬盘控制器已准备好数据传输
    jnz .not_ready  ; 如果未准备好，继续等待

    ; 第五步：从 0x1f0 端口读数据
    mov ax, di  ; 获取待读入的扇区数
    mov dx, 256  ; 每个扇区 512 字节，一次读取 2 字节，共需读取 256 次
    mul dx      ; 计算总读取次数
    mov cx, ax  ; 将总读取次数存入 CX 寄存器
    mov dx, 0x1f0  ; 设置数据端口

.go_on_read:
    in ax, dx    ; 从端口读取数据
    mov [bx], ax  ; 将数据写入内存
    add bx, 2    ; 增加内存地址指针
    loop .go_on_read  ; 循环读取，直到 CX 为 0

    ret  ; 返回，回到调用 rd_disk_m_16 的地方

    times 510-($-$$) db 0  ; 填充到 510 字节
    db 0x55, 0xaa  ; MBR 签名
```

loader.s

```assembly
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR  ; 定义代码段的起始地址为 LOADER_BASE_ADDR

; 输出背景色绿色，前景色红色，并且跳动的字符串"2 LOADER"
mov byte [gs:0x00],'2'
mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色

mov byte [gs:0x02],' '
mov byte [gs:0x03],0xA4

mov byte [gs:0x04],'L'
mov byte [gs:0x05],0xA4   

mov byte [gs:0x06],'O'
mov byte [gs:0x07],0xA4

mov byte [gs:0x08],'A'
mov byte [gs:0x09],0xA4

mov byte [gs:0x0a],'D'
mov byte [gs:0x0b],0xA4

mov byte [gs:0x0c],'E'
mov byte [gs:0x0d],0xA4

mov byte [gs:0x0e],'R'
mov byte [gs:0x0f],0xA4

jmp $		                        ; 通过死循环使程序悬停在此

```

boot.inc

```assembly
; loader和kernel
LOADER_BASE_ADDR equ 0x900 ;相当于c语言的#define LOADER_BASE_ADDR 0x900
                           ;定义了 loader 在内存中的位置,MBR 要把 loader 从硬盘读入后放到此处
                           ;即后面 loader 会存在内存地址 0x900 处
LOADER_START_SECTOR equ 0x2 ;loader 程序在硬盘上的起始扇区
```

![image-20240801212706705](/home/ZMR/.config/Typora/typora-user-images/image-20240801212706705.png)

### ★★★ 代码讲解

> `mbr.s` 的作用主要是引导计算机的启动过程。它位于硬盘的第一个扇区（MBR，主引导记录），由 BIOS 加载并执行。
>
> `mbr.s` **成功将 loader 程序从硬盘读取到内存中，并跳转到 loader 程序的起始地址开始执行**

1. **初始化硬件环境**：

   - 设置段寄存器（CS、DS、ES、SS、FS）和栈指针（SP），确保程序可以正确访问内存和使用栈。

2. **清屏操作**：

   - 使用 BIOS 中断清除屏幕，并设置屏幕显示的模式，以便后续的输出操作。

3. **输出信息**：

   - 在屏幕上显示一个简单的字符串（如 "1 MBR"），用于表明 MBR 程序已经成功加载并开始执行。

4. **准备读取 loader**：

   - 设置 `eax` 为 `LOADER_START_SECTOR`（loader 在硬盘上的起始扇区），`bx` 为 `LOADER_BASE_ADDR`（将数据从硬盘读入的内存地址），`cx` 为 `1`（待读入的扇区数）。

5. **★★★调用 `rd_disk_m_16` 函数**：

   - 调用 

     ```
     rd_disk_m_16
     ```

      函数读取硬盘上的 loader 程序。该函数执行以下步骤：

     - 设置待读取的扇区数。
     - 将 LBA 地址写入相应端口。
     - 向硬盘发送读命令。
     - 等待硬盘准备好数据传输。
     - 从硬盘读取数据并写入内存。

6. **★★★跳转到 loader 程序**：

   - 读取完成后，使用 `jmp LOADER_BASE_ADDR` 跳转到 loader 程序的起始地址（`0x900`）执行。

---

---

---

 # 第四章 保护模式入门

- 实模式，指的是 32 位的 CPU 运行在 16 位模式下的状态
- 开机时，32 位的 CPU 是先处于实模式，之后再进入保护模式的
- 加入保护模式的三个步骤：

  **（1）打开 A20。**
  **（2）加载 gdt。**
  **（3）将 cr0 的 pe 位置 1。**

## 保护模式相对于实模式的拓展

### 寄存器拓展

![image-20240802170318832](/home/ZMR/.config/Typora/typora-user-images/image-20240802170318832.png)

#### 80286

- 80286是8086的下一代，但**有了保护模式**
- 因为有保护模式，所以引入数据结构：**全局描述符表**
  - 表中至少有一个表项，其中每一个表项称为段描述符，其大小为 64 字节，用来描述各个内存段的起始地址、大小、
    权限等信息。
  - 但：段描述符是**在内存中**，访问内存对 CPU 来说是比较慢的动作，**效率不高**。
  - 但：段描述符的格式很奇怪，一个**数据要分三个地方存**，所以将这些数据拼起来很**费时间**。
  - 综上：为了提高获取段信息的效率，引入**段描述符缓冲寄存器**，将段信息用一个寄存器来缓存。以后每次访问相同的段时，就直接读取该段寄存器对应的段描述符缓冲寄存器。该缓存内容的失效时间为：只要往段寄存器中赋值（即更新选择子），CPU 就会重新访问全局描述符表，再将获取的段信息重新放回段描述符缓冲寄存器
- 偏移地址和实模式一样
- 段寄存器中保存的不是段基址，而是**“选择子”**，该选择子就是个**数**，用这个数来**索引全局描述符表中的段描述符**（把全局描述符表当成数组，选择子就像数组下标一样）

#### ★★★ 8086、80286以及80386

| CPU型号 | 位数 | 地址线位数 | 内存大小              | 段基址位数 | 寄存器位宽 |
| ------- | ---- | ---------- | --------------------- | ---------- | ---------- |
| 8086    | 16位 | 20条       | 1 MB（20位地址空间）  | 16位       | 16位       |
| 80286   | 16位 | 24条       | 16 MB（24位地址空间） | 24位       | 16位       |
| 80386   | 32位 | 32条       | 4 GB（32位地址空间）  | 32位       | 32位       |

- 8086与80286被淘汰
  - **是 24 位段基址，段内相对偏移地址还是必不可少的。用于寻址的通用寄存器还是 16 位，即单独的一个寄存器还是只能访问 64KB 的空间。如果用寄存器作为段内偏移地址，段的大小还是 64KB，这就白白浪费了 24 位段基址的优势，要是想访问完整的 16MB 内存，依然要不断地变换段基址**，所以 80286 很快就被淘汰了
  -  **寻址限制**
    - **段大小限制**：在 80286 和 8086 的 16 位架构中，**段内偏移地址最大为 64KB**（因为寄存器位宽都为16位）。每个段的地址范围从 0 到 65535（2^16 - 1），这意味着**每个段无法超过 64KB**。
    - **影响大型应用**：对于现代应用程序，尤其是需要大量数据或执行复杂算法的程序，64KB 的限制显得非常狭窄。开发者必须分割数据和代码到多个段中，导致内存管理变得繁琐。
    - **额外的复杂性**：程序必须设计为跨多个段工作，这可能导致代码的复杂性增加。
  -  **频繁变换段基址**
    - **频繁调整段基址**：为了访问超过单个段的 64KB 内存，程序必须通过**改变段寄存器的值来访问不同的段**。
    - **性能开销**：每次变换段基址需要 CPU 执行额外的指令，消耗处理时间，降低性能。
    - **不适应多任务处理**：在多任务操作系统中，频繁切换段基址会导致上下文切换的效率降低，影响系统性能和速度。
- 80386的平坦模式
  - **段基址是 32 位，单独的一个寄存器也是 32 位，任意一个段都可以访问到 4GB 空间，不用再变化段基**
    **址了。**
  - 甚至段基址可以是 0，光用段内偏移就可以指向 4GB 空间任意角落。这就开启了“平坦模式”

---

### 寻址方式拓展

![image-20240802194950350](/home/ZMR/.config/Typora/typora-user-images/image-20240802194950350.png)

- 保护模式下：基址寄存器不再只是 bx、bp，而是所有 32 位的通用寄存器
- 变址寄存器也是一样，不再只是 si、di，而是除 esp 之外的所有 32 位通用寄存器
- 偏移量由实模式的 16 位变成了 32 位。并且，还可以对变址寄存器乘以一个比例因子

---

### 运行模式反转

#### bits 伪指令指定运行模式

- bits 的指令格式是[bits 16]或[bits 32]。
  [bits 16]是告诉编译器，下面的代码帮我编译成 16 位的机器码。
  [bits 32]是告诉编译器，下面的代码帮我编译成 32 位的机器码。

![image-20240802195256765](/home/ZMR/.config/Typora/typora-user-images/image-20240802195256765.png)

#### 0x66：操作数大小反转前缀

- 16 位实模式下可以用 32 位保护模式下的寄存器，需要**在指令前添加指令前缀 0x66**

  ![image-20240802195421174](/home/ZMR/.config/Typora/typora-user-images/image-20240802195421174.png)

  - 第 3 行用到了 32 位寄存器 eax，属于 32 位操作数，由于当前模式是 16 位，要用 0x66 将操作数大小转为
    32 位，故机器码是 66B834120000。其中 34120000 是另一操作数，B8 是操作码，0x66 便是操作数反转前缀。

#### 0x67：寻址方式反转前缀

- 使用对方模式下的寻址方式

  ![image-20240802200122325](/home/ZMR/.config/Typora/typora-user-images/image-20240802200122325.png)

  - 第 2 行的指令，从操作数和寻址方式来看，本身符合 16 位模式，无需添加任何反转前缀。
  - 第 3 行把eax 寄存器作为基址寻址，eax 寄存器不属于实模式，所以在机器码前添加了寻址方式反转前缀 0x67。
  - 第4 行同样是用 eax 寄存器作为基址寻址，并且用到了伪指令 dword，表示在 eax 所表示的内存处，连续写入 4 字节大小的数据。操作数大小也由默认的 2 字节变成了 4 字节，就会添加 0x66 的前缀

---

### 指令扩展

- 在实模式环境下：
  当压入 8 位立即数时，由于实模式下默认操作数是 16 位，CPU 会将其扩展为 16 位后再将其入栈，sp-2。
  当压入 16 位立即数时，CPU 会将其直接入栈，sp-2。
  当压入 32 位立即数时，CPU 会将其直接入栈，sp-4。

- 在保护模式下：
  当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp 指针减 4。
  当压入 16 位立即数时，CPU 直接压入 2 字节，esp 指针减 2。
  当压入 32 位立即数时，CPU 直接压入 4 字节，esp 指针减 4。

- 对于段寄存器入栈：

  即 cs、ds、es、fs、gs、ss，无论在哪种模式下，都是按当前模式的默认操作数大小压入的。例如，在 16 位模式下，CPU 直接压入 2 字节，栈指针 sp 减 2。在 32 位模式下，CPU 直接压入 4 字节，栈指针 esp 减 4。

- 对于通用寄存器和内存：无论是在实模式或保护模式
  y 如果压入的是 16 位数据，栈指针减 2。
  y 如果压入的是 32 位数据，栈指针减 4。

---

---

## 全局描述符表GDT（从实模式进入保护模式前做的准备）	

全局描述符表（Global Descriptor Table，GDT）是**保护模式下内存段的登记表**，这是不同于实模式的显著特征之一。

### 段描述符

![image-20240802205043588](/home/ZMR/.config/Typora/typora-user-images/image-20240802205043588.png)

- **段描述符**：用于描述内存段（如数据段、代码段等）的属性，结构大小为8字节（64位），分为低32位和高32位两部分，但必须连续存储。**CPU读取段描述符以获取段的正确信息，并缓存到段描述符缓冲寄存器中**。

  ```assembly
                                                          ;-------构建全局描述符表，并直接在里面填充段描述符-----------
  GDT_BASE:                                               ;GDT 的起始地址是标号 GDT_BASE所在的地址
      dd 0x00000000                                       ;下面定义了三个段描述符，每个描述符8字节
  	dd 0x00000000                                       ;因为第0个描述符不可用，所以前8个字节用0填充，因此下面段描述符是从第一个开始
  
  CODE_DESC:                                              ;---第一个：代 码 段 描 述 符 CODE_DESC
      dd 0x0000FFFF                                       ;低 4 字节中：低 2 字节是段界限的 0～15 位，高 2 字节是段基址的 0～15 位
  	dd DESC_CODE_HIGH4                                  ;高 4 字节中:复杂的字段已经在boot.inc文件里以宏的形式定义好了，这里直接用即可（下面两个同理）
  
  DATA_STACK_DESC:                                        ;---第二个：数 据 段 和 栈 段 描 述 符 DATA_STACK_DESC
      dd 0x0000FFFF
      dd DESC_DATA_HIGH4
  
  VIDEO_DESC:                                             ;---第三个：显存段描述符 VIDEO_DESC
      dd 0x80000007	                                    
      dd DESC_VIDEO_HIGH4                                 
  ```

  

#### ★★★ 段基址和段界限

- 段基址：表示**内存段的起始地址**，通常为32位地址（在段描述符中被拆成了三段）。
- 段界限：表示**段的大小和范围**，用20位二进制数表示（在段描述符中被拆成了两段）。它的作用是**限制段内偏移地址的范围**。段界限可以表示的单位量为1B（G位为0）或4KB（G位为1）。段的实际大小计算公式为：
  - G位为0时：实际段界限 = （描述符中段界限+1）*1 -1 = 描述符中段界限
  - G位为1时：实际段界限 = （描述符中段界限+1）*4KB -1
- 例：G位为1时，如果是平坦模型，描述符段界限为 0xFFFFF，那么实际段界限边界值=0x100000*0x1000-1=0xFFFFFFFF。
  - 这意味着段的地址范围从0到0xFFFFFFFF（即4GB）


#### 内存访问

- 内存访问需要提供“段基址：段内偏移地址”，其中段界限用来限制段内偏移地址的范围。如果偏移地址超过段界限的范围，CPU会抛出异常。

#### 段描述符结构

低32位

- 前16位：存储段界限的低16位（0-15位）
- 后16位：存储段基址的低16位（0-15位）

高32位

- 0-7位：存储段基址的中间8位（16-23位）
- 8-11位：Type字段，指定描述符类型
- 12位：S字段，指示是否是系统段（0）或非系统段（1）
- 13-14位：DPL字段，描述符特权级，表示内存段的特权级
- 15位：P字段，指示段是否存在（1表示存在，0表示不存在）
- 16-19位：存储段界限的高4位（16-19位）
- 20位：AVL字段，用户可用位
- 21位：L字段，设置是否是64位代码段（1表示64位，0表示32位）
- 22位：D/B字段，指示有效地址和操作数的大小
- 23位：G字段，粒度，决定段界限的单位大小（0为1B，1为4KB）
- 24-31位：存储段基址的高8位（24-31位）

#### Type字段（Type字段和S字段组合确定描述符类型）

- 系统段类型（S为0）
  - 各种“门”结构，如调用门、任务门、中断门、陷阱门等
- 非系统段类型（S为1）
  - 代码段
    - X: 可执行位（1表示可执行，0表示不可执行）
    - R: 可读位（1表示可读，0表示不可读）
    - C: 一致性代码段（1表示一致性，0表示非一致性）
  - 数据段
    - E: 段扩展方向（0表示向上扩展，1表示向下扩展）
    - W: 可写位（1表示可写，0表示不可写）

#### 特权级（DPL字段）

- 保护模式下，将计算机世界按权力划分成不同等级，分别为0、1、2、3级，**数字越小特权级越大。保护模式下的操作系统处于最高的0特权级，用户程序通常处于最低的3特权级。**

#### 粒度（G字段）

- 段界限的单位大小：
  - G为0：单位为1字节，段最大为1MB（2的 20 次方*1 字节）
  - G为1：单位为4KB，段最大为4GB（2 的 20 次方*4KB 字节）

---

### 全局描述符表 GDT、局部描述符表 LDT 及选择子

#### 段描述符的定义

在保护模式下，段描述符用于描述内存段的属性，包括基地址、段界限、段类型等。每个内存段（如代码段、数据段、栈段等）都需要一个段描述符。

#### 全局描述符表（GDT）

段描述符被存储在全局描述符表（Global Descriptor Table, GDT）中。GDT 是一个数组，其中每个元素都是一个8字节的段描述符。GDT 可以被多个程序共享，因此称为“全局”描述符表。第0个段描述符不可用。

#### GDT 寄存器（GDTR）

GDT 位于内存中，CPU 通过一个专用寄存器 GDTR（GDT Register）来指向 GDT。GDTR 是一个48位的寄存器，前16位存储GDT的大小（以字节为单位），后32位存储GDT的起始地址。我们用 `lgdt` 指令来加载 GDTR。

![image-20240803105229063](/home/ZMR/.config/Typora/typora-user-images/image-20240803105229063.png)

```assembly
gdt_ptr dw GDT_LIMIT      	;定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址
	    dd  GDT_BASE
...
lgdt [gdt_ptr]				;加载GDT（进入保护模式的其中一步）
```



#### 选择子（Selector）

段寄存器（如CS、DS、ES、FS、GS、SS）在保护模式下存储的是选择子，而不是段基地址。选择子用于在段描述符表（GDT或LDT）中索引段描述符。

![image-20240803105058313](/home/ZMR/.config/Typora/typora-user-images/image-20240803105058313.png)

选择子是16位的，包含：

- 低2位：请求特权级（RPL, Request Privilege Level）。
- 第2位：表指示位（TI, Table Indicator），0表示GDT，1表示LDT。
- 高13位：描述符索引，用于在GDT或LDT中索引段描述符。

```assembly
SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0 
SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0
SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0
```



#### 保护模式下的内存分段

即使在保护模式下，IA-32架构仍然使用段基址和段内偏移地址的形式访问内存。但由于32位地址线和32位寄存器可以直接提供32位地址，**不需要再将段基址乘以16后与段内偏移地址相加**。选择子指向的段描述符中的段基址**直接加**上段内偏移地址就构成了实际的内存地址。

#### LDT（局部描述符表）

LDT（Local Descriptor Table）是为了支持多任务，每个任务可以有自己的LDT。LDT的地址存储在LDTR寄存器中，使用`lldt`指令加载。与GDT不同，LDT中的第0个段描述符是可用的，因为TI位指示选择子是在LDT中索引段描述符。

---

### ★★★ GDTR、GDT、选择子、段描述符、段描述符缓冲寄存器、内存段的关系

![image-20240803105526222](/home/ZMR/.config/Typora/typora-user-images/image-20240803105526222.png)

- GDTR寄存器（数组指针）存的是GDT的内存地址及大小，GDT（数组）的内容是段描述符（数组元素），通过选择子（数组下标）对全局描述符表进行下标索引，找到相应的段描述符，而段描述符里存的是内存段的各种信息（数组中每个元素都是一个结构体，这个结构体代表一段的内存区域）

- 即：★★★ **`通过GDTR寄存器定位GDT，通过选择子索引到GDT中的具体段描述符，将段描述符的内容缓存到段描述符缓冲寄存器中，从段描述符中取得内存段的各种信息，从而完成对内存的访问和管理。`**

- 例子：内存访问过程

  假设选择子为 `0x8` 并加载到 DS 寄存器：

  1. 低2位（RPL）为 `00`。
  2. 第2位（TI）为 `0`，表示在GDT中索引段描述符。
  3. 高13位为 `0x1`，表示在GDT中索引第1个段描述符（GDT中的第0个段描述符不可用）。

  假设第1个段描述符的段基址为 `0x1234`。访问内存地址 `ds:0x9` 的过程如下：

  1. 如果选择子 `0x8` 已加载到 DS 寄存器，CPU检查段描述符缓冲寄存器，发现段基址 `0x1234` 已缓存，则直接从段描述符缓冲寄存器中取出段描述符，到第三步。若无，则到第二步。
  2. CPU使用选择子 `0x8` 在GDT中索引第1个段描述符，得到其段描述符，获得段基址 `0x1234`。CPU将段描述符的内容（如段基址 `0x1234`、段界限、属性等）缓存到 DS 寄存器的段描述符缓冲寄存器中（段寄存器DS的隐藏部分）。
  3. 将段基址 `0x1234` 与段内偏移地址 `0x9` 相加，得到实际内存地址 `0x123d`。
  
  ```assembly
      ;选择子被加载到段寄存器（如DS寄存器）是发生在程序显式执行以下指令时
      mov ax,SELECTOR_DATA
      mov ds,ax
      mov es,ax
      mov ss,ax
      mov esp,LOADER_STACK_TOP
      mov ax,SELECTOR_VIDEO
      mov gs,ax
  ```

---

### A20 地址线

在实模式下，内存访问采用“段基址：段内偏移地址”的形式，段基址需要乘以16再加上段内偏移地址。由于寄存器是16位的，段基址和段内偏移地址的最大值均为0xFFFF。这样计算出的最大地址为：

0xFFFF0+0xFFFF=0x10FFEF

但实模式下的地址线是20位，最大寻址空间是1MB，即0x00000～0xFFFFF。因此，**超过1MB的部分在逻辑上是正常的，但物理内存中没有与之对应的部分**。为了让这种地址计算方式继续可用，CPU**采用地址回绕的方法，将超过1MB的部分自动回绕到0地址，继续从0地址开始映射，即将地址对1MB求模**。

> 在实模式下，是真有可能回绕后的地址位置上本来就有别人的地址。
>
> 为了最大程度上保证系统运行的稳定，减少地址回绕时对低地址产生的影响，设计时，特意将核心的代码和内容放在了高地址的地方。

#### 地址回绕的实现

地址回绕有两种情况：

1. **只有20位地址线的CPU（如8086/8088）**：

   - 8086/8088只有20位地址线（A0～A19），最大内存空间是1MB（0x0～0xFFFFF）。
   - 当地址进位到1MB以上，如0x100000，由于没有第21位地址线，进位的1被丢掉，地址变成0x00000。

   ![image-20240803110825941](/home/ZMR/.config/Typora/typora-user-images/image-20240803110825941.png)

   2 . **80286及其后的CPU**：

   - 80286及以后的CPU有24位地址线（A0～A23），可以访问16MB的内存。
   - 但为了兼容8086/8088，80286在实模式下应表现得与8086/8088一样，只使用20条地址线（即A20线是关闭的）。这意味着如果访问0x100000～0x10FFEF之间的内存，系统应该回绕到0地址。

   为了解决此问题，IBM设计了一种通过键盘控制器上的输出线来控制A20地址线有效性的机制，称为A20Gate：

   - **A20Gate打开**：当访问0x100000～0x10FFEF之间的地址时，CPU**将访问实际的物理内存**。
   - **A20Gate关闭**：当访问0x100000～0x10FFEF之间的地址时，CPU**将采用8086/8088的地址回绕**。

#### 保护模式中的A20Gate

在保护模式下，需要突破20条地址线（A20）以访问更大的内存空间。这需要关闭地址回绕，即打开A20Gate。

打开A20Gate的步骤非常简单，通过设置端口0x92的第1位为1即可，具体步骤如下：

```assembly
;进入保护模式的其中一步
in al, 0x92
or al, 0000_0010B
out 0x92, al
```

---

### CR0 寄存器的 PE 位

- CR0寄存器的第 0 位，即 PE 位，Protection Enable，此位用于启用保护模式，是保护模式的开关

![image-20240803112254281](/home/ZMR/.config/Typora/typora-user-images/image-20240803112254281.png)

- PE 为 0 表示在实模式下运行，PE 为 1 表示在保护模式下运行

  ```assembly
  ;进入保护模式的其中一步
  mov eax, cr0			;将 cr0 写入 eax
  or eax, 0x00000001		;通过或运算 or 指令将 eax 的第 0 位置 1
  mov cr0, eax			;将 eax 写回 cr0，这样 cr0 的 PE 位便为 1 了
  ```
  
  

---

### 从实模式进入保护模式

#### ▶ 代码

mbr.S

- 注：由于 loader.bin 超过了 512 字节，故将扇区数直接扩为。其他内容同"让MBR使用硬盘"

```assembly
...
mov cx,4; 待读入的扇区数
...
```



boot.inc

**定义了模块化段描述符字段宏和模块化选择子字段宏**

```assembly
                            ;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900  ;相当于c语言的#define LOADER_BASE_ADDR 0x900
                            ;定义了 loader 在内存中的位置,MBR 要把 loader 从硬盘读入后放到此处
                            ;即将来 loader 会在内存地址 0x900 处
LOADER_START_SECTOR equ 0x2 ;loader 程序在硬盘上的起始扇区

                                                    ;--------------   模块化的gdt描述符字段宏-------------
DESC_G_4K   equ	  1_00000000000000000000000b        ;设置段界限的单位为4KB
DESC_D_32   equ	   1_0000000000000000000000b        ;设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位，而非16位
DESC_L	    equ	    0_000000000000000000000b	    ;64位代码段标记位，我们现在是在编写32位操作系统，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	    ;此标志位是为了给操作系统或其他软件设计的一个自定义位，
                                                    ;可以将这个位用于任何自定义的需求。
                                                    ;比如，操作系统可以用这个位来标记这个段是否正在被使用，或者用于其他特定的需求。
                                                    ;这取决于开发者如何使用这个位。但从硬件的角度来看，AVL位没有任何特定的功能或意义，它的使用完全由软件决定。
DESC_LIMIT_CODE2  equ 1111_0000000000000000b        ;定义代码段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2              ;定义数据段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b        ;定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0
DESC_P	    equ		  1_000000000000000b            ;定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中
DESC_DPL_0  equ		   00_0000000000000b            ;定义DPL为0的字段
DESC_DPL_1  equ		   01_0000000000000b            ;定义DPL为1的字段
DESC_DPL_2  equ		   10_0000000000000b            ;定义DPL为2的字段
DESC_DPL_3  equ		   11_0000000000000b            ;定义DPL为3的字段
DESC_S_CODE equ		     1_000000000000b            ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_DATA equ	  DESC_S_CODE                       ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_sys  equ		     0_000000000000b            ;将段描述符的S位置为0，表示系统段
DESC_TYPE_CODE  equ	      1000_00000000b	        ;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	        ;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.


                                                    ;定义代码段，数据段，显存段的高32位--->在loader.s里面定义段描述符时用到
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

                                                    ;--------------   模块化的选择子字段宏  ---------------
RPL0  equ   00b                                     ;定义选择字的RPL为0
RPL1  equ   01b                                     ;定义选择子的RPL为1
RPL2  equ   10b                                     ;定义选择字的RPL为2
RPL3  equ   11b                                     ;定义选择子的RPL为3
TI_GDT	 equ   000b                                 ;定义段选择子请求的段描述符是在GDT中
TI_LDT	 equ   100b                                 ;定义段选择子请求的段描述符是在LDT中
```



loader.S

准备并进入保护模式后利用初始化的GDT表中的显存段描述符来对显存寻址后操作以显示字符

```assembly
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
    jmp loader_start					                ;loader一进来是下面一大堆GDT段描述符数据，无法执行，所以要跳过
                                                        ;虽然代码在执行时跳过了定义部分，但定义部分的数据已经被加载到内存中，并可以通过相关的指令来访问和使用
   
                                                        ;-----------------   保护模式前的准备过程   -------------------
                                                        
                                                        ;-------构建全局描述符表，并直接在里面填充段描述符-----------
GDT_BASE:                                               ;GDT 的起始地址是标号 GDT_BASE所在的地址
    dd 0x00000000                                       ;下面定义了三个段描述符，每个描述符8字节
	dd 0x00000000                                       ;因为第0个描述符不可用，所以前8个字节用0填充，因此下面段描述符是从第一个开始

CODE_DESC:                                              ;---第一个：代 码 段 描 述 符 CODE_DESC
    dd 0x0000FFFF                                       ;低 4 字节中：低 2 字节是段界限的 0～15 位，高 2 字节是段基址的 0～15 位
	dd DESC_CODE_HIGH4                                  ;高 4 字节中:复杂的字段已经在boot.inc文件里以宏的形式定义好了，这里直接用即可（下面两个同理）

DATA_STACK_DESC:                                        ;---第二个：数 据 段 和 栈 段 描 述 符 DATA_STACK_DESC
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

VIDEO_DESC:                                             ;---第三个：显存段描述符 VIDEO_DESC
    dd 0x80000007	                                    ;limit=(0xbffff-0xb8000)/4k=0x7
    dd DESC_VIDEO_HIGH4                                 ; 此时dpl已改为0

    GDT_SIZE equ $ - GDT_BASE                           ;--------计算gdt的界限--------
    GDT_LIMIT equ GDT_SIZE - 1 

    times 60 dq 0					                    ;--------此处预留60个描述符的空间--------

                                                        ;--------构建代码段、数据段、显存段的选择子-----------
    SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0       ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	    ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	    ; 同上 

                                                        ;-------定义全局描述符表 GDT 的指针(用于 lgdt 加载 GDT 到 gdtr 寄存器)-----------
gdt_ptr dw GDT_LIMIT                                    ;定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址，
	    dd  GDT_BASE
loadermsg db '2 loader in real.'

loader_start:
                                                        ;----------------------------------------------------------
                                                        ;INT 0x10    功能号:0x13    功能描述:打印字符串“2 loader in real.”
                                                        ;---------------------------------------------------------- 
    mov sp,LOADER_BASE_ADDR
    mov	bp,loadermsg                                    
    mov	cx,17			                                
    mov	ax,0x1301		                                
    mov	bx,0x001f		                                
    mov	dx,0x1800		                                
    int	0x10                                            

                                                        ;-----------------   准备进入保护模式   ----------------------
                                                        ;1 打开A20
                                                        ;2 加载gdt
                                                        ;3 将cr0的pe位置1

                                                        ;-----------------  打开A20  ----------------
    in al, 0x92
    or al, 0000_0010B
    out 0x92,al

                                                        ;-----------------  加载GDT  ----------------
    lgdt [gdt_ptr]


                                                        ;-----------------  cr0第0位置1  ----------------
    mov eax,cr0
    or eax,0x00000001
    mov cr0,eax

                                                        ;jmp dword SELECTOR_CODE:p_mode_start	    
    jmp  SELECTOR_CODE:p_mode_start	                    ; 刷新流水线，避免分支预测的影响。这种cpu优化策略，最怕jmp跳转，
					                                    ; 这将导致之前做的预测失效，从而起到了刷新的作用。

[bits 32]
p_mode_start:
                                                        ;---------用构29行的选择子初始化成各段寄存器----------
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

    mov byte [gs:160], 'P'

    jmp $

```

#### 代码解释

- loader.S 中第 4 行的“jmp loader_start”，其机器码是 E91702，共 3 字节大小。其中的 E9 是操作码，1702 是操作数，由于是小端字节序，所以其十六进制是 0x217，这是 16 位相对近转移。此指令直接跳过 GDT 定义相关部分，直接到第 32 行。第 32 行的标号 loader_start 在文件内的地址是“jmp loader_start”的 3 字节机器码+4 个段描述符大小+预留的 60 个描述符大小+gdt_ptr 的 6 字节+loadermsg 的 17 个字节=3+32+480+6+17=538=0x21a。再加上 loader 被加载到的地址 0x900，在内存中的实际地址为 0x900+0x21a=0xb1a。

  - 如果不包括第 4 行的 jmploader_start，那么 loader_start 的地址将是 0xb1a-3=0xb17。也就是说，如果把
    mbr 中跳入 loader 的语句 jmp LOADER_BASE_ADDR，改成 jmp LOADER_BASE_ADDR+ 0xb17，其结
    果也是一样的，直接跳转到 loader.S 中的 loader_start

  

  ![image-20240803165339199](/home/ZMR/.config/Typora/typora-user-images/image-20240803165339199.png)

- loader.S文件打印了：左下角的字符串“2 loader in real”是在实模式下用 BIOS 中断 0x10 打印的。左上角第 2 行的字符'P'，这是咱们在保护模式下输出的

- mbr.S文件打印了：左上角第一行的“1 MBR”

- loader.S文件逻辑：[点击](https://blog.csdn.net/kanshanxd/article/details/130749718)

---

---

## 处理器微架构（提升执行效率的策略）

### 流水线

![image-20240803210139690](/home/ZMR/.config/Typora/typora-user-images/image-20240803210139690.png)

​	流水线是指**将指令的执行过程分成多个步骤，并且每个步骤由不同的硬件单元独立执行**。比如，我们可以将“砸钉子”这一过程分为两个步骤：“取钉子”和“砸钉子”，每个步骤分别需要1秒。如果按照顺序执行，每2秒能完成一个钉子。若将取钉子和砸钉子两个步骤重叠执行，每秒就能完成一个钉子。应用到CPU中，指令的执行可以分为取指令、译码和执行三个步骤，这样在**同一时钟周期内，CPU可以同时执行三条不同指令的不同步骤**，大大提高了效率。

​	CPU 是按照程序中指令顺序来填充流水线的，也就是说按照程序计数器 PC（x86中是 cs：ip）中的值来装载流水线的，当前指令和下一条指令在空间上是挨着的。如果当前执行的指令是jmp，下一条指令已经被送上流水线译码了，第三条指令已经被送上流水线取指了。而CPU 早已经跳到别处去执行了，第二、三条指令用不上了，**所以 CPU 在遇到无条件转移指令 jmp 时，需要清空流水线。**



#### 使用远跳转指令清空流水线，更新段描述符缓冲寄存器

在**进入保护模式时**，我们需要解决两个问题：**更新段描述符缓冲寄存器和清空流水线**。我们使用的指令是：

```assembly
jmp dword SELECTOR_CODE:p_mode_start
```

更新段描述符缓冲寄存器

- **问题**：段描述符缓冲寄存器未更新，仍包含实模式的值。
- **解决**：在进入保护模式后，立即更新段描述符缓冲寄存器，加载正确的选择子。
- **原因**：保护模式需要正确的段描述符，而实模式的值会导致错误。

清空流水线

- **问题**：指令译码错误，导致16位和32位指令混用。
- **解决**：使用远跳转指令清空流水线。
- **原因**：保护模式下指令是32位，而流水线中已存在的16位指令会导致错误。

---

### 乱序执行

乱序执行是指CPU不按照代码中的顺序执行指令，而是根据指令之间的依赖关系和硬件资源的空闲状态来安排指令的执行顺序。例如，以下代码中第1行和第2行不能乱序执行，因为第2行依赖第1行的结果：

```assembly
mov eax, [0x1234]
add eax, ebx
```

但如果修改为以下代码，第2行可以在第1行内存访问的等待过程中执行：

```assembly
mov eax, [0x1234]
add ecx, ebx
```

这种策略利用指令之间的独立性，提高了流水线的效率。

### 缓存

缓存是用来缓解存储设备访问速度较慢的问题的一种机制。CPU中通常有一级缓存（L1）、二级缓存（L2）和三级缓存（L3）。缓存利用程序的局部性原理，最近访问的数据和靠近当前访问的数据在将来一段时间内也会被频繁访问，通过将这些数据加载到缓存中，可以减少CPU对内存的访问次数，从而提高效率。

### 分支预测

分支预测是在处理器遇到分支指令时，预测哪条路径更可能被执行，并提前将预测路径的指令放入流水线中执行。例如，在以下代码中：

```c
if (condition) {
    // do something
} else {
    // do something else
}
```

CPU会预测`condition`是true还是false，从而决定加载哪部分指令到流水线中。如果预测正确，程序会更快地执行。

---

---

## 对内存段的保护（保护模式保护了什么）

### 段寄存器加载选择子时的保护

当引用一个内存段时，需要将选择子加载到段寄存器。为了防止非法引用内存段，处理器在以下几个方面进行检查：

![image-20240803214119648](/home/ZMR/.config/Typora/typora-user-images/image-20240803214119648.png)

1. **选择子是否超越界限**：
   - 选择子的高13位是段描述符的索引值（第0～1位是RPL，第2位是TI位）。
   - 处理器验证选择子的索引值是否在描述符表（GDT或LDT）的界限内。
2. **描述符表基地址和界限值检查**：
   - 如果TI位是0，从全局描述符表寄存器（GDTR）中获取GDT基地址和界限值。
   - 如果TI位是1，从局部描述符表寄存器（LDTR）中获取LDT基地址和界限值。
   - 处理器检查选择子的索引值是否在描述符表的界限内。如果不满足条件，处理器抛出异常。

### 段类型检查

在选择子检查后，处理器还要检查段的类型。主要原则如下：

- 只有具备可执行属性的段（代码段）才能加载到CS段寄存器中。
- 只具备执行属性的段（代码段）不允许加载到除CS外的段寄存器中。
- 只有具备可写属性的段（数据段）才能加载到SS栈段寄存器中。
- 至少具备可读属性的段才能加载到DS、ES、FS、GS段寄存器中。

### 段存在性检查

处理器通过段描述符中的P位检查段是否存在：

- 如果P位为1，表示段存在，可以将选择子载入段寄存器，同时更新段描述符缓冲寄存器。
- 如果P位为0，表示段不存在，处理器抛出异常并执行异常处理程序。

### 代码段和数据段的保护

对于代码段和数据段，处理器在每次访问内存地址时，确保地址在段内的有效范围内：

![image-20240803215248744](/home/ZMR/.config/Typora/typora-user-images/image-20240803215248744.png)

1. **代码段检查**：
   - EIP（段内偏移地址）+ 指令长度 - 1 ≤ 实际段界限大小
   - 如果指令不完全在段内，处理器抛出异常。
2. **数据段检查**：
   - 偏移地址 + 数据长度 - 1 ≤ 实际段界限大小
   - 如果数据不完全在段内，处理器抛出异常。

### ★★ 栈段的保护

栈段可以是向上扩展或向下扩展的数据段。对于向下扩展的段，实际段界限是段内不可访问的第一个字节。处理器确保栈指针（ESP）在栈段内的有效范围内：

![image-20240805110857539](/home/ZMR/.config/Typora/typora-user-images/image-20240805110857539.png)

- 实际段界限 + 1 ≤ **ESP - 操作数大小** ≤ 0xFFFFFFFF
  - 例：
  - 假设现在 esp 指针为 0xFFFFE002，段描述符的 G 位为 1，描述符中的段界限为 0xFFFFD。
  - 压栈前检查：实际段界限为0x1000*FFFFD+0xFFF=0xFFFFDFFF。当执行 push ax，压入 2 字节的操作数，即 esp-2=0xFFFFE000，新的 esp 值≥实际段界限 0xFFFFDFFF +1。如果执行 push eax，压入 4 字节的数据，esp-4=0xFFFFDFFE，小于实际段界限0xFFFFDFFF，故 CPU 会抛出异常。
  - 压栈后算物理地址：由于 esp 只是栈段内的偏移地址，其真正物理地址还要加上段基址。

> 关于为什么有栈段基址了，还要引入段界限来限制栈段的大小：
>
> 段描述符中定义了段基址和段界限等内存段的信息，分别表示段的内存起始地址和段的大小。段界限和栈底之间的内容为栈段的大小。因为一个地址是由段基址+偏移地址构成，这意味着可能栈段基址下面的段可能会由于（非法）加了一个很大的偏移地址，使其跨越了原本它那个段的范围，而定位到栈段。（或者说栈段的段基址本身就位于其他内存段的里边）所以栈段基址到段界限+1的位置都有可能是其他段的部分。因此栈仍需要一个段界限来限制栈向下拓展的范围。

---

---

---

