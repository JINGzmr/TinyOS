 # 第二章 BIOS与MBR

## 载入内存

- cpu的硬件电路只能运行处于内存中的程序
  - 优点:速度快,容量大,统一不同的存储介质
- 程序载入内存的步骤
  1. 程序被加载器加载到内存某个区域
  2. CPU的cs:ip寄存器指向该程序的起始地址

---

---

## ★★ BIOS

- Base Input & Output System，即基本输入输出系统。
- Intel 8086 有 20 条地址线，可以访问 1MB 的内存空间，即 2 的 20 次方=1048576=1MB，地址范围是 0x00000 到 0xFFFFF
  - 但这20条地址总线**不是全部都给内存条使用**
  - 20条中一部分给外设，一部分给显存，一部分给...剩下的可用地址给内存条，也就是物理内存
  - 所以：32位机，就算安装了4GB内存条，但显示其内存也只有3.8GB左右
- **实模式下的 1MB 内存**布局
  - ![image-20240730204222074](/home/ZMR/.config/Typora/typora-user-images/image-20240730204222074.png)
  - 顶部的 0xF0000～0xFFFFF，这 64KB 的内存是 ROM，存的是 **BIOS 的代码**
  - BIOS 的主要工作是**检测、初始化硬件**（硬件自己提供了一些初始化的功能调用，BIOS 直接调用就好了）
  - BIOS 在内存中的 0x000 至 0x3FF 区域**建立中断向量表**，可以通过**int 中断号**来实现相关的**硬件调用**，这是**`对硬件的 IO 操作，也就是输入输出`** ----> （解释了为什么 BIOS 叫做基本输入输出系统）

---

### BIOS的加载过程

1. BIOS是**计算机启动时第一个运行的软件**，它存储在只读存储器（ROM）中
2. **硬件加载**：BIOS 由硬件加载（ ROM 通过地址映射在低端 1MB 内存的顶部（地址 0xF0000 至 0xFFFFF））
3. **入口地址**：BIOS 的入口地址是 0xFFFF0。开机时，CPU 的**段寄存器（cs）和指令指针（ip）被强制初始化为 0xF000 和 0xFFF0**
4. **实模式下的地址计算**：在实模式下，段地址需要乘以 16，0xF000:0xFFF0 的**物理地址为 0xFFFF0**

### BIOS初始化过程

5. **跳转指令**：在 0xFFFF0 处的**跳转指令**（如 `jmp far f000:e05b`）指向 BIOS 代码的**实际位置**
6. **硬件检测**：BIOS 初始化后，会检测内存、显卡等硬件，当检测通过并初始化好硬件后，在内存中的 0x000 至 0x3FF 区域**建立中断向量表（IVT）**

### BIOS最后一项任务

7. 校验启动盘的**MBR**（主引导记录）
8. 检查MBR末尾的两个字节（魔数0x55和0xaa）来确认该扇区中存在可执行程序

---

---

## ★★ MBR

- 一开始位于启动盘**0盘 0道 1扇区**（固定该位置是为了节省启动时间）

- **MBR加载的位置**: 选择32KB内存的**最后1KB（即0x7c00）为MBR的加载地址**，确保不会覆盖系统的其他重要数据。

  - 32KB：**最小内存要求**: 操作系统（如DOS）需要32KB内存。

  - 1KB：MBR 的大小必须是 512 字节（但还要为其所用的栈分配点空间，就干脆给1KB）

    - 所以**0x55 和 0xaa 这两个魔数分别位与510和511字节处**

      ```assembly
      ;mbr.s文件
      SECTION MBR vstart=0x7c00 
      
      	...
      
          message db "hello MBR"      ;定义打印的字符串为hello MBR
          times 510-($-$$) db 0       ;$为本代码行的地址,$$为本section的起始地址,$-$$为本行到本 section的偏移量
                                      ;因为MBR 的最后两个字节是固定的内容，分别是 0x55 和 0xaa，要预留出这 2 个字节
                                      ;故本扇区内前 512-2=510 字节要填满, 所以db 0是用 0 将本扇区剩余空间填充
          db 0x55,0xaa                ;最后两个字节为固定的魔数,BIOS会检查这两个字节来识别这是一个有效的MBR
      ```

  - 0x7c00：与IBM PC 5150的BIOS设计有关，该位置是在BIOS中断处理程序（INT 19H）中硬编码的，旨在为加载MBR提供一个可靠的地址

### ▶ 代码（通过BIOS输出hello MBR）

```assembly
;主引导程序 
SECTION MBR vstart=0x7c00       ;本程序在编译时，告诉编译器，把我的起始地址编译为 0x7c00
    mov ax,cs                   ;此时cs寄存器为0，可以用来将ax寄存器置0
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00               ;将栈指针sp寄存器初始化为0x7c00,让栈有足够的空间向低地址方向扩展。

    ;清屏
    ;利用0x06号功能，上卷全部行，则可清屏
    mov ax, 0x600               ;ah中输入功能号
    mov bx, 0x700               ;设置上卷行属性，0x70表示用黑底白字的属性填充空白行
    mov cx, 0                   ;左上角: (0, 0)
    mov dx, 0x184f	            ;右下角: (80,25),
			                    ;VGA文本模式中,一行只能容纳80个字符,共25行,下标从0开始,所以0x18=24,0x4f=79
    int 0x10                    

    ;下面这三行代码是获取光标位置
    mov ah, 3		            ;输入: 3号子功能是获取光标位置,需要存入ah寄存器
    mov bh, 0		            ;bh寄存器存储的是待获取光标的页号

    int 0x10		            ;执行BIOS 0x10号中断,输出: ch=光标开始行,cl=光标结束行,dh=光标所在行号,dl=光标所在列号

    ;打印字符串
    ;还是用10h中断,不过这次是调用13号子功能打印字符串
    mov ax, message 
    mov bp, ax		           
    mov cx, 9		            ;要打印的字符串的长度
    mov ax, 0x1301	            ;ah=13h,al=01h,表示要打印字符串
    mov bx, 0x2		            ;bh存储要显示的页号,此处是第0页,bl中是字符属性, 属性黑底绿字(bl = 02h,07是黑底白字)
    int 0x10		            ;执行BIOS 0x10 号中断,打印字符串

    jmp $		                ;使程序悬停在此,即死循环

    message db "hello MBR"      ;定义打印的字符串为hello MBR
    times 510-($-$$) db 0       ;$为本代码行的地址,$$为本section的起始地址,$-$$为本行到本 section的偏移量.
                                ;因为MBR 的最后两个字节是固定的内容，分别是 0x55 和 0xaa，要预留出这 2 个字节
                                ;故本扇区内前 512-2=510 字节要填满, 所以db 0是用 0 将本扇区剩余空间填充
    db 0x55,0xaa                ;最后两个字节为固定的魔数,BIOS会检查这两个字节来识别这是一个有效的MBR

```

### BIOS与MBR

#### 地址类型

1. **0xFFFF0**（BIOS 入口点）
   - **类型**：物理地址。
   - **说明**：在实模式下，BIOS 的入口地址通常为 0xFFFF0。这是 BIOS 固件在启动时的加载位置。
2. **0x7C00**（MBR）
   - **类型**：物理地址。
   - **说明**：MBR通常在磁盘的第一个扇区，加载到内存时的地址为 0x7C00。

#### 地址关系

- 都在物理内存：在计算机启动时，BIOS 会将 MBR 从磁盘中读取到物理内存的 0x7C00 位置

---

## ★★★计算机启动过程

**电源开启**：计算机通电，BIOS 开始执行。

**BIOS 初始化**：BIOS 执行上电自检（POST），初始化硬件，并查找引导设备。

**BIOS 加载 MBR**：BIOS 读取引导设备的 MBR，将其加载到内存，并将控制权转交给 MBR 中的引导代码。

**MBR 执行引导代码**：MBR 中的引导代码执行，加载操作系统的引导加载程序或操作系统本身。

---

---

---

# 第三章 完善MBR

## ★★★ CPU工作原理

![image-20240731102328181](/home/ZMR/.config/Typora/typora-user-images/image-20240731102328181.png)

- **控制单元**要取下一条待运行的指令，该指令的地址在**程序计数器 PC** 中，在 x86CPU 上，程序计数器就是 **cs：ip**
- 读取 **ip 寄存器**后，将此地址送上地址总线，CPU 根据此地址便得到了指令，并将其存入到**指令寄存器 IR** 中
- 这时候轮到**指令译码器**上场了，它根据指令格式检查指令寄存器中的指令，先确定操作码是什么，再检查操作数类型，若是在内存中，就将相应**操作数**从内存中取到自己的存储单元，若操作数是在寄存器中就直接用了，免了取操作数这一过程
- 操作码有了，操作数也齐了，**操作控制器**给运算单元下令，开工，于是**运算单元**便真正开始执行指令了。ip 寄存器的值被加上当前指令的大小，于是 ip 又指向了下一条指令的地址
- 接着控制单元又要取下一条指令了，流程回到了本段开头

---

## 实模式下 CPU 内存寻址方式

- 寄存器寻址
- 立即数寻址
- 内存寻址
  - 直接寻址
  - 基址寻址
  - 变址寻址
  - 基址变址寻址

### 寄存器寻址

```assembly
mov ax, 0x10
mov dx, 0x9
mul dx
```

- 第一、二条指令源操作数都是立即数，所以也属于立即数寻址

### 立即数寻址

```assembly
mov ax,0x18
mov ds, ax
mov ax, macro_selector ; 宏
mov ax, label_star 	   ; 标号
```

- 第一条指令中的源操作数 0x18 是立即数，目的操作数 ax 是寄存器，所以它既是立即数寻址，也是寄
  存器寻址

### 内存寻址

- 前面两种寻址方式，**操作数一个是在寄存器中，一个是在指令中直接给出，它们都不在内存中**。操作
  数在内存中的寻址方式称为内存寻址。
- ~~寄存器寻址弊端：CPU 给程序员用的寄存器并不是很多，所以操作数一多起来的时候，基本就倒腾不开了~~
- ~~立即数寻址弊端：得提前知道立即数是多少。而且，大多数时候操作数位于内存中的某个位置，只知道操作数所在的内存地址，不知道操作数的值~~

#### 直接寻址

- **数字作为内存地址**，通过中括号的形式告诉 CPU，取此地址中的值作为操作数

```assembly
mov ax, [0x1234]
mov ax, [fs:0x5678]
```

- 0x1234 是**段内偏移地址，默认的段地址是 DS**。这条指令是将内存地址 DS：0x1234 处的值写入 ax 寄存器
- 第二条指令中，由于使用了**段跨越前缀 fs**，0x5678 的**段基址则变成了 gs 寄存器**。最终的内存地址是gs 寄存器的值*16+0x5678，CPU 到此内存地址取值再存入 ax 寄存器

#### 基址寻址

- 使用 **BX** 或 **BP** 寄存器作为基址，进行内存地址的计算（实模式下只能用这两个，保护模式不限）
- **BX寄存器**：
  - 默认段寄存器为 **DS**（数据段）。
  - 例如：指令 `ADD WORD [BX], 0x1234` 意味着将内存地址 `DS:BX` 处的值与 `0x1234` 相加，并存回 `DS:BX`。
- **BP寄存器**：
  - 默认段寄存器为 **SS**（栈段）。
  - 主要用于栈的访问，尤其在函数调用和局部变量管理中。![image-20240731105233478](/home/ZMR/.config/Typora/typora-user-images/image-20240731105233478.png)
- 堆栈框架![image-20240731110313114](/home/ZMR/.config/Typora/typora-user-images/image-20240731110313114.png)

#### 变址寻址

- 和基址寻址类似，只是寄存器由 bx、bp 换成了 si 和 di，默认段寄存器是 ds

  ```assembly
  mov [di]，ax  		;将 AX 寄存器的值存储到由 DI 寄存器指向的内存地址
  mov [si+0x1234], ax  ;将 AX 寄存器的值存储到由 SI 寄存器加上偏移量 0x1234 计算得出的内存地址
  ```

#### 基址变址寻址

- 基址寄存器 bx 或 bp 加一个变址寄存器 si 或 di，默认段寄存器是 ds

  ```assembly
  mov [bx+di], ax  ;将 ax 中的值送入以 ds 为段基址，bx+di 为偏移地址的内存
  add [bx+si], ax  ;将 ax 与[ds：bx+si]处的值相加后存入内存[ds：bx+si]
  ```

---

## 实模式下的ret

### 近返回ret

1. ret（return）指令的功能：在栈顶（寄存器 ss：sp 所指向的地址）弹出 **2 字节**的内容来替换 **IP** 寄存器，并会使 sp 指针+2
2. 如果 call 是**近调用**，在目标函数中就要用 ret 来返回，因为**近调用的 call 只在栈中留下了 2 字节的返回地址**（IP 寄存器的值），ret 只是从栈顶取得 2 个字节作为偏移地址载入 IP 寄存器

### 远返回retf

1. retf（return far）：从栈顶取得 **4 字节**，栈顶处的 2 字节用来替换 **IP** 寄存器，另外的 2 字节用来替换**CS** 寄存器
2. 如果 call 是**远调用**，在目标函数中就要用 retf（ret far）来返回，因为**远调用的 call 指令在栈中留下了段基址和段内偏移地址**，retf 指令只会从栈中弹出 2 字节的偏移地址和 2 字节的段基址

---

## 实模式下的call

- 调用函数

### 16 位实模式相对近调用

**1. 相对近调用概述**

- 相对近调用是指在同一个代码段内（即同一个 64KB 空间内）进行函数调用。
- 由于目标函数和当前指令位于同一个段，因此只需要给出目标函数的段内偏移地址，无需给出段基址。
- 这种调用方式使用 `call near` 指令，其中 `near` 可以省略。
- 指令格式为 `call near 立即数地址`，操作数为立即数。

**2. 相对近调用的操作数**

- 操作数不是目标函数的绝对地址，而**是目标函数地址相对于当前 `call` 指令地址的偏移量，即地址差**。
- 具体计算方法为：**目标函数地址 - 当前 `call` 指令地址 - 指令长度（3 字节）**。
- 操作数是一个有符号数，范围为 -32768 到 32767。

**3. 相对近调用的执行过程**

- **CPU 遇到 `call near` 指令时，会将当前 IP 寄存器值（即当前指令地址）压入堆栈，然后将操作数（相对地址增量）加到 IP 寄存器值上，并将结果作为新的 IP 寄存器值，从而跳转到目标函数的地址。**
- **目标函数执行完毕后，使用 `ret` 指令返回。`ret` 指令会从堆栈中弹出之前保存的 IP 寄存器值，并将其赋值给 IP 寄存器，从而返回到 `call` 指令的下一条指令处继续执行。**

**4. 相对近调用的优势**

- 由于操作数是相对地址，因此代码位置的改变不会影响指令的执行，提高了代码的可移植性。
- 相对地址的计算由编译器完成，简化了开发人员的工作。

**5. 示例代码分析**

```assembly
call near near_proc
jmp $
addr dd 4
near_proc：
	mov ax， 0x1234
	ret
```

`call near_proc` 指令的机器码为 `e8 06 00`。

- `e8` 是 `call near` 指令的操作码。
- `06 00` 是操作数，表示目标函数 `near_proc` 的地址相对于当前 `call` 指令地址的偏移量为 6。

bochs 的反汇编结果验证了这一点：

- 当前指令地址为 `0x900`。
- 目标函数地址为 `0x909`。
- 操作数为 `0x06`，即 `0x909 - 0x900 - 3 = 0x06`。

### 16 位实模式间接绝对近调用

**1. 间接绝对近调用概述**

- 间接绝对近调用是指通过寄存器或内存地址间接获取目标函数的绝对地址，并在同一个代码段内进行函数调用。
- 与“16 位相对近调用”不同，这种调用方式**不使用相对地址，而是直接使用目标函数的绝对地址**。
- 由于是近调用，目标函数和当前指令位于同一个代码段，因此只需要给出目标函数的段内偏移地址，无需给出段基址。

**2. 指令格式**

- 指令格式为 `call 寄存器寻址` 或 `call 内存寻址`。
- `call 寄存器寻址` 指令使用寄存器存放目标函数的地址，例如 `call ax`。
- `call 内存寻址` 指令使用内存地址存放目标函数的地址，例如 `call [0x1234]`。

**3. 操作码**

- `call 内存寻址` 指令的操作码为 `ff16`，机器码为 `ff16 + 16 位内存地址`。
- 寄存器寻址的机器码与寄存器名称有关，例如 `call ax` 的机器码为 `ffd0`，`call cx` 的机器码为 `ffd1`。

**4. 执行过程**

- **CPU 遇到 `call` 指令时，会将当前 IP 寄存器值（即当前指令地址）压入堆栈。**
- **然后根据指令格式，从寄存器或内存中获取目标函数的地址，并将其赋值给 IP 寄存器。**
- **最后，CPU 跳转到目标函数地址执行。**

**5. 示例代码分析**

```assembly
section call_test vstart=0x900
mov word [addr], near_proc
call [addr]
mov ax, near_proc
call ax
jmp $
addr dd 4
near_proc:
	mov ax, 0x1234
	ret
```

`call [addr]` 和 `call ax` 分别演示了间接绝对近调用的两种方式。

- 第 3 行 `call [addr]` 使用内存地址 `addr` 存放目标函数 `near_proc` 的地址。
- 第 5 行 `call ax` 使用 `ax` 寄存器存放目标函数 `near_proc` 的地址。

### 16 位实模式直接绝对远调用

### 16 位实模式间接绝对远调用



---

## 实模式下的 jmp

- `相对于call：jmp有去无返`

1. **短相对跳转 (jmp short)**：这种跳转类型使用一个有符号 8 位立即数作为偏移量，允许在当前指令的 -128 到 +127 字节内进行相对跳转。这条指令的操作码是 0xEB。

   ```assembly
   jmp short start
   ...
   start：
   	...
   ```

2. **近相对跳转 (jmp near)**：这种跳转类型使用一个有符号 16 位立即数作为偏移量，允许在当前指令的 -32,768 到 +32,767 字节内进行相对跳转。这条指令的操作码是 0xE9。

   ```assembly
   jmp near start
   ...
   start:
   	...
   ```

3. **近寄存器间接跳转 (jmp near reg)**：这种跳转类型使用一个寄存器中的 16 位值，例如 AX。这条指令的操作码是 0xFF。

   ```assembly
   mov ax， start
   jmp near ax
   ...
   start:
   	...
   ```

4. **直接绝对远转移 (jmp far)**：这种跳转类型直接提供目标地址的段基址和段内偏移地址。操作数是立即数形式的。操作数会被直接加载到 CS 寄存器和 IP 寄存器中，从而实现转移。

   ```assembly
   jmp 0：start
   ...
   start:
   	...
   ```

5. **间接绝对远转移 (jmp far mem)**：这种跳转类型的操作数在内存中。当不使用段跨越前缀时，段基址寄存器默认为 DS。操作数需要访问内存才能得到，因此需要知道寻址方式。操作数包含 4 个字节：段内偏移地址（2 字节）和段基址（2 字节）。由于是远转移，因此 CPU 的 CS 寄存器和 IP 寄存器都要被修改成操作数中指定的值。

   ```assembly
   jmp far [addr]
   ...
   addr dw start，0
   start:
   	...
   ```

---

## 标志寄存器 flags

![image-20240731155453687](/home/ZMR/.config/Typora/typora-user-images/image-20240731155453687.png)

- 第 0 位的是 CF 位，即 Carry Flag，意为进位。它可用于检测**无符号**数加减法**是否有溢出**，因为 CF 为 1 时，也就是最高位有进位或借位，肯定是溢出。
- 第 2 位为 PF 位，即 Parity Flag，意为奇偶位。用于标记结果低 8 位中 1 的个数，如果为偶数，PF 位为 1，否则为 0。
- 第 4 位为 AF 位，即 Auxiliary carry Flag，意为辅助进位标志，用来记录运算结果低 4 位的进、借位情况，即若低半字节有进、借位，AF 为 1，否则为 0。
- 第 6 位为 ZF 位，即 Zero Flag，意为零标志位。若计算结果为 0，此标志为 1，否则为 0。
- 第 7 位为 SF 位，即 Sign Flag，意为符号标志位。若运算结果为负，则 SF 位为 1，否则为 0。
- 第 8 位为 TF 位，即 Trap Flag，意为陷阱标志位。此位若为 1，用于让 CPU 进入单步运行方式，若为0，则为连续工作的方式。(debug 程序，在单步调试时，原理上就是让 TF 位为 1)
- 第 9 位为 IF 位，即 Interrupt Flag，意为中断标志位。若 IF 位为 1，表示中断开启，CPU 可以响应外部可屏蔽中断。若为 0，表示中断关闭，CPU 不再响应来自 CPU 外部的可屏蔽中断，但 CPU 内部的异常还是要响应的.
- 第 10 位为 DF 位，即 Direction Flag，意为方向标志位。此标志位用于字符串操作指令中，当 DF 为1 时，指令中的操作数地址会自动减少一个单位，当 DF 为 0 时，指令中的操作数地址会自动增加一个单位，意即给地址的变化提供个方向。
- 第 11 位为 OF 位，即 Overflow Flag，意为溢出标志位。若 OF 为 1，表示有溢出，为 0 则未发生溢出。专门用于检测**有符号数**运算结果**是否有溢出**现象。
- ...

---

## 有条件转移

![image-20240731160330979](/home/ZMR/.config/Typora/typora-user-images/image-20240731160330979.png)

a表示 above
b表示 below
c表示 carry
e表示 equal
g表示 great
j表示 jmp
l表示 less
n表示 not
o表示 overflow
p表示 parity

---

## 实模式的缺点

1. 实模式下没有特权级，用户程序和操作系统平起平坐
2. 程序可以随意修改自己的段基址，可以随意访问任意物理内存，包括访问操作系统所在的内存数据

----

## IO接口

### 背景

CPU 与外部设备通信的挑战：

- 外部设备种类繁多，特性各异，数据格式、工作时序、信号电平等方面都存在差异。
- CPU 速度远高于外部设备，直接与每个设备交互会造成 CPU 等待时间过长，效率低下。

### 概述

IO 接口的引入：

- 作用： **CPU 和外部设备之间的代理，负责协调双方之间的差异，简化 CPU 的操作**。
- IO 接口可以是电路板、芯片或插槽，负责速度匹配、信号转换、数据格式转换、时序控制等功能。
- IO 接口可以分为硬件和软件两部分：
  - 硬件部分负责实际的协调转换工作。
  - 软件部分包括驱动程序和数据传输程序，控制接口电路的运作。

IO 接口的分类：

- 可编程接口芯片：可以根据需要设置工作模式，支持多种功能，允许多个设备共享同一个接口。
- 不可编程接口芯片：功能简单，不需要设定即可使用。

IO 接口的控制编程：

- 通过软件指令控制 IO 接口的功能和工作模式，实现定制化的功能。
- 使用端口读写指令 (in/out) 来实现 IO 接口的控制编程。

具体例子：

- ### USB 接口：用于连接外部设备，如键盘、鼠标、打印机等。

- ### PCI/PCIe 插槽：用于连接各种扩展卡，如显卡、网卡、声卡等。

### 功能

- 设置数据缓冲区，解决速度不匹配问题。
- 设置信号电平转换电路，解决信号电平差异问题。
- 设置数据格式转换电路，解决数据格式差异问题。
- 设置时序控制电路，同步 CPU 和外部设备的工作时序。
- 提供地址译码，实现对多个端口的访问。

### 其他

总线：

- 作用：**连接 CPU 和外部设备的物理链路，是一组电线，用于传输信号**。
- 主板上的各种插槽都是连接到总线上的。
- 总线可以分为不同的类型，如地址总线、数据总线、ISA 总线等。

南桥芯片：

- 作用：**仲裁 IO 接口的竞争，连接各种内部总线**。

- 南桥芯片负责连接各种低速设备，如硬盘、USB、PCI 设备等。

- 南桥芯片内部集成了一些 IO 接口，并提供 PCI 接口用于扩展其他设备。

  ![image-20240731200112351](/home/ZMR/.config/Typora/typora-user-images/image-20240731200112351.png)

端口：

- 作用：**是 IO 接口内部的寄存器，用于与 CPU 进行数据交互**。
- 为了区别于 CPU 内部的寄存器，IO 接口中的寄存器称为端口。
- in 指令用于从端口读取数据。
- out 指令用于向端口写入数据。

### ★★★ IO接口，cpu，外部设备，总线，南桥芯片，端口之间的关系

 IO 接口是连接 CPU 和硬件的桥梁，一端是 CPU，另一端是硬件。IO接口通过总线连接CPU和外部设备。当同时有很多的IO接口想与CPU通信时，需要南桥芯片来协调各个IO接口。而IO接口被设计成需要使用寄存器才能与CPU 通信，因此IO接口中的寄存器被称为端口，用于与 CPU 进行数据交互

---

## 显存、显卡、显示器

- 关系：**显卡（硬件组件，包括GPU）通过显存（显卡里的物理内存）进行图形数据的存取和处理，然后通过 I/O 接口（如PCI/PCIe 插槽）将处理后的图像输出到显示器**

- 黑白图形模式: 显存中的对应位置为 1，屏幕上的相应像素就被点亮，呈现的是白色。若该位为 0，该像素就不会被点亮，只要不管该像素就是黑色

- 真彩色: 24 个 bit 表示一个颜色，即24 位对应一个像素

### ▶ 代码（通过显卡输出hello MBR）

```assembly
;主引导程序 
SECTION MBR vstart=0x7c00      
    mov ax,cs                  
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00       

    ;往gs寄存器中存入段基址
    mov ax,0xb800   ;由于显存文本模式中，其内存地址是 0xb8000，实模式下内存分段访问策略是“段基址*16+段内偏移地址”
    mov gs,ax       ;所以由0xb8000得到的段基址是其除以16,也就是右移4位，得：0xb800

    mov ax, 0x600              
    mov bx, 0x700              
    mov cx, 0                  
    mov dx, 0x184f	           
			                   
    int 0x10
    
    ; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
    mov byte [gs:0x00],'h'              ; gs为段跨越前缀，指定gs为段基址
    mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色

    mov byte [gs:0x02],'e'
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'l'
    mov byte [gs:0x05],0xA4   

    mov byte [gs:0x06],'l'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'o'
    mov byte [gs:0x09],0xA4

    mov byte [gs:0x0a],' '
    mov byte [gs:0x0b],0xA4

    mov byte [gs:0x0c],'M'
    mov byte [gs:0x0d],0xA4

    mov byte [gs:0x0e],'B'
    mov byte [gs:0x0f],0xA4

    mov byte [gs:0x10],'R'
    mov byte [gs:0x11],0xA4

    jmp $

    times 510-($-$$) db 0
    db 0x55,0xaa
```

![image-20240801102626566](/home/ZMR/.config/Typora/typora-user-images/image-20240801102626566.png)

---

## bochs

### 简介

1. 是一个开源 x86 虚拟机软件，支持硬件级别上的调试
2. bochs 的调试风格参照 gdb 来设计
3. 八进制（零开头）：011
   十进制：11
   十六进制（0x开头）：0x11

### Bochs 调试命令分类

- **Debugger control** 类：控制调试器行为，例如退出调试状态、设置寄存器值、显示模式信息等。
- **Execution control** 类：控制程序执行，例如继续执行、单步执行、执行下一条指令等。
- **Breakpoint management** 类：管理断点，例如设置断点、删除断点、禁用/启用断点等。
- **CPU and memory contents** 类：查看 CPU 和内存内容，例如查看内存内容、查看寄存器值、查看堆栈信息等。

### 常用调试命令介绍

#### Debugger control类

- `q|quit|exit`: 退出调试状态，关闭虚拟机。
- `set`: 设置寄存器值或其他选项，例如 `set reg = val` 设置寄存器值，`set u on|off` 设置是否反汇编指令。
- `show`: 显示信息，例如 `show mode` 显示模式信息，`show int` 显示中断信息，`show call` 显示函数调用信息。
- `traceon|off`: 设置是否在单步调试时反汇编代码。
- `u|disasm`: 反汇编代码。
- `ctrl+c`: 中断执行，回到 Bochs 控制台。

#### Execution control类

- `c|cont|continue`: 继续执行。
- `s|step`: 单步执行。
- `p|n|next`: 执行下一条指令。

#### Breakpoint management类

- `vb|vbreak`: 设置虚拟地址断点。
- `lb|lbreak`: 设置线性地址断点。
- `pb|pbreak|b|break`: 设置物理地址断点。
- `sb`: 设置指令数断点。
- `sba`: 设置 CPU 执行指令数断点。
- `watch`: 设置读写断点。
- `blist`: 显示所有断点信息。
- `bpd|bpe`: 禁用/启用断点。
- `d|del|delete`: 删除断点。

#### CPU and memory contents类

- `x`: 显示线性地址的内容。
- `xp`: 显示物理地址的内容。
- `setpmem`: 设置物理内存内容。
- `r|reg|regs|registers`: 显示寄存器值。
- `ptime`: 显示 Bochs 自启动之后，总执行指令数。
- `print-stack`: 显示堆栈信息。
- `?|calc`: 内置计算器。
- `info`: 显示信息，例如 `info pb` 查看断点信息，`info CPU` 显示 CPU 所有寄存器值，`info idt` 显示中断向量表 IDT，`info gdt` 显示全局描述符表 GDT，`info flags` 显示状态寄存器，`info tab` 显示页表信息。

### 常见调试步骤

> 调试 `#GP General Protection Exception` 的步骤如下

1. 启动调试

   - 使用 `show int` 命令查看中断状态。

   - 运行程序，使用 `c` 命令继续执行。


2. 查找异常
   - 观察控制台输出，注意到 `exception (not softint)` 行，确定异常发生的位置（如 `0008:c0001e1b`）。


3. 确定中断处理函数

   - 使用 `nm` 命令查找中断处理函数的符号信息：
     ```bash
     nm build/kernel.bin | grep 1e1b
     ```

   - 确认函数名（如 `intr##0x0d##entry`），这表明是 GP 异常的处理。


4. 设置断点

   - 在异常处理函数入口设置断点：
     ```bash
     lb 0xc0001e1b
     ```

   - 使用 `c` 命令继续执行，捕获到断点。


5. 查看寄存器状态
   - 使用 `r` 命令查看寄存器状态，特别是 `ebx` 和 `gs` 的值，检查是否存在无效的内存访问。


6. 检查内存

   - 使用 `sreg` 查看段寄存器的状态，确认 `gs` 段的基址和限制。

   - 使用 `x gs:ax` 检查内存，观察是否有超出范围的访问。


7. 分析段描述符
   - 使用 `info gdt 3` 查看 GDT 中的段描述符，确认段的 `limit` 是否足够。


8. 执行并验证

   - 逐步执行引发异常的指令：
     ```bash
     s
     ```

   - 如果再次触发 GP 异常，回到中断处理函数，分析错误原因。


9. 修复错误
   - 根据调试信息，修正代码中的越界访问错误，确保访问的内存地址在合法范围内。


10. 重复测试
    - 重新编译并测试程序，确保问题已解决，不再引发 GP 异常。


---

## 硬盘

- **硬盘控制器属于 IO 接口**，cpu通过硬盘控制器来与硬盘交流
- 因此硬盘控制器拥有端口，也就是它里面的寄存器。让硬盘工作，我们就需要读写硬盘控制器的端口

### ★★ 硬盘操作方法

- **硬盘读或写操作**的基本顺序
  1. **选择通道**：指定要操作的硬盘通道。
  2. **写入扇区数**：将待操作的扇区数写入 sector count 寄存器。
  3. **设置 LBA 地址**：将扇区起始地址的低 24 位写入 LBA 寄存器，并在 device 寄存器中设置 LBA 模式及选择硬盘。
  4. **写入命令**：将具体的操作命令（如读或写）写入 command 寄存器。
  5. **检查状态**：读取 status 寄存器，判断硬盘是否完成操作。
  6. **判断操作类型**：如果是读操作，继续下一步；如果是写操作，则结束。
  7. **读取数据**：从硬盘将数据读出。

- 硬盘工作完成后，它已经准备好了数据，通过下面**五种方式进行数据传送**

  （1）**无条件传送方式**：随时准备好了数据，CPU 随时取随时拿都没问题（如：寄存器、内存）

  （2）**查询传送方式**：也称为程序 I/O、PIO，传输之前，每次都由程序先去检测设备的状态（CPU花在查询上的时间多，效率低）

  （3）**中断传送方式**：也称为中断驱动 I/O，当数据源设备准备好数据后，硬盘控制器通过发中断来通知 CPU 来拿数据（避免CPU浪费时间在查询上，效率较高。但中断时，CPU就需要压栈出栈，浪费其资源）

  （4）**直接存储器存取方式（DMA）**：“直接”体现在 不让 CPU参与传输，完全由数据源设备和内存直接传输。CPU 直接到内存中拿数据就好了。（和中断比，它方便快捷。但DMA由硬件实现，需要DMA控制器）

  （5）**I/O 处理机传送方式**：在DMA基础上再引入I/O 处理机，专门用于处理 IO。（CPU彻底不用管了）

---

## 让MBR使用硬盘

### ▶ 代码

mbr.s

```assembly
;主引导程序 
%include "boot.inc"     ;nasm 编译器中的预处理指令,让编译器在编译之前把 boot.inc 文件包含进来
SECTION MBR vstart=0x7c00         
    mov ax,cs      
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00
    mov ax,0xb800
    mov gs,ax

    ; 清屏
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0                      
    mov dx, 184fh		           		                   
				                   
    int 10h                        

    ; 输出字符串:MBR
    mov byte [gs:0x00],'1'
    mov byte [gs:0x01],0xA4

    mov byte [gs:0x02],' '
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'M'
    mov byte [gs:0x05],0xA4	        ;A表示绿色背景闪烁，4表示前景色为红色

    mov byte [gs:0x06],'B'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'R'
    mov byte [gs:0x09],0xA4
	 
    ;下面三行为rd_disk_m_16 函数传递参数（用寄存器传递，这里用到eax、bx、cx 寄存器）
    mov eax,LOADER_START_SECTOR	    ; 待读入的起始扇区lba地址
    mov bx,LOADER_BASE_ADDR         ; 数据从硬盘读进来后，将其写入的内存地址
    mov cx,1			            ; 待读入的扇区数，因为此时大小不会512字节，因此1扇区即可

    call rd_disk_m_16		        ; ★★★调用函数 rd_disk_m_16 读取硬盘的一个扇区，从硬盘读取 loader 程序到指定的内存地址
  
    jmp LOADER_BASE_ADDR            ; ★★★跳转到 loader 的起始地址，执行 loader 程序
       

; 功能: 读取硬盘 n 个扇区的函数
rd_disk_m_16:
    ; eax = LBA 扇区号
    ; ebx = 将数据写入的内存地址
    ; ecx = 读入的扇区数

    mov esi, eax  ; 备份 EAX 寄存器的值（LBA 扇区号）
    mov di, cx    ; 备份 ECX 寄存器的值（待读入的扇区数）

    ; 通过下面五步进行磁盘读取
    ; 第一步：选择特定通道的寄存器，设置要读取的扇区数
    mov dx, 0x1f2  ; 选择端口 0x1f2
    mov al, cl     ; 设置要读取的扇区数
    out dx, al     ; 写入到端口

    mov eax, esi   ; 恢复 EAX 寄存器的值

    ; 第二步：将 LBA 地址的各部分写入端口 0x1f3 ~ 0x1f6
    mov dx, 0x1f3  ; 设置 LBA 地址的低 8 位
    out dx, al     ; 写入到端口

    mov cl, 8      ; 将 EAX 寄存器右移 8 位，设置 LBA 地址的 15~8 位
    shr eax, cl
    mov dx, 0x1f4
    out dx, al

    shr eax, cl    ; 将 EAX 寄存器右移 8 位，设置 LBA 地址的 23~16 位
    mov dx, 0x1f5
    out dx, al

    shr eax, cl    ; 将 EAX 寄存器右移 8 位，设置 LBA 地址的 27~24 位
    and al, 0x0f   ; 只保留低 4 位
    or al, 0xe0    ; 设置高 4 位为 1110，表示 LBA 模式
    mov dx, 0x1f6
    out dx, al

    ; 第三步：向 0x1f7 端口写入读命令，0x20
    mov dx, 0x1f7
    mov al, 0x20  ; 设置读命令
    out dx, al   ; 写入到端口

    ; 第四步：检测硬盘状态，等待硬盘准备好数据传输
.not_ready:
    nop         ; 相当于 sleep，等待
    in al, dx   ; 从端口读取硬盘状态
    and al, 0x88  ; 检查第 4 位和第 7 位
    cmp al, 0x08  ; 如果第 4 位为 1，表示硬盘控制器已准备好数据传输
    jnz .not_ready  ; 如果未准备好，继续等待

    ; 第五步：从 0x1f0 端口读数据
    mov ax, di  ; 获取待读入的扇区数
    mov dx, 256  ; 每个扇区 512 字节，一次读取 2 字节，共需读取 256 次
    mul dx      ; 计算总读取次数
    mov cx, ax  ; 将总读取次数存入 CX 寄存器
    mov dx, 0x1f0  ; 设置数据端口

.go_on_read:
    in ax, dx    ; 从端口读取数据
    mov [bx], ax  ; 将数据写入内存
    add bx, 2    ; 增加内存地址指针
    loop .go_on_read  ; 循环读取，直到 CX 为 0

    ret  ; 返回，回到调用 rd_disk_m_16 的地方

    times 510-($-$$) db 0  ; 填充到 510 字节
    db 0x55, 0xaa  ; MBR 签名
```

loader.s

```assembly
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR  ; 定义代码段的起始地址为 LOADER_BASE_ADDR

; 输出背景色绿色，前景色红色，并且跳动的字符串"2 LOADER"
mov byte [gs:0x00],'2'
mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色

mov byte [gs:0x02],' '
mov byte [gs:0x03],0xA4

mov byte [gs:0x04],'L'
mov byte [gs:0x05],0xA4   

mov byte [gs:0x06],'O'
mov byte [gs:0x07],0xA4

mov byte [gs:0x08],'A'
mov byte [gs:0x09],0xA4

mov byte [gs:0x0a],'D'
mov byte [gs:0x0b],0xA4

mov byte [gs:0x0c],'E'
mov byte [gs:0x0d],0xA4

mov byte [gs:0x0e],'R'
mov byte [gs:0x0f],0xA4

jmp $		                        ; 通过死循环使程序悬停在此

```

boot.inc

```assembly
; loader和kernel
LOADER_BASE_ADDR equ 0x900 ;相当于c语言的#define LOADER_BASE_ADDR 0x900
                           ;定义了 loader 在内存中的位置,MBR 要把 loader 从硬盘读入后放到此处
                           ;即后面 loader 会存在内存地址 0x900 处
LOADER_START_SECTOR equ 0x2 ;loader 程序在硬盘上的起始扇区
```

![image-20240801212706705](/home/ZMR/.config/Typora/typora-user-images/image-20240801212706705.png)

### ★★★ 代码讲解

> `mbr.s` 的作用主要是引导计算机的启动过程。它位于硬盘的第一个扇区（MBR，主引导记录），由 BIOS 加载并执行。
>
> `mbr.s` **成功将 loader 程序从硬盘读取到内存中，并跳转到 loader 程序的起始地址开始执行**

1. **初始化硬件环境**：

   - 设置段寄存器（CS、DS、ES、SS、FS）和栈指针（SP），确保程序可以正确访问内存和使用栈。

2. **清屏操作**：

   - 使用 BIOS 中断清除屏幕，并设置屏幕显示的模式，以便后续的输出操作。

3. **输出信息**：

   - 在屏幕上显示一个简单的字符串（如 "1 MBR"），用于表明 MBR 程序已经成功加载并开始执行。

4. **准备读取 loader**：

   - 设置 `eax` 为 `LOADER_START_SECTOR`（loader 在硬盘上的起始扇区），`bx` 为 `LOADER_BASE_ADDR`（将数据从硬盘读入的内存地址），`cx` 为 `1`（待读入的扇区数）。

5. **★★★调用 `rd_disk_m_16` 函数**：

   - 调用 

     ```
     rd_disk_m_16
     ```

      函数读取硬盘上的 loader 程序。该函数执行以下步骤：

     - 设置待读取的扇区数。
     - 将 LBA 地址写入相应端口。
     - 向硬盘发送读命令。
     - 等待硬盘准备好数据传输。
     - 从硬盘读取数据并写入内存。

6. **★★★跳转到 loader 程序**：

   - 读取完成后，使用 `jmp LOADER_BASE_ADDR` 跳转到 loader 程序的起始地址（`0x900`）执行。

---

---

---

 # 第四章 保护模式入门

- 实模式，指的是 32 位的 CPU 运行在 16 位模式下的状态
- 开机时，32 位的 CPU 是先处于实模式，之后再进入保护模式的
- 加入保护模式的三个步骤：

  **（1）打开 A20。**
  **（2）加载 gdt。**
  **（3）将 cr0 的 pe 位置 1。**

## 保护模式相对于实模式的拓展

### 寄存器拓展

![image-20240802170318832](/home/ZMR/.config/Typora/typora-user-images/image-20240802170318832.png)

#### 80286

- 80286是8086的下一代，但**有了保护模式**
- 因为有保护模式，所以引入数据结构：**全局描述符表**
  - 表中至少有一个表项，其中每一个表项称为段描述符，其大小为 64 字节，用来描述各个内存段的起始地址、大小、
    权限等信息。
  - 但：段描述符是**在内存中**，访问内存对 CPU 来说是比较慢的动作，**效率不高**。
  - 但：段描述符的格式很奇怪，一个**数据要分三个地方存**，所以将这些数据拼起来很**费时间**。
  - 综上：为了提高获取段信息的效率，引入**段描述符缓冲寄存器**，将段信息用一个寄存器来缓存。以后每次访问相同的段时，就直接读取该段寄存器对应的段描述符缓冲寄存器。该缓存内容的失效时间为：只要往段寄存器中赋值（即更新选择子），CPU 就会重新访问全局描述符表，再将获取的段信息重新放回段描述符缓冲寄存器
- 偏移地址和实模式一样
- 段寄存器中保存的不是段基址，而是**“选择子”**，该选择子就是个**数**，用这个数来**索引全局描述符表中的段描述符**（把全局描述符表当成数组，选择子就像数组下标一样）

#### ★★★ 8086、80286以及80386

| CPU型号 | 位数 | 地址线位数 | 内存大小              | 段基址位数 | 寄存器位宽 |
| ------- | ---- | ---------- | --------------------- | ---------- | ---------- |
| 8086    | 16位 | 20条       | 1 MB（20位地址空间）  | 16位       | 16位       |
| 80286   | 16位 | 24条       | 16 MB（24位地址空间） | 24位       | 16位       |
| 80386   | 32位 | 32条       | 4 GB（32位地址空间）  | 32位       | 32位       |

- 8086与80286被淘汰
  - **是 24 位段基址，段内相对偏移地址还是必不可少的。用于寻址的通用寄存器还是 16 位，即单独的一个寄存器还是只能访问 64KB 的空间。如果用寄存器作为段内偏移地址，段的大小还是 64KB，这就白白浪费了 24 位段基址的优势，要是想访问完整的 16MB 内存，依然要不断地变换段基址**，所以 80286 很快就被淘汰了
  -  **寻址限制**
    - **段大小限制**：在 80286 和 8086 的 16 位架构中，**段内偏移地址最大为 64KB**（因为寄存器位宽都为16位）。每个段的地址范围从 0 到 65535（2^16 - 1），这意味着**每个段无法超过 64KB**。
    - **影响大型应用**：对于现代应用程序，尤其是需要大量数据或执行复杂算法的程序，64KB 的限制显得非常狭窄。开发者必须分割数据和代码到多个段中，导致内存管理变得繁琐。
    - **额外的复杂性**：程序必须设计为跨多个段工作，这可能导致代码的复杂性增加。
  -  **频繁变换段基址**
    - **频繁调整段基址**：为了访问超过单个段的 64KB 内存，程序必须通过**改变段寄存器的值来访问不同的段**。
    - **性能开销**：每次变换段基址需要 CPU 执行额外的指令，消耗处理时间，降低性能。
    - **不适应多任务处理**：在多任务操作系统中，频繁切换段基址会导致上下文切换的效率降低，影响系统性能和速度。
- 80386的平坦模式
  - **段基址是 32 位，单独的一个寄存器也是 32 位，任意一个段都可以访问到 4GB 空间，不用再变化段基**
    **址了。**
  - 甚至段基址可以是 0，光用段内偏移就可以指向 4GB 空间任意角落。这就开启了“平坦模式”

---

### 寻址方式拓展

![image-20240802194950350](/home/ZMR/.config/Typora/typora-user-images/image-20240802194950350.png)

- 保护模式下：基址寄存器不再只是 bx、bp，而是所有 32 位的通用寄存器
- 变址寄存器也是一样，不再只是 si、di，而是除 esp 之外的所有 32 位通用寄存器
- 偏移量由实模式的 16 位变成了 32 位。并且，还可以对变址寄存器乘以一个比例因子

---

### 运行模式反转

#### bits 伪指令指定运行模式

- bits 的指令格式是[bits 16]或[bits 32]。
  [bits 16]是告诉编译器，下面的代码帮我编译成 16 位的机器码。
  [bits 32]是告诉编译器，下面的代码帮我编译成 32 位的机器码。

![image-20240802195256765](/home/ZMR/.config/Typora/typora-user-images/image-20240802195256765.png)

#### 0x66：操作数大小反转前缀

- 16 位实模式下可以用 32 位保护模式下的寄存器，需要**在指令前添加指令前缀 0x66**

  ![image-20240802195421174](/home/ZMR/.config/Typora/typora-user-images/image-20240802195421174.png)

  - 第 3 行用到了 32 位寄存器 eax，属于 32 位操作数，由于当前模式是 16 位，要用 0x66 将操作数大小转为
    32 位，故机器码是 66B834120000。其中 34120000 是另一操作数，B8 是操作码，0x66 便是操作数反转前缀。

#### 0x67：寻址方式反转前缀

- 使用对方模式下的寻址方式

  ![image-20240802200122325](/home/ZMR/.config/Typora/typora-user-images/image-20240802200122325.png)

  - 第 2 行的指令，从操作数和寻址方式来看，本身符合 16 位模式，无需添加任何反转前缀。
  - 第 3 行把eax 寄存器作为基址寻址，eax 寄存器不属于实模式，所以在机器码前添加了寻址方式反转前缀 0x67。
  - 第4 行同样是用 eax 寄存器作为基址寻址，并且用到了伪指令 dword，表示在 eax 所表示的内存处，连续写入 4 字节大小的数据。操作数大小也由默认的 2 字节变成了 4 字节，就会添加 0x66 的前缀

---

### 指令扩展

- 在实模式环境下：
  当压入 8 位立即数时，由于实模式下默认操作数是 16 位，CPU 会将其扩展为 16 位后再将其入栈，sp-2。
  当压入 16 位立即数时，CPU 会将其直接入栈，sp-2。
  当压入 32 位立即数时，CPU 会将其直接入栈，sp-4。

- 在保护模式下：
  当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp 指针减 4。
  当压入 16 位立即数时，CPU 直接压入 2 字节，esp 指针减 2。
  当压入 32 位立即数时，CPU 直接压入 4 字节，esp 指针减 4。

- 对于段寄存器入栈：

  即 cs、ds、es、fs、gs、ss，无论在哪种模式下，都是按当前模式的默认操作数大小压入的。例如，在 16 位模式下，CPU 直接压入 2 字节，栈指针 sp 减 2。在 32 位模式下，CPU 直接压入 4 字节，栈指针 esp 减 4。

- 对于通用寄存器和内存：无论是在实模式或保护模式
  y 如果压入的是 16 位数据，栈指针减 2。
  y 如果压入的是 32 位数据，栈指针减 4。

---

---

## 全局描述符表GDT（从实模式进入保护模式前做的准备）	

全局描述符表（Global Descriptor Table，GDT）是**保护模式下内存段的登记表**，这是不同于实模式的显著特征之一。

### 段描述符

![image-20240802205043588](/home/ZMR/.config/Typora/typora-user-images/image-20240802205043588.png)

- **段描述符**：用于描述内存段（如数据段、代码段等）的属性，结构大小为8字节（64位），分为低32位和高32位两部分，但必须连续存储。**CPU读取段描述符以获取段的正确信息，并缓存到段描述符缓冲寄存器中**。

  ```assembly
                                                          ;-------构建全局描述符表，并直接在里面填充段描述符-----------
  GDT_BASE:                                               ;GDT 的起始地址是标号 GDT_BASE所在的地址
      dd 0x00000000                                       ;下面定义了三个段描述符，每个描述符8字节
  	dd 0x00000000                                       ;因为第0个描述符不可用，所以前8个字节用0填充，因此下面段描述符是从第一个开始
  
  CODE_DESC:                                              ;---第一个：代 码 段 描 述 符 CODE_DESC
      dd 0x0000FFFF                                       ;低 4 字节中：低 2 字节是段界限的 0～15 位，高 2 字节是段基址的 0～15 位
  	dd DESC_CODE_HIGH4                                  ;高 4 字节中:复杂的字段已经在boot.inc文件里以宏的形式定义好了，这里直接用即可（下面两个同理）
  
  DATA_STACK_DESC:                                        ;---第二个：数 据 段 和 栈 段 描 述 符 DATA_STACK_DESC
      dd 0x0000FFFF
      dd DESC_DATA_HIGH4
  
  VIDEO_DESC:                                             ;---第三个：显存段描述符 VIDEO_DESC
      dd 0x80000007	                                    
      dd DESC_VIDEO_HIGH4                                 
  ```

  

#### ★★★ 段基址和段界限

- 段基址：表示**内存段的起始地址**，通常为32位地址（在段描述符中被拆成了三段）。
- 段界限：表示**段的大小和范围**，用20位二进制数表示（在段描述符中被拆成了两段）。它的作用是**限制段内偏移地址的范围**。段界限可以表示的单位量为1B（G位为0）或4KB（G位为1）。段的实际大小计算公式为：
  - G位为0时：实际段界限 = （描述符中段界限+1）*1 -1 = 描述符中段界限
  - G位为1时：实际段界限 = （描述符中段界限+1）*4KB -1
- 例：G位为1时，如果是平坦模型，描述符段界限为 0xFFFFF，那么实际段界限边界值=0x100000*0x1000-1=0xFFFFFFFF。
  - 这意味着段的地址范围从0到0xFFFFFFFF（即4GB）


#### 内存访问

- 内存访问需要提供“段基址：段内偏移地址”，其中段界限用来限制段内偏移地址的范围。如果偏移地址超过段界限的范围，CPU会抛出异常。

#### 段描述符结构

低32位

- 前16位：存储段界限的低16位（0-15位）
- 后16位：存储段基址的低16位（0-15位）

高32位

- 0-7位：存储段基址的中间8位（16-23位）
- 8-11位：Type字段，指定描述符类型
- 12位：S字段，指示是否是系统段（0）或非系统段（1）
- 13-14位：DPL字段，描述符特权级，表示内存段的特权级
- 15位：P字段，指示段是否存在（1表示存在，0表示不存在）
- 16-19位：存储段界限的高4位（16-19位）
- 20位：AVL字段，用户可用位
- 21位：L字段，设置是否是64位代码段（1表示64位，0表示32位）
- 22位：D/B字段，指示有效地址和操作数的大小
- 23位：G字段，粒度，决定段界限的单位大小（0为1B，1为4KB）
- 24-31位：存储段基址的高8位（24-31位）

#### Type字段（Type字段和S字段组合确定描述符类型）

- 系统段类型（S为0）
  - 各种“门”结构，如调用门、任务门、中断门、陷阱门等
- 非系统段类型（S为1）
  - 代码段
    - X: 可执行位（1表示可执行，0表示不可执行）
    - R: 可读位（1表示可读，0表示不可读）
    - C: 一致性代码段（1表示一致性，0表示非一致性）
  - 数据段
    - E: 段扩展方向（0表示向上扩展，1表示向下扩展）
    - W: 可写位（1表示可写，0表示不可写）

#### 特权级（DPL字段）

- 保护模式下，将计算机世界按权力划分成不同等级，分别为0、1、2、3级，**数字越小特权级越大。保护模式下的操作系统处于最高的0特权级，用户程序通常处于最低的3特权级。**

#### 粒度（G字段）

- 段界限的单位大小：
  - G为0：单位为1字节，段最大为1MB（2的 20 次方*1 字节）
  - G为1：单位为4KB，段最大为4GB（2 的 20 次方*4KB 字节）

---

### 全局描述符表 GDT、局部描述符表 LDT 及选择子

#### 段描述符的定义

在保护模式下，段描述符用于描述内存段的属性，包括基地址、段界限、段类型等。每个内存段（如代码段、数据段、栈段等）都需要一个段描述符。

#### 全局描述符表（GDT）

段描述符被存储在全局描述符表（Global Descriptor Table, GDT）中。GDT 是一个数组，其中每个元素都是一个8字节的段描述符。GDT 可以被多个程序共享，因此称为“全局”描述符表。第0个段描述符不可用。

#### GDT 寄存器（GDTR）

GDT 位于内存中，CPU 通过一个专用寄存器 GDTR（GDT Register）来指向 GDT。GDTR 是一个48位的寄存器，前16位存储GDT的大小（以字节为单位），后32位存储GDT的起始地址。我们用 `lgdt` 指令来加载 GDTR。

![image-20240803105229063](/home/ZMR/.config/Typora/typora-user-images/image-20240803105229063.png)

```assembly
gdt_ptr dw GDT_LIMIT      	;定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址
	    dd  GDT_BASE
...
lgdt [gdt_ptr]				;加载GDT（进入保护模式的其中一步）
```



#### 选择子（Selector）

段寄存器（如CS、DS、ES、FS、GS、SS）在保护模式下存储的是选择子，而不是段基地址。选择子用于在段描述符表（GDT或LDT）中索引段描述符。

![image-20240803105058313](/home/ZMR/.config/Typora/typora-user-images/image-20240803105058313.png)

选择子是16位的，包含：

- 低2位：请求特权级（RPL, Request Privilege Level）。
- 第2位：表指示位（TI, Table Indicator），0表示GDT，1表示LDT。
- 高13位：描述符索引，用于在GDT或LDT中索引段描述符。

```assembly
SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0 
SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0
SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0
```



#### 保护模式下的内存分段

即使在保护模式下，IA-32架构仍然使用段基址和段内偏移地址的形式访问内存。但由于32位地址线和32位寄存器可以直接提供32位地址，**不需要再将段基址乘以16后与段内偏移地址相加**。选择子指向的段描述符中的段基址**直接加**上段内偏移地址就构成了实际的内存地址。

#### LDT（局部描述符表）

LDT（Local Descriptor Table）是为了支持多任务，每个任务可以有自己的LDT。LDT的地址存储在LDTR寄存器中，使用`lldt`指令加载。与GDT不同，LDT中的第0个段描述符是可用的，因为TI位指示选择子是在LDT中索引段描述符。

---

### ★★★ GDTR、GDT、选择子、段描述符、段描述符缓冲寄存器、内存段的关系

![image-20240803105526222](/home/ZMR/.config/Typora/typora-user-images/image-20240803105526222.png)

- GDTR寄存器（数组指针）存的是GDT的内存地址及大小，GDT（数组）的内容是段描述符（数组元素），通过选择子（数组下标）对全局描述符表进行下标索引，找到相应的段描述符，而段描述符里存的是内存段的各种信息（数组中每个元素都是一个结构体，这个结构体代表一段的内存区域）

- 即：★★★ **`通过GDTR寄存器定位GDT，通过选择子索引到GDT中的具体段描述符，将段描述符的内容缓存到段描述符缓冲寄存器中，从段描述符中取得内存段的各种信息，从而完成对内存的访问和管理。`**

- 例子：内存访问过程

  假设选择子为 `0x8` 并加载到 DS 寄存器：

  1. 低2位（RPL）为 `00`。
  2. 第2位（TI）为 `0`，表示在GDT中索引段描述符。
  3. 高13位为 `0x1`，表示在GDT中索引第1个段描述符（GDT中的第0个段描述符不可用）。

  假设第1个段描述符的段基址为 `0x1234`。访问内存地址 `ds:0x9` 的过程如下：

  1. 如果选择子 `0x8` 已加载到 DS 寄存器，CPU检查段描述符缓冲寄存器，发现段基址 `0x1234` 已缓存，则直接从段描述符缓冲寄存器中取出段描述符，到第三步。若无，则到第二步。
  2. CPU使用选择子 `0x8` 在GDT中索引第1个段描述符，得到其段描述符，获得段基址 `0x1234`。CPU将段描述符的内容（如段基址 `0x1234`、段界限、属性等）缓存到 DS 寄存器的段描述符缓冲寄存器中（段寄存器DS的隐藏部分）。
  3. 将段基址 `0x1234` 与段内偏移地址 `0x9` 相加，得到实际内存地址 `0x123d`。
  
  ```assembly
      ;选择子被加载到段寄存器（如DS寄存器）是发生在程序显式执行以下指令时
      mov ax,SELECTOR_DATA
      mov ds,ax
      mov es,ax
      mov ss,ax
      mov esp,LOADER_STACK_TOP
      mov ax,SELECTOR_VIDEO
      mov gs,ax
  ```

---

### A20 地址线

在实模式下，内存访问采用“段基址：段内偏移地址”的形式，段基址需要乘以16再加上段内偏移地址。由于寄存器是16位的，段基址和段内偏移地址的最大值均为0xFFFF。这样计算出的最大地址为：

0xFFFF0+0xFFFF=0x10FFEF

但实模式下的地址线是20位，最大寻址空间是1MB，即0x00000～0xFFFFF。因此，**超过1MB的部分在逻辑上是正常的，但物理内存中没有与之对应的部分**。为了让这种地址计算方式继续可用，CPU**采用地址回绕的方法，将超过1MB的部分自动回绕到0地址，继续从0地址开始映射，即将地址对1MB求模**。

> 在实模式下，是真有可能回绕后的地址位置上本来就有别人的地址。
>
> 为了最大程度上保证系统运行的稳定，减少地址回绕时对低地址产生的影响，设计时，特意将核心的代码和内容放在了高地址的地方。

#### 地址回绕的实现

地址回绕有两种情况：

1. **只有20位地址线的CPU（如8086/8088）**：

   - 8086/8088只有20位地址线（A0～A19），最大内存空间是1MB（0x0～0xFFFFF）。
   - 当地址进位到1MB以上，如0x100000，由于没有第21位地址线，进位的1被丢掉，地址变成0x00000。

   ![image-20240803110825941](/home/ZMR/.config/Typora/typora-user-images/image-20240803110825941.png)

   2 . **80286及其后的CPU**：

   - 80286及以后的CPU有24位地址线（A0～A23），可以访问16MB的内存。
   - 但为了兼容8086/8088，80286在实模式下应表现得与8086/8088一样，只使用20条地址线（即A20线是关闭的）。这意味着如果访问0x100000～0x10FFEF之间的内存，系统应该回绕到0地址。

   为了解决此问题，IBM设计了一种通过键盘控制器上的输出线来控制A20地址线有效性的机制，称为A20Gate：

   - **A20Gate打开**：当访问0x100000～0x10FFEF之间的地址时，CPU**将访问实际的物理内存**。
   - **A20Gate关闭**：当访问0x100000～0x10FFEF之间的地址时，CPU**将采用8086/8088的地址回绕**。

#### 保护模式中的A20Gate

在保护模式下，需要突破20条地址线（A20）以访问更大的内存空间。这需要关闭地址回绕，即打开A20Gate。

打开A20Gate的步骤非常简单，通过设置端口0x92的第1位为1即可，具体步骤如下：

```assembly
;进入保护模式的其中一步
in al, 0x92
or al, 0000_0010B
out 0x92, al
```

---

### CR0 寄存器的 PE 位

- CR0寄存器的第 0 位，即 PE 位，Protection Enable，此位用于启用保护模式，是保护模式的开关

![image-20240803112254281](/home/ZMR/.config/Typora/typora-user-images/image-20240803112254281.png)

- PE 为 0 表示在实模式下运行，PE 为 1 表示在保护模式下运行

  ```assembly
  ;进入保护模式的其中一步
  mov eax, cr0			;将 cr0 写入 eax
  or eax, 0x00000001		;通过或运算 or 指令将 eax 的第 0 位置 1
  mov cr0, eax			;将 eax 写回 cr0，这样 cr0 的 PE 位便为 1 了
  ```
  
  

---

### 从实模式进入保护模式

#### ▶ 代码

mbr.S

- 注：由于 loader.bin 超过了 512 字节，故将扇区数直接扩为。其他内容同"让MBR使用硬盘"

```assembly
...
mov cx,4; 待读入的扇区数
...
jmp LOADER_BASE_ADDR ;跳转到 loader 的起始地址，执行 loader 程序
...
```



boot.inc

**定义了模块化段描述符字段宏和模块化选择子字段宏**

```assembly
                            ;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900  ;相当于c语言的#define LOADER_BASE_ADDR 0x900
                            ;定义了 loader 在内存中的位置,MBR 要把 loader 从硬盘读入后放到此处
                            ;即将来 loader 会在内存地址 0x900 处
LOADER_START_SECTOR equ 0x2 ;loader 程序在硬盘上的起始扇区

                                                    ;--------------   模块化的gdt描述符字段宏-------------
DESC_G_4K   equ	  1_00000000000000000000000b        ;设置段界限的单位为4KB
DESC_D_32   equ	   1_0000000000000000000000b        ;设置代码段/数据段的有效地址（段内偏移地址）及操作数大小为32位，而非16位
DESC_L	    equ	    0_000000000000000000000b	    ;64位代码段标记位，我们现在是在编写32位操作系统，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	    ;此标志位是为了给操作系统或其他软件设计的一个自定义位，
                                                    ;可以将这个位用于任何自定义的需求。
                                                    ;比如，操作系统可以用这个位来标记这个段是否正在被使用，或者用于其他特定的需求。
                                                    ;这取决于开发者如何使用这个位。但从硬件的角度来看，AVL位没有任何特定的功能或意义，它的使用完全由软件决定。
DESC_LIMIT_CODE2  equ 1111_0000000000000000b        ;定义代码段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2              ;定义数据段要用的段描述符高32位中16~19段界限为全1
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b        ;定义我们要操作显存时对应的段描述符的高32位中16~19段界限为全0
DESC_P	    equ		  1_000000000000000b            ;定义了段描述符中的P标志位，表示该段描述符指向的段是否在内存中
DESC_DPL_0  equ		   00_0000000000000b            ;定义DPL为0的字段
DESC_DPL_1  equ		   01_0000000000000b            ;定义DPL为1的字段
DESC_DPL_2  equ		   10_0000000000000b            ;定义DPL为2的字段
DESC_DPL_3  equ		   11_0000000000000b            ;定义DPL为3的字段
DESC_S_CODE equ		     1_000000000000b            ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_DATA equ	  DESC_S_CODE                       ;无论代码段，还是数据段，对于cpu来说都是非系统段，所以将S位置为1，见书p153图
DESC_S_sys  equ		     0_000000000000b            ;将段描述符的S位置为0，表示系统段
DESC_TYPE_CODE  equ	      1000_00000000b	        ;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	        ;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.


                                                    ;定义代码段，数据段，显存段的高32位--->在loader.s里面定义段描述符时用到
DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

                                                    ;--------------   模块化的选择子字段宏  ---------------
RPL0  equ   00b                                     ;定义选择字的RPL为0
RPL1  equ   01b                                     ;定义选择子的RPL为1
RPL2  equ   10b                                     ;定义选择字的RPL为2
RPL3  equ   11b                                     ;定义选择子的RPL为3
TI_GDT	 equ   000b                                 ;定义段选择子请求的段描述符是在GDT中
TI_LDT	 equ   100b                                 ;定义段选择子请求的段描述符是在LDT中
```



loader.S

准备并进入保护模式后利用初始化的GDT表中的显存段描述符来对显存寻址后操作以显示字符

```assembly
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
    jmp loader_start					                ;loader一进来是下面一大堆GDT段描述符数据，无法执行，所以要跳过
                                                        ;虽然代码在执行时跳过了定义部分，但定义部分的数据已经被加载到内存中，并可以通过相关的指令来访问和使用
   
                                                        ;-----------------   保护模式前的准备过程   -------------------
                                                        
                                                        ;-------构建全局描述符表，并直接在里面填充段描述符-----------
GDT_BASE:                                               ;GDT 的起始地址是标号 GDT_BASE所在的地址
    dd 0x00000000                                       ;下面定义了三个段描述符，每个描述符8字节
	dd 0x00000000                                       ;因为第0个描述符不可用，所以前8个字节用0填充，因此下面段描述符是从第一个开始

CODE_DESC:                                              ;---第一个：代 码 段 描 述 符 CODE_DESC
    dd 0x0000FFFF                                       ;低 4 字节中：低 2 字节是段界限的 0～15 位，高 2 字节是段基址的 0～15 位
	dd DESC_CODE_HIGH4                                  ;高 4 字节中:复杂的字段已经在boot.inc文件里以宏的形式定义好了，这里直接用即可（下面两个同理）

DATA_STACK_DESC:                                        ;---第二个：数 据 段 和 栈 段 描 述 符 DATA_STACK_DESC
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

VIDEO_DESC:                                             ;---第三个：显存段描述符 VIDEO_DESC
    dd 0x80000007	                                    ;limit=(0xbffff-0xb8000)/4k=0x7
    dd DESC_VIDEO_HIGH4                                 ; 此时dpl已改为0

    GDT_SIZE equ $ - GDT_BASE                           ;--------计算gdt的界限--------
    GDT_LIMIT equ GDT_SIZE - 1 

    times 60 dq 0					                    ;--------此处预留60个描述符的空间--------

                                                        ;--------构建代码段、数据段、显存段的选择子-----------
    SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0       ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
    SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	    ; 同上
    SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	    ; 同上 

                                                        ;-------定义全局描述符表 GDT 的指针(用于 lgdt 加载 GDT 到 gdtr 寄存器)-----------
gdt_ptr dw GDT_LIMIT                                    ;定义加载进入GDTR的数据，前2字节是gdt界限，后4字节是gdt起始地址，
	    dd  GDT_BASE
loadermsg db '2 loader in real.'

loader_start:
                                                        ;----------------------------------------------------------
                                                        ;INT 0x10    功能号:0x13    功能描述:打印字符串“2 loader in real.”
                                                        ;---------------------------------------------------------- 
    mov sp,LOADER_BASE_ADDR
    mov	bp,loadermsg                                    
    mov	cx,17			                                
    mov	ax,0x1301		                                
    mov	bx,0x001f		                                
    mov	dx,0x1800		                                
    int	0x10                                            

                                                        ;-----------------   准备进入保护模式   ----------------------
                                                        ;1 打开A20
                                                        ;2 加载gdt
                                                        ;3 将cr0的pe位置1

                                                        ;-----------------  打开A20  ----------------
    in al, 0x92
    or al, 0000_0010B
    out 0x92,al

                                                        ;-----------------  加载GDT  ----------------
    lgdt [gdt_ptr]


                                                        ;-----------------  cr0第0位置1  ----------------
    mov eax,cr0
    or eax,0x00000001
    mov cr0,eax

                                                        ;jmp dword SELECTOR_CODE:p_mode_start	    
    jmp  SELECTOR_CODE:p_mode_start	                    ; 刷新流水线，避免分支预测的影响。这种cpu优化策略，最怕jmp跳转，
					                                    ; 这将导致之前做的预测失效，从而起到了刷新的作用。

[bits 32]
p_mode_start:
                                                        ;---------用构29行的选择子初始化成各段寄存器----------
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

    mov byte [gs:160], 'P'

    jmp $

```

#### 代码解释

- loader.S 中第 4 行的“jmp loader_start”，其机器码是 E91702，共 3 字节大小。其中的 E9 是操作码，1702 是操作数，由于是小端字节序，所以其十六进制是 0x217，这是 16 位相对近转移。此指令直接跳过 GDT 定义相关部分，直接到第 32 行。第 32 行的标号 loader_start 在文件内的地址是“jmp loader_start”的 3 字节机器码+4 个段描述符大小+预留的 60 个描述符大小+gdt_ptr 的 6 字节+loadermsg 的 17 个字节=3+32+480+6+17=538=0x21a。再加上 loader 被加载到的地址 0x900，在内存中的实际地址为 0x900+0x21a=0xb1a。

  - 如果不包括第 4 行的 jmploader_start，那么 loader_start 的地址将是 0xb1a-3=0xb17。也就是说，如果把mbr 中跳入 loader 的语句 jmp LOADER_BASE_ADDR，改成 jmp LOADER_BASE_ADDR+ 0xb17，其结果也是一样的，直接跳转到 loader.S 中的 loader_start
  
  

  ![image-20240803165339199](/home/ZMR/.config/Typora/typora-user-images/image-20240803165339199.png)

- loader.S文件打印了：左下角的字符串“2 loader in real”是在实模式下用 BIOS 中断 0x10 打印的。左上角第 2 行的字符'P'，这是咱们在保护模式下输出的

- mbr.S文件打印了：左上角第一行的“1 MBR”

- loader.S文件逻辑：[点击](https://blog.csdn.net/kanshanxd/article/details/130749718)

---

---

## 处理器微架构（提升执行效率的策略）

### 流水线

![image-20240803210139690](/home/ZMR/.config/Typora/typora-user-images/image-20240803210139690.png)

​	流水线是指**将指令的执行过程分成多个步骤，并且每个步骤由不同的硬件单元独立执行**。比如，我们可以将“砸钉子”这一过程分为两个步骤：“取钉子”和“砸钉子”，每个步骤分别需要1秒。如果按照顺序执行，每2秒能完成一个钉子。若将取钉子和砸钉子两个步骤重叠执行，每秒就能完成一个钉子。应用到CPU中，指令的执行可以分为取指令、译码和执行三个步骤，这样在**同一时钟周期内，CPU可以同时执行三条不同指令的不同步骤**，大大提高了效率。

​	CPU 是按照程序中指令顺序来填充流水线的，也就是说按照程序计数器 PC（x86中是 cs：ip）中的值来装载流水线的，当前指令和下一条指令在空间上是挨着的。如果当前执行的指令是jmp，下一条指令已经被送上流水线译码了，第三条指令已经被送上流水线取指了。而CPU 早已经跳到别处去执行了，第二、三条指令用不上了，**所以 CPU 在遇到无条件转移指令 jmp 时，需要清空流水线。**



#### 使用远跳转指令清空流水线，更新段描述符缓冲寄存器

在**进入保护模式时**，我们需要解决两个问题：**更新段描述符缓冲寄存器和清空流水线**。我们使用的指令是：

```assembly
jmp dword SELECTOR_CODE:p_mode_start
```

更新段描述符缓冲寄存器

- **问题**：段描述符缓冲寄存器未更新，仍包含实模式的值。
- **解决**：在进入保护模式后，立即更新段描述符缓冲寄存器，加载正确的选择子。
- **原因**：保护模式需要正确的段描述符，而实模式的值会导致错误。

清空流水线

- **问题**：指令译码错误，导致16位和32位指令混用。
- **解决**：使用远跳转指令清空流水线。
- **原因**：保护模式下指令是32位，而流水线中已存在的16位指令会导致错误。

---

### 乱序执行

乱序执行是指CPU不按照代码中的顺序执行指令，而是根据指令之间的依赖关系和硬件资源的空闲状态来安排指令的执行顺序。例如，以下代码中第1行和第2行不能乱序执行，因为第2行依赖第1行的结果：

```assembly
mov eax, [0x1234]
add eax, ebx
```

但如果修改为以下代码，第2行可以在第1行内存访问的等待过程中执行：

```assembly
mov eax, [0x1234]
add ecx, ebx
```

这种策略利用指令之间的独立性，提高了流水线的效率。

### 缓存

缓存是用来缓解存储设备访问速度较慢的问题的一种机制。CPU中通常有一级缓存（L1）、二级缓存（L2）和三级缓存（L3）。缓存利用程序的局部性原理，最近访问的数据和靠近当前访问的数据在将来一段时间内也会被频繁访问，通过将这些数据加载到缓存中，可以减少CPU对内存的访问次数，从而提高效率。

### 分支预测

分支预测是在处理器遇到分支指令时，预测哪条路径更可能被执行，并提前将预测路径的指令放入流水线中执行。例如，在以下代码中：

```c
if (condition) {
    // do something
} else {
    // do something else
}
```

CPU会预测`condition`是true还是false，从而决定加载哪部分指令到流水线中。如果预测正确，程序会更快地执行。

---

---

## 对内存段的保护（保护模式保护了什么）

### 段寄存器加载选择子时的保护

当引用一个内存段时，需要将选择子加载到段寄存器。为了防止非法引用内存段，处理器在以下几个方面进行检查：

![image-20240803214119648](/home/ZMR/.config/Typora/typora-user-images/image-20240803214119648.png)

1. **选择子是否超越界限**：
   - 选择子的高13位是段描述符的索引值（第0～1位是RPL，第2位是TI位）。
   - 处理器验证选择子的索引值是否在描述符表（GDT或LDT）的界限内。
2. **描述符表基地址和界限值检查**：
   - 如果TI位是0，从全局描述符表寄存器（GDTR）中获取GDT基地址和界限值。
   - 如果TI位是1，从局部描述符表寄存器（LDTR）中获取LDT基地址和界限值。
   - 处理器检查选择子的索引值是否在描述符表的界限内。如果不满足条件，处理器抛出异常。

### 段类型检查

在选择子检查后，处理器还要检查段的类型。主要原则如下：

- 只有具备可执行属性的段（代码段）才能加载到CS段寄存器中。
- 只具备执行属性的段（代码段）不允许加载到除CS外的段寄存器中。
- 只有具备可写属性的段（数据段）才能加载到SS栈段寄存器中。
- 至少具备可读属性的段才能加载到DS、ES、FS、GS段寄存器中。

### 段存在性检查

处理器通过段描述符中的P位检查段是否存在：

- 如果P位为1，表示段存在，可以将选择子载入段寄存器，同时更新段描述符缓冲寄存器。
- 如果P位为0，表示段不存在，处理器抛出异常并执行异常处理程序。

### 代码段和数据段的保护

对于代码段和数据段，处理器在每次访问内存地址时，确保地址在段内的有效范围内：

![image-20240803215248744](/home/ZMR/.config/Typora/typora-user-images/image-20240803215248744.png)

1. **代码段检查**：
   - EIP（段内偏移地址）+ 指令长度 - 1 ≤ 实际段界限大小
   - 如果指令不完全在段内，处理器抛出异常。
2. **数据段检查**：
   - 偏移地址 + 数据长度 - 1 ≤ 实际段界限大小
   - 如果数据不完全在段内，处理器抛出异常。

### ★★ 栈段的保护

栈段可以是向上扩展或向下扩展的数据段。对于向下扩展的段，实际段界限是段内不可访问的第一个字节。处理器确保栈指针（ESP）在栈段内的有效范围内：

![image-20240805110857539](/home/ZMR/.config/Typora/typora-user-images/image-20240805110857539.png)

- 实际段界限 + 1 ≤ **ESP - 操作数大小** ≤ 0xFFFFFFFF
  - 例：
  - 假设现在 esp 指针为 0xFFFFE002，段描述符的 G 位为 1，描述符中的段界限为 0xFFFFD。
  - 压栈前检查：实际段界限为0x1000*FFFFD+0xFFF=0xFFFFDFFF。当执行 push ax，压入 2 字节的操作数，即 esp-2=0xFFFFE000，新的 esp 值≥实际段界限 0xFFFFDFFF +1。如果执行 push eax，压入 4 字节的数据，esp-4=0xFFFFDFFE，小于实际段界限0xFFFFDFFF，故 CPU 会抛出异常。
  - 压栈后算物理地址：由于 esp 只是栈段内的偏移地址，其真正物理地址还要加上段基址。

> 关于为什么有栈段基址了，还要引入段界限来限制栈段的大小：
>
> 段描述符中定义了段基址和段界限等内存段的信息，分别表示段的内存起始地址和段的大小。段界限和栈底之间的内容为栈段的大小。因为一个地址是由段基址+偏移地址构成，这意味着可能栈段基址下面的段可能会由于（非法）加了一个很大的偏移地址，使其跨越了原本它那个段的范围，而定位到栈段。（或者说栈段的段基址本身就位于其他内存段的里边）所以栈段基址到段界限+1的位置都有可能是其他段的部分。因此栈仍需要一个段界限来限制栈向下拓展的范围。

---

---

---

# 第五章 保护模式进阶，向内核迈进

## 获取物理内存容量

在 Linux 系统中，有多种方法可以获取内存容量。如果一种方法失败，可以尝试其他方法。

例如，在 Linux 2.6 内核中，通过 `detect_memory` 函数获取内存容量。这个函数通过调用 BIOS 中断 0x15 实现，主要使用 BIOS 中断 0x15 的以下三个子功能：

1. **EAX=0xE820**：遍历主机上全部内存。
2. **AX=0xE801**：检测低于 15MB 和 16MB~4GB 的内存，最大支持 4GB。
3. **AH=0x88**：最多检测 64MB 内存，实际内存超过此容量也按 64MB 返回。

这些方法**都在实模式下使用**。若所有方法均失败，系统无法获取内存信息，只能挂起停止运行。

BIOS 中断通过连续调用硬件的 API 获取内存信息。调用 BIOS 中断有代价，因此尽量在一次中断中返回尽可能多的信息，由用户程序挑选重点内容。

###  利用 BIOS 中断 0x15 子功能 0xE820 获取内存

BIOS 中断 0x15 的子功能 0xE820 能获取系统内存布局，以类型属性划分系统内存。每次调用此中断返回一种类型的内存信息，直到所有类型返回完毕。此方法返回丰富的内存信息，包括多个属性字段。

#### 地址范围描述符结构 ARDS

- Address Range Descriptor Structure

- 内存信息的内容是用地址范围描述符来描述的，用ARDS存储地址范围描述符
- ARDS 结构总大小为 20 字节
- **每次 int 0x15 之后，BIOS就返回这样一个结构的数据**。
- 注意，ARDS 结构中用 64 位宽度的属性来描述这段内存基地址（起始地址）及其长度

| 字节偏移量 | 属性名称     | 描述                             |
| ---------- | ------------ | -------------------------------- |
| 0          | BaseAddrLow  | 内存基地址的低 32 位             |
| 4          | BaseAddrHigh | 内存基地址的高 32 位             |
| 8          | LengthLow    | 内存长度的低 32 位，以字节为单位 |
| 12         | LengthHigh   | 内存长度的高 32 位               |
| 16         | Type         | 内存类型                         |

- 地址范围描述符结构的 Type 字段如下：

| Type 值 | 名称                 | 描述                                          |
| ------- | -------------------- | --------------------------------------------- |
| 1       | AddressRangeMemory   | 可被操作系统使用的内存                        |
| 2       | AddressRangeReserved | 被系统保留，不可用的内存                      |
| 其他    | 未定义               | 保留，将来可能使用，视为 AddressRangeReserved |

#### ★★★地址范围描述符和段描述符的区别（物理内存和逻辑内存的区别）

- 地址范围描述符: 主要用于**描述系统物理内存的布局和状态**，特别是在系统启动时，通过 BIOS 获取内存信息。地址范围描述符的结构通常包括内存块的起始地址、长度和类型。
- 段描述符: 用于**分段内存管理**，主要在x86架构中使用，涉及到保护模式下的内存管理。段描述符在段选择器中定义一个段的基地址、长度、类型、特权级等信息。

| **特性**     | **地址范围描述符** (Address Range Descriptor) | **段描述符** (Segment Descriptor)              |
| ------------ | --------------------------------------------- | ---------------------------------------------- |
| **作用范围** | 用于描述物理内存布局                          | 用于描述逻辑内存布局                           |
| **使用时机** | 系统启动时通过BIOS获取                        | 操作系统启动和运行时用于内存管理               |
| **用途**     | 告诉操作系统哪些物理内存可用，哪些需要保留    | 设置和管理代码段、数据段等的访问权限和地址范围 |



| **特性**     | **物理内存** (Physical Memory)                       | **逻辑内存** (Logical Memory)                              |
| ------------ | ---------------------------------------------------- | ---------------------------------------------------------- |
| **定义**     | 实际存在于硬件中的内存模块，即RAM                    | 操作系统为每个进程提供的虚拟地址空间                       |
| **地址空间** | 固定的地址范围，从0开始到内存条的最大容量            | 每个进程的地址空间独立且连续                               |
| **访问方式** | CPU通过操作系统直接访问                              | 通过内存管理单元（MMU）将逻辑地址映射到物理地址            |
| **独立性**   | 所有进程共享同一物理内存，需要操作系统管理           | 每个进程拥有独立的逻辑地址空间                             |
| **安全性**   | 操作系统协调管理以确保安全性                         | 提供进程间的地址空间隔离，防止互相干扰                     |
| **扩展性**   | 物理内存容量有限，扩展需要增加硬件                   | 逻辑内存可以通过页面交换机制扩展，使用比物理内存大的空间   |
| **描述符**   | 使用地址范围描述符（Address Range Descriptor, ARDS） | 使用段描述符（Segment Descriptor）                         |
| **主要用途** | 描述实际物理内存的布局和可用性                       | 管理和保护进程的地址空间，设置代码段、数据段等             |
| **管理机制** | 通过BIOS中断获取内存信息，操作系统管理物理内存       | 操作系统分配和管理虚拟地址空间，通过段和页表映射到物理内存 |
| **示例**     | BIOS中断0x15获取内存布局信息                         | 操作系统启动时为每个进程分配虚拟地址空间                   |



#### BIOS 中断 0x15 子功能 0xE820 

| 调用或返回 | 寄存器或状态位 | 用途                                             |
| ---------- | -------------- | ------------------------------------------------ |
| 调用前输入 | EAX            | 子功能号：0xE820                                 |
|            | EBX            | ARDS 后续值，第一次调用置 0，之后 BIOS 更新此值  |
|            | ES             | ARDS 缓冲区，BIOS 写入内存信息的地址             |
|            | ECX            | ARDS 结构的字节大小，默认为 20 字节              |
|            | EDX            | 签名标记 0x534d4150 ("SMAP")                     |
| 返回后输出 | CF 位          | 0 表示调用成功，1 表示调用出错                   |
|            | EAX            | 签名标记 0x534d4150 ("SMAP")                     |
|            | ES             | ARDS 缓冲区地址，返回的内存信息                  |
|            | ECX            | ARDS 结构字节数，最小 20 字节                    |
|            | EBX            | 下一个 ARDS 的位置，若为 0 表示这是最后一个 ARDS |

调用步骤如下：

1. 填写调用前输入的寄存器。
2. 执行中断调用 `int 0x15`。
3. 若 CF 位为 0，返回后输出的寄存器包含结果。

---

### 利用 BIOS 中断 0x15 子功能 0xE801 获取内存

BIOS 中断 0x15 的子功能 0xE801 识别最大 4GB 内存。检测结果分别存放在两组寄存器中。低于 15MB 的内存以 1KB 为单位存放在 AX 和 CX 中；16MB~4GB 的内存以 64KB 为单位存放在 BX 和 DX 中。

| 调用或返回 | 寄存器或状态位 | 用途                           |
| ---------- | -------------- | ------------------------------ |
| 调用前输入 | AX             | 子功能号：0xE801               |
| 返回后输出 | CF 位          | 0 表示调用成功，1 表示调用出错 |
|            | AX             | 低于 15MB 的内存容量，单位 1KB |
|            | BX             | 16MB~4GB 的内存容量，单位 64KB |
|            | CX             | 同 AX                          |
|            | DX             | 同 BX                          |

调用步骤如下：

1. 将 AX 寄存器写入 0xE801。
2. 执行中断调用 `int 0x15`。
3. 若 CF 位为 0，返回后输出的寄存器包含结果。

---

### 利用 BIOS 中断 0x15 子功能 0x88 获取内存

BIOS 中断 0x15 的子功能 0x88 只能识别最大 64MB 内存。检测结果存放在 AX 中，单位为 1KB。

| 调用或返回 | 寄存器或状态位 | 用途                           |
| ---------- | :------------- | ------------------------------ |
| 调用前输入 | AH             | 子功能号：0x88                 |
| 返回后输出 | CF 位          | 0 表示调用成功，1 表示调用出错 |
|            | AX             | 1MB 以上的内存容量，单位 1KB   |

调用步骤如下：

1. 将 AX 寄存器写入 0x88。
2. 执行中断调用 `int 0x15`。
3. 若 CF 位为 0，返回后输出的寄存器包含结果。

---

### ▶ 代码（获取物理内存容量）

mbr.S

```assembly
...
jmp LOADER_BASE_ADDR + 0x300	;★★★跳转到 loader.S 文件中的 loader_start:位置。
...
```

- **★★★ 注：0x300是loader_start:相对于loader.S起始地址的偏移量**
- 计算如下：
- total_mem_bytes 前面有 4 个段描述符的定义，还有预留 60 个段描述槽位 times 60 dq 0。段描述符大小是 8 字节，dq 也是 8 字节，所以 total_mem_bytes 偏移量是 (4+60)*8=512=0x200 字节。（本程序的加载地址是 0x900，0x900+0x200=0xb00，所以 0xb00是变量 total_mem_bytes 加载到内存中的地址）
- total_mem_bytes是 4 字节，gdt_ptr 是 6 字节，ards_buf 是 244 字节，ards_nr 是 2 字节，加起来的和是 256 字节，即 0x100。加上 total_mem_bytes 在文件内偏移地址是 0x200，所以 loader_start 在文件内的偏移地址是 0x100+0x200=0x300。



loader.S

**在实模式下调用BIOS中断获得内存容量，然后将信息存储在内存中**

```assembly
%include "boot.inc"                                     
section loader vstart=LOADER_BASE_ADDR                  
LOADER_STACK_TOP equ LOADER_BASE_ADDR                   				                    

;jmp loader_start	;★★★由于mbr.S中调用该程序时，直接跳转到loader_start:位置，故不需要它再次跳转了

;-----------------   保护模式前的准备过程   ------------------------------------------
;-------构建全局描述符表，并直接在里面填充段描述符-----------
GDT_BASE:                                               
    dd 0x00000000                                       
	dd 0x00000000                                       

CODE_DESC:                                              
    dd 0x0000FFFF                                       
	dd DESC_CODE_HIGH4                                  

DATA_STACK_DESC:                                        
    dd 0x0000FFFF                                       
    dd DESC_DATA_HIGH4                                  

VIDEO_DESC:                                             
    dd 0x80000007	                                    
    dd DESC_VIDEO_HIGH4                                 

GDT_SIZE equ $ - GDT_BASE                               
GDT_LIMIT equ GDT_SIZE - 1                              

times 60 dq 0					                        

;--------构建代码段、数据段、显存段的选择子-----------
SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0           
SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	        
SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	        

total_mem_bytes dd 0				                    ; ★★★用于保存内存容量，偏移 0x200 字节

gdt_ptr dw GDT_LIMIT                                    ; 定义加载到 GDTR 的数据，前 2 字节是 GDT 界限
	    dd  GDT_BASE                                    ; 后 4 字节是 GDT 起始地址

ards_buf times 244 db 0                                 ; 预留 244 字节的 ARDS 缓冲区
ards_nr dw 0		                                    ; 用于记录 ARDS 结构体数量

loader_start:                                           ; ★★★从 mbr.S 直接跳转到这边，偏移 ox300字节

;-------  int 15h eax = 0000E820h ,edx = 534D4150h ('SMAP') 获取内存布局 -------
xor ebx, ebx		                                    ; 第一次调用时，ebx 值为 0
mov edx, 0x534d4150	                                    ; edx 赋值为 'SMAP' 标志
mov di, ards_buf	                                    ; di 指向 ARDS 缓冲区
.e820_mem_get_loop:	                                    ; 循环获取每个 ARDS 内存范围描述结构
mov eax, 0x0000e820	                                    ; 设置 E820 功能号
mov ecx, 20		                                        ; ARDS 结构大小是 20 字节
int 0x15                                                ; 调用 BIOS 中断 0x15 获取内存信息
add di, cx		                                        ; di 增加 20 字节，指向下一个 ARDS 结构位置
inc word [ards_nr]	                                    ; 增加 ARDS 数量
cmp ebx, 0		                                        ; 如果 ebx 为 0 且 cf 不为 1，则说明所有 ARDS 都已返回
jnz .e820_mem_get_loop                                  ; 如果 ebx 不为 0，则继续循环

;-------- 在所有 ARDS 结构中，找出 (base_add_low + length_low) 的最大值，即内存容量 --------
mov cx, [ards_nr]	                                    ; 将 ARDS 数量存入 cx
mov ebx, ards_buf                                       ; ebx 指向 ARDS 缓冲区
xor edx, edx		                                    ; edx 清零，用于保存最大内存容量
.find_max_mem_area:	                                    ; 遍历每一个 ARDS 结构体
mov eax, [ebx]	                                        ; 取出 base_add_low
add eax, [ebx+8]	                                    ; 加上 length_low，得到该段内存的结束地址
add ebx, 20		                                        ; 指向下一个 ARDS 结构
cmp edx, eax		                                    ; 比较 edx 和 eax，找出最大值
jge .next_ards                                          ; 如果 edx >= eax，则跳到 next_ards
mov edx, eax		                                    ; 如果 eax > edx，则将 edx 赋值为 eax
.next_ards:
loop .find_max_mem_area                                 ; 循环查找最大内存块

mov [total_mem_bytes], edx	                            ; 将最大内存容量存入 total_mem_bytes

;-----------------   准备进入保护模式   ------------------------------------------
;1 打开 A20
;2 加载 GDT
;3 将 CR0 的 PE 位设为 1

;-----------------  打开 A20  ----------------
in al, 0x92                                            
or al, 0000_0010B                                      
out 0x92, al                                           

;-----------------  加载 GDT  ----------------
lgdt [gdt_ptr]                                         

;-----------------  CR0 第 0 位设为 1  ---------------
mov eax, cr0                                           
or eax, 0x00000001                                     
mov cr0, eax                                           

jmp SELECTOR_CODE:p_mode_start	                       

.error_hlt:		                                       
hlt

[bits 32]
p_mode_start:
mov ax, SELECTOR_DATA                                  
mov ds, ax                                             
mov es, ax                                             
mov ss, ax                                             
mov esp, LOADER_STACK_TOP                              
mov ax, SELECTOR_VIDEO                                 
mov gs, ax                                             

mov byte [gs:160], 'P'                                 

jmp $                                                  

```

- 代码步骤：
  1. 按照BIOS中断返回类型的数据结构来开辟内存空间来存储中断获取到的信息
  2. 查询中断使用用法，**调用BIOS中断0x15子功能0xe820获得内存的ARDS结构体**
  3. **遍历获得的ARDS结构体，将所有结构体中的BaseAddrLow与LengthLow相加**（得到的是每个内存区域的结束地址），冒泡选择**值最大的就是内存的大小**（最大的内存区域的结束地址就是这块内存所能访问到的最大的地址，也就是内存的大小）

- 变量 total_mem_bytes 的地址是 0xb00，所以咱们在 bochs 控制台中用 xp 0xb00 指令来查看该地址

  ![image-20240805213233783](/home/ZMR/.config/Typora/typora-user-images/image-20240805213233783.png)

- 查看 bochs 虚拟机的配置文件 bochsrc.disk，megs 参数用来指定内存大小，图中为32，即内存为32M

  ![image-20240805213459628](/home/ZMR/.config/Typora/typora-user-images/image-20240805213459628.png)

- 0x2000000 换算成十进制正是 32MB，可见检测结果是正确的!!!

---

---

## 内存分页机制

### 一级页表

​	分页机制其实是在分段机制的基础上构建的。虽然分页机制并不依赖于分段机制，但由于Intel IA32架构的设计，分页机制不可避免地与分段机制相关联。

#### ★★ 分段机制与分页机制（线性地址与逻辑地址、物理地址）

​	在保护模式下，段寄存器中的内容是选择子，而选择子最终指向段基址。内存访问的核心机制依然是**“段基址：段内偏移地址”，这两个地址相加后得到的绝对地址称为线性地址。在分段机制下，CPU认为线性地址就是物理地址，并直接将其送上地址总线**。分段机制下的地址访问过程如图所示：

![image-20240806171645922](/home/ZMR/.config/Typora/typora-user-images/image-20240806171645922.png)

​	分页机制建立在分段机制之上。**开启分页机制后，段部件输出的线性地址被称为虚拟地址，它不再是物理地址。CPU必须通过页表将虚拟地址转换成物理地址**（访问一个线性地址时，实际上是访问页表项中记录的物理内存地址）。分页机制下的地址访问过程如图所示：

![image-20240806171656090](/home/ZMR/.config/Typora/typora-user-images/image-20240806171656090.png)

#### 分页机制的原理与页表结构

​	分页机制的核心是通过页表将线性地址转换成物理地址，并用大小相等的页替代大小不等的段。线性地址通过映射，可以与任意物理内存地址相关联，逻辑上连续的线性地址对应的物理地址可以不连续。分页机制的主要作用如下：

1. **将线性地址转换成物理地址。**
2. **用大小相等的页代替大小不等的段。**

如图所示：

![image-20240806171712240](/home/ZMR/.config/Typora/typora-user-images/image-20240806171712240.png)



#### 分页机制下操作系统加载进程的过程

在分页机制下，**每个进程**都有自己的**4GB虚拟地址空间**。**操作系统为每个进程分配逻辑内存段，并在虚拟地址空间中分配内存块**。这些虚拟内存块在页表中映射到实际的物理内存页。每个进程都认为自己独享4GB地址空间。



#### 页表的原理与结构

为了存储地址映射关系，需要页表（Page Table）。**页表中每个单元格称为页表项**（Page Table Entry，PTE），用于**存储内存物理地址**，一个页表项大小为4字节。当访问一个线性地址时，实际上是访问页表项中记录的物理内存地址。



#### ★★★地址转换过程

32位地址可以分为高位部分和低位部分。**高位部分表示页数量，低位部分表示页内偏移**。标准页大小为4KB，4GB地址空间被划分为1M个页，每个页对应一个页表项。一级页表模型如图所示：

![image-20240806171809180](/home/ZMR/.config/Typora/typora-user-images/image-20240806171809180.png)

地址转换的关键是通过线性地址找到对应的页表项。具体步骤如下：

1. **用线性地址的高20位作为页表项索引。**
2. **页表项索引乘以4后，得到该页表项相对于页表物理地址的字节偏移量。加上页表的物理地址，得到页表项的物理地址，此时才能访问页表项。**
3. **从页表项中读取物理页地址。**
4. **用线性地址的低12位与物理页地址相加，得到最终的物理地址。**

> 1.如果采用线性地址与物理地址一一映射的方案，则表中有 4G 个页表项，32 位的地址要用 4 字节的页表项来存储，页表总共大小是 4Byte*4G =16GB。光页表就占了16GB内存，得不偿失。
>
> 2.标准的页大小为4KB，那么每个进程都有的4GB虚拟地址空间就被划分成1M个页（4GB/4KB=1M)
>
> 3.页是地址空间的计量单位，并不是专属物理地址或线性地址，只要是 4KB 的地址空间都可以称为一页，所以线性地址的一页也要对应物理地址的一页（但物理内存地址可能小于4GB*（因为cpu32位地址线带来的4GB的地址空间不仅仅用于物理内存，还包括了各种内存映射的I/O区域和固件区域）*，因此可能小于1M个页，而虚拟地址是实打实的4GB）。因为4GB的虚拟地址被分为了1M个页，因此页表中也要有1M个页表项。
>
> 4.1M=2的20次方，即线性地址（也就是逻辑地址）的高20位来表示页的数量，因为编号为0～1M-1,所以高20位也作为页表的页表项索引（相当于：页表为数组，页表项为数组元素，线性地址的高20位为数组下标）

示例如下：

假设指令 `mov ax, [0x1234]` 在平坦模型下工作，段基址为0，段内偏移地址为0x1234，线性地址为0x1234。分页机制下，线性地址0x1234被送入页部件，页部件分析高20位（0x00001），将其作为页表项索引，索引乘以4得到该页表项相对于页表物理地址的字节偏移量，用 cr3 寄存器中的页表物理地址加上此偏移量得到页表项的物理地址，通过页表项地址访问页表项，得到映射到的物理页地址（0x9000），与线性地址低12位（0x234）相加，得到最终物理地址（0x9234）。

完整的地址转换过程如下图所示：

![image-20240806171750825](/home/ZMR/.config/Typora/typora-user-images/image-20240806171750825.png)

---

---

### 二级页表

一级页表的缺点：

1. 内存占用大：一级页表最多可以容纳 1M (1048576) 个页表项，每个页表项 4 字节，如果页表项全满的话，页表大小为 4MB。
2. 提前构建：一级页表的所有页表项必须提前建好，因为操作系统需要占用 4GB 虚拟地址空间的高 1GB，用户进程需要占用低 3GB。
3. 多进程情况下的内存浪费：每个进程都有自己的页表，当进程数量多时，仅页表占用的空间就非常可观。

二级页表的**优点**：

- **动态创建页表项**，减少内存浪费。

- 更好地管理内存分配，提高内存利用效率。

  - 动态创建页表项主要体现在：
  - 只有在需要访问特定虚拟地址时，才会创建相应的页表项。
  - 当访问一个未映射的虚拟地址时，会触发缺页异常（page fault）。操作系统捕获这个异常后，会动态分配一个新的页表项，并将其映射到物理内存。

  

#### 介绍

无论页表级别，标准页的大小都是 4KB。这意味着 4GB 线性地址空间最多包含 1M 个标准页。

- **一级页表**：将这 1M 个标准页放置在一个页表中。
- **二级页表**：将这 1M 个标准页平均分配到 1K 个页表中。每个页表包含 1K 个页表项，每个页表项 4 字节，因此每个页表大小为 4KB。

​	为了管理这些页表，每个页表的物理地址在**页目录表**中都以**页目录项**（Page Directory Entry， PDE）的形式存储，**页目录项大小和页表项一样**，都用来描述一个物理页的物理地址，其大小**都是 4 字节**，而且最多有 1024 个页表，所以页目录表也是 4KB 大小，同样也是标准页的大小。

**页目录表和页表所占用的物理页也混迹于物理内存中**，如图所示。

![image-20240807204155214](/home/ZMR/.config/Typora/typora-user-images/image-20240807204155214.png)

>页目录表中共 1024 个页表，也就是有 1024 个页目录项。每个页目录项中是一个页表物理页地址，物理页地址是指页的物理地址。
>
>每个页表中有 1024 个页表项，每个页表项中是一个物理页地址，最终数据写在这页表项中指定的物理页中。页表项中分配的物理页地址在真正物理内存中离散分布。
>
>页大小都是 0x1000，即 4096字节，因此页地址是以 000 为结尾的十六进制数字。

---

#### ★★★ 地址转换过程

一级页表将 32 位虚拟地址拆分成高 20 位用于定位一个物理页，低 12 位用于页内偏移量。

二级页表中，32 位虚拟地址被拆分为三部分：

1. 高 10 位（第 31～22 位）：在页目录表中定位一个页目录项（PDE），PDE 中有页表物理地址。
2. 中间 10 位（第 21～12 位）：在页表中定位一个页表项（PTE），PTE 中有分配的物理页地址。
3. 低 12 位（第 11～0 位）：页内偏移量。

地址转换步骤如下：

1. **定位页目录项：**
   - **用虚拟地址的高 10 位乘以 4，作为页目录表内的偏移地址，加上页目录表的物理地址，得到页目录项的物理地址。读取该页目录项，获取页表的物理地址。**
2. **定位页表项：**
   - **用虚拟地址的中间 10 位乘以 4，作为页表内的偏移地址，加上在第一步中得到的页表物理地址，得到页表项的物理地址。读取该页表项，获取分配的物理页地址。**
3. **定位最终物理地址：**
   - **用虚拟地址的低 12 位加上第二步中得到的物理页地址，得到最终的物理地址。**



示例如下：

平坦模型下段基址为 0，指令 mov ax，[0x1234567]，经过段部件处理，输出的线性地址为 0x1234567，
由于是在分页机制下，此地址被认为是虚拟地址，需要被页部件转换。首先进行地址拆分：

- 高 10 位：0000000100（二进制）= 0x4（十六进制）
- 中间 10 位：1000110100（二进制）= 0x234（十六进制）
- 低 12 位：010101100111（二进制）= 0x567（十六进制）

转换步骤：

1. 页目录项地址：0x4 * 4 + 页目录表地址（通过查寻cr3寄存器得到） = 0x10+ 页目录表地址

   拿着页目录项地址来定位页面录项在页目录表中的位置。按偏移地址+0x10得到页目录项中存的地址为0x1000。

   意味着要找物理地址为0x1000的页表。
2. 页表项地址：0x234 * 4 + 页表地址 = 0x8d0 + 0x1000 = 0x18d0

   拿着页表项地址来定位页表项在页表中的位置。得到页表项中的地址为0xfa00。

   意味着要找物理地址为0xfa000的物理页。
3. 最终物理地址： 0x567 + 物理页地址 = 0x567 + 0xfa000 = 0xfa567。

> 0x4 * 4相当于二进制里的左移2位。因为2的2次方是4。如果乘以8,则左移3位。

![image-20240807214311143](/home/ZMR/.config/Typora/typora-user-images/image-20240807214311143.png)

---



#### 页表项结构

![image-20240808100039920](/home/ZMR/.config/Typora/typora-user-images/image-20240808100039920.png)

页目录项和页表项都是 4 字节大小，但其内容并不全是物理地址，只有第 12～31 位才是物理地址，高 20 位。低 12 位用于存储其他属性，如存在位（P）、读写位（RW）、用户/超级用户位（US）等。

> 为什么20位就够了？
>
> 因为页目录项和页表项中的都是物理页地址，标准页大小是 4KB，故地址都是 4K 的倍数，也就是地址的低 12位是 0，所以只需要记录物理地址高 20 位就可以啦。

---

#### cr3寄存器

![image-20240808100529994](/home/ZMR/.config/Typora/typora-user-images/image-20240808100529994.png)

页表同描述符表一样，是个内存中的数据结构，处理器要使用它们，必须要知道它们的物理地址，所以页表也有个专门的寄存器来存储其地址。**控制寄存器 cr3 用于存储页表物理地址**，所以 cr3 寄存器又称为页目录基址寄存器（Page Directory Base Register，PDBR）

---

#### 启用分页机制的步骤

1. **准备页目录表和页表**。
2. **将页表地址写入控制寄存器 cr3**。
3. **设置 cr0 的 PG 位为 1**。

> 在将 PG 位置 1 之前，**系统都是在内存分段机制下工作**，**段部件输出的线性地址便直接是物理地址**，也就意味着在第 2 步中，cr3 寄存器中的页表地址是真实的物理地址。
>
> cro的第PE位置1是进入保护模式的其中一步。

---

---

### 操作系统与用户进程的关系

1. 用户的代码加上所需要的操作系统中的部分代码才算完整的程序。而用户进程能用哪些功能，是由操作系统决定的。
2. 进程可以有无限多个，而操作系统只有一个，所以，操作系统必须“**共享**”给所有用户进程。
   - 在页表中实现共享，只要操作系统属于用户进程的虚拟地址空间。
   - 即把 4GB 虚拟地址空间分成两部分，3～4GB专门划给操作系统，0～3GB用户进程使用

---

---

### 启用分页机制

#### ▶ 代码（启用分页、创建页目录及页表）

boot.inc

```assembly
;------------loader 和 kernel--------
...
 PAGE_DIR_TABLE_POS equ 0x100000
...
;---------------- 页表相关属性 --------------
PG_P equ 1b
PG_RW_R equ 00b
PG_RW_W equ 10b
PG_US_S equ 000b
PG_US_U equ 100b
```



loader.S

```assembly
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
   
;-----------------   保护模式前的准备过程   -------------------
...
;-----------------   准备进入保护模式   ----------------------
...

[bits 32]
p_mode_start:
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax

;----------------------------   分页模式准备及进入分页模式   -------------------------------

    call setup_page                                     ;先调用创建页目录表的函数,我们的页目录表必须放在1M开始的位置，所以必须在开启保护模式后运行（且分页模式是在创建好页目录及页表后才开启）

                                                        ;以下两句是将gdt描述符中视频段描述符中的段基址+0xc0000000
    mov ebx, [gdt_ptr + 2]                              ;ebx中存着GDT_BASE
    or dword [ebx + 0x18 + 4], 0xc0000000               ;视频段是第3个段描述符,每个描述符是8字节,故0x18 = 24，然后+4，是取出了视频段段描述符的高4字节。然后or操作，段基址最高位+c
                
    add dword [gdt_ptr + 2], 0xc0000000                 ;将gdt的基址加上0xc0000000使其成为内核所在的高地址

    add esp, 0xc0000000                                 ; 将栈指针同样映射到内核地址

    mov eax, PAGE_DIR_TABLE_POS                         ; 把页目录地址赋给cr3
    mov cr3, eax
                         
    mov eax, cr0                                        ; 打开cr0的pg位(第31位)
    or eax, 0x80000000  
    mov cr0, eax
                   
    lgdt [gdt_ptr]                                      ;在开启分页后,用gdt新的地址重新加载

    mov byte [gs:160], 'V'                              ;视频段段基址已经被更新,用字符v表示virtual addr

    jmp $


 ;--------------------------------   创建页目录及页表  ----------------------------------     
 
setup_page:                                            
                                                        ;--------以下6行是将1M开始的4KB置为0，将页目录表初始化(循环清空页目录表所占的内存)
    mov ecx, 4096                                       ;创建4096个byte 0，循环4096次
    mov esi, 0                                          ;用esi来作为偏移量寻址
.clear_page_dir:
    mov byte [PAGE_DIR_TABLE_POS + esi], 0
    inc esi
    loop .clear_page_dir                                ;每循环一次ecx会被loop减一，当ecx为0时，退出循环



                                                        ;----- ★★★初始化页目录表，让0号项与768号指向同一个页表，该页表管理从0开始4M的空间-----
.create_pde:				                            ;一个页目录表项可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，这是为将地址映射为内核地址做准备
    mov eax, PAGE_DIR_TABLE_POS                         ; eax中存着页目录表的位置
    add eax, 0x1000 			                        ; 在页目录表位置的基础上+4K（页目录表的大小），现在eax中第一个页表的起始位置
    mov ebx, eax				                        ; 此处为ebx赋值，现在ebx存着第一个页表的起始位置
    or eax, PG_US_U | PG_RW_W | PG_P	                ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.
                                                        ; 现在eax中的值符合一个页目录项的要求了，高20位是一个指向第一个页表的4K整数倍地址，低12位是相关属性设置
    mov [PAGE_DIR_TABLE_POS + 0x0], eax                 ; 页目录表0号项写入第一个页表的位置(0x101000)及属性(7)
    mov [PAGE_DIR_TABLE_POS + 0xc00], eax               ; 页目录表768号项写入第一个页表的位置(0x101000)及属性(7)
					                                    
					                                    
					                                    
    sub eax, 0x1000                                     ;-----★★★使最后一个目录项1023号指向页目录表自己的地址，为的是将来动态操作页表做准备-----
    mov [PAGE_DIR_TABLE_POS + 4092], eax	            ;属性包含PG_US_U是为了将来init进程（运行在用户空间）访问这个页目录表项
                                                        
                                                        
                                                        
    mov ecx, 256				                        ;-----★★初始化第一个页表，因为我们的操作系统不会超过1M，所以只用初始化256项，每个页表项映射4KB物理内存，总共映射前1MB的物理内存空间。（每项4KB，256项即1MB，而一个页表有1024个项，剩下的768项暂时不用管）-----
    mov esi, 0                                          ; esi来做寻址页表项的偏移量
    mov edx, PG_US_U | PG_RW_W | PG_P	                ; 属性为7,US=1,RW=1,P=1
.create_pte:				                            ; 创建Page Table Entry
    mov [ebx+esi*4],edx			                        ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 
    add edx,4096                                        ; edx指向下一个4kb空间，且已经设定好了属性，故edx中是一个完整指向下一个4kb物理空间的页表表项
    inc esi                                             ; 寻址页表项的偏移量+1
    loop .create_pte                                    ;循环设定第一个页表的256项



                                                        ;-----★★初始化页目录表769号-1022号项，769号项指向第二个页表的地址（此页表紧挨着上面的第一个页表），770号指向第三个，以此类推-----
    mov eax, PAGE_DIR_TABLE_POS                         ; eax存页目录表的起始位置
    add eax, 0x2000 		                            ; 此时eax为第二个页表的位置
    or eax, PG_US_U | PG_RW_W | PG_P                    ; 设置页目录表项相关属性，US,RW和P位都为1，现在eax中的值是一个完整的指向第二个页表的页目录表项
    mov ebx, PAGE_DIR_TABLE_POS                         ; ebx现在存着页目录表的起始位置
    mov ecx, 254			                            ; 要设置254个表项
    mov esi, 769                                        ; 要设置的页目录表项的偏移起始
.create_kernel_pde:
    mov [ebx+esi*4], eax                                ; 设置页目录表项
    inc esi                                             ; 增加要设置的页目录表项的偏移
    add eax, 0x1000                                     ; eax指向下一个页表的位置，由于之前设定了属性，所以eax是一个完整的指向下一个页表的页目录表项
    loop .create_kernel_pde                             ; 循环设定254个页目录表项
    ret
 
```

- 代码思路步骤

  A、先在boot.inc中定义页目录表的起始位置（放在内存1MB开始的位置），与定义模块化的页目录项与页表项字段；在上一版所写的loader.S中加入我们的创建页表函数。

  B、在页目录表的位置初始化0。

  C、页目录表0号项与768号项均指向第一个页表——0号项指向第一个页表（loader这个程序会运行在0-4M空间内，且跨越了段机制与页机制，顺序映射（第一个页表映射0开始4MB，第二个页表映射紧挨着下一个4MB空间）可以保证之前段机制下的线性地址和分页后的虚拟地址对应的物理地址一致，在这4M空间内，分段下的线性地址=分页后的虚拟地址=物理地址），768号项指向第一个页表是为了让分页机制下3GB开始的4MB虚拟地址空间（虚拟地址0-3G空间用户用，3-4G空间操作系统用）对应到了0-4M实际物理空间，因为这里放着我们的操作系统。这是为了所有进程共享操作系统做准备。页目录表最后一项1023号项指向自己——为的是将来动态操作页表做准备。

  D、初始化第一个页表（非页目录表）——因为这个页表管理着0—4M的物理地址空间，我们的操作系统就在这个空间内。

  E、初始化页目录表769号-1022号项，769号项指向第二个页表（此页表紧挨着上面的第一个页表），770号指向第三个，以此类推，——为将来用户进程做准备，使所有用户进程共享内核空间（从768号项—1022号项的页目录表项会被拷贝到所有用户进程的页目录表项中）。

![image-20240812200702369](/home/ZMR/.config/Typora/typora-user-images/image-20240812200702369.png)

- mbr.S文件打印了：左上角第一行的“1 MBR”
- loader.S文件打印了：当启用分页机制后，打印 “ v ”



> 为什么只初始化了映射到物理地址低端4MB的0号和768号页目录项、769～1022号页目录项、指向页目录表自己地址的1023号目录项，剩下的1～767号为什么不用初始化？
>
> 答：
>
> 1. 初始化页目录表的0号项和768号项是为了**映射低4MB的物理内存到虚拟地址空间的低4MB和高4MB区域**。这种映射允许内核使用虚拟地址访问这些物理地址，并确保操作系统的启动和基本功能。
>
> 2. 769～1022号项的初始化是为了**给内核预留更多的虚拟内存空间**，**用于映射更多的物理内存或设备寄存器**。（这部分属于**虚拟地址空间中3～4GB的内核空间**）
> 3. 1023号指向页目录表自己的地址，**为将来动态操作页表做准备**。
> 4. 1～767号项未初始化是因为这些项主**要用于用户空间的虚拟地址**，操作系统可以**在运行时动态管理这些地址的映射**，避免不必要的资源浪费。

---

---

### ★★ 用虚拟地址访问页表

​	进入分页机制后，所有对内存的访问都是将虚拟地址通过页表进行地址转换后，得到的物理地址。**但页表本身也存在于内存中，且页表是一种动态的数据结构，需要动态增减，那么修改页表就需要得到页表的内存地址，所以我们就需要“用虚拟地址访问页表”**。

---

#### 页目录表映射到虚拟地址空间

为了能够通过虚拟地址访问页表，我们**在页目录表的最后一个页目录项中填入了页目录表的物理地址**。**这样做的目的是让虚拟地址高 10 位为 0x3FF 时指向页目录表本身，使得页目录表可以作为页表使用**。这个过程如下：

1. 高 10 位为 0x3FF：
   - 虚拟地址的高 10 位为 0x3FF（即 1111111111b），则访问的是页目录表的最后一个目录项。这个目录项中存储的是页目录表的物理地址。
2. 中间 10 位：
   - 虚拟地址的中间 10 位用于在页目录表中定位一个页表项。如果中间 10 位为 0x0，则定位到页目录表的第一个页目录项。这个项中记录的是页表的物理地址。
3. 低 12 位：
   - 虚拟地址的低 12 位用于页内偏移量。它直接加在物理页地址上，形成最终的物理地址。

---

#### 地址映射实例

`info tab 命令看到页表中虚拟地址到物理地址的映射关系`

![image-20240808150530676](/home/ZMR/.config/Typora/typora-user-images/image-20240808150530676.png)

左边列出的是 32 位虚拟地址范围，右边是虚拟地址对应的物理地址

1. 第一行，虚拟地址 0x00000000～0x000fffff，这是虚拟空间低端 1M 内存，其对应的物理地址是0x000000000000～0x0000000fffff。这是咱们的**第 0 个页表起的作用**。

2. 第二行，虚拟地址 0xc0000000～0xc00fffff，这是咱们**第 768 个页表起的作用**。由于**第 0 个页目录项和 第 768 个 页 目 录 项 指 向 的 是 同 一 个 页 表** ， 所 以 其 映 射 的 物 理 地 址 依 然 是 0x000000000000 ～0x0000000fffff。

> 问：
>
> 为什么第0个页目录项所指向的页表，其表示的物理地址空间为**0～0x3fffff**（低端4MB，包括了低端1MB，即0～0xfffff）？
>
> 答：
>
> 在实模式或保护模式下，**系统在低端1MB的物理内存中运行loader**（启动加载器）。这个内存区域包括了BIOS、中断向量表、操作系统引导代码等重要数据。
>
> 在**操作系统从实模式（或者是没有启用分页的保护模式）切换到分页机制的保护模式**时，需要保证以下两点：
>
> - **一致性**：段机制下的线性地址和分页机制下的虚拟地址需要映射到同一个物理地址，这样可以确保在切换分页机制时，正在运行的代码和数据不会出错。尤其是loader运行在1MB物理地址之内，在启用分页后，虚拟地址需要正确映射到原来的物理地址。
> - **平滑过渡**：在启用分页前，系统是通过段机制访问内存的，线性地址就是物理地址。在启用分页后，虚拟地址需要映射到相应的物理地址，这样在切换分页机制时，代码和数据访问不会发生变化，确保系统运行的连续性和稳定性。

> 问：
>
> 为什么第768个页目录项所指向的页表，其表示的物理地址空间也是0～0x3fffff
>
> 答：
>
> 由于操作系统内核放在低端1MB物理内存空间，但开启分页机制后，每个进程都有4GB的虚拟内存空间，而3GB以上（也就是虚拟地址0xc0000000以上）的空间属于操作系统。刚好0xc0000000以上的第1MB地址是属于第768个页目录项，因此将第768个页目录项对应的4MB映射到物理地址的低端4MB中。

3. 第三到五行：

第一个奇怪的虚拟地址映射

- **虚拟地址范围**：0xFFC00000 - 0xFFC00FFF
- **物理地址范围**：0x000000101000 - 0x000000101FFF

解释：

- 高 10 位为 0x3FF，即最后一个页目录项，其物理地址是页目录表的地址。
- 中间 10 位为 0x0，定位到页目录表的第一个页目录项，记录的是第一个页表的物理地址（0x101000）。
- 低 12 位为页内偏移量，范围 0x000 - 0xFFF。

因此，虚拟地址 0xFFC00000 - 0xFFC00FFF 映射到物理地址 0x000000101000 - 0x000000101FFF。

即该地址范围表示的是第一个页表，0x000000101000为第一个页表的第一个页表项的地址，0x000000101FFF为第一个页表的最后一个页表项的地址。

第二个奇怪的虚拟地址映射

- **虚拟地址范围**：0xFFF00000 - 0xFFF00FFF
- **物理地址范围**：0x000000101000 - 0x000000101FFF

解释：

- 高 10 位为 0x3FF，中间 10 位为 0x300，定位到第 768 个页目录项，该项指向第一个页表。
- 低 12 位为页内偏移量。

因此，虚拟地址 0xFFF00000 - 0xFFF00FFF 映射到物理地址 0x000000101000 - 0x000000101FFF。

第三个奇怪的虚拟地址映射

- **虚拟地址范围**：0xFFFFF000 - 0xFFFFFFFF
- **物理地址范围**：0x000000100000 - 0x000000100FFF

解释：

- 高 10 位为 0x3FF，中间 10 位为 0x3FF，定位到页目录表的最后一个页目录项。
- 低 12 位为页内偏移量。

因此，虚拟地址 0xFFFFF000 - 0xFFFFFFFF 映射到物理地址 0x000000100000 - 0x000000100FFF。

即该地址范围表示的是最后一个页表的地址范围

---

#### 通过虚拟地址访问页表和页目录表的方法

1. **获取页目录表物理地址**：
   - 虚拟地址高 20 位为 0xFFFFF，低 12 位为 0x000，即虚拟地址为 0xFFFFF000，这也是页目录表中第 0 个页目录项自身的物理地址。
2. **访问页目录中的页目录项，即获取页表物理地址**：
   - 虚拟地址高 20 位为 0xFFFFF，低 12 位为页目录项的索引乘以 4（如 0xFFFFF000 + 索引 * 4），即虚拟地址为0xfffffxxx。
3. **访问页表中的页表项**：
   - 虚拟地址高 10 位为 0x3FF（为了获取页目录表物理地址），中间 10 位为页表的索引，低 12 位为页表项的偏移地址（如 0xFFC00000 + 索引 * 4）。

---

---

### 快表TLB

由于每次虚拟地址到物理地址的转换都很复杂，处理器和内存之间频繁交互，导致效率低下。

**TLB（Translation Lookaside Buffer）**：

- 为提高地址转换速度，处理器引入了 TLB 缓存。

- TLB 存放了虚拟地址页框与物理地址页框的映射关系。

- 处理器在寻址时，先查找 TLB，如果命中，直接获取物理地址；若未命中，再查询内存中的页表并更新 TLB。

  ![image-20240808204453420](/home/ZMR/.config/Typora/typora-user-images/image-20240808204453420.png)

**TLB 的维护**：

- TLB 数据只存放部分页表项，且只有 P 位为 1 的页表项才会被存入 TLB。
- TLB 需要保持与内存中页表同步，当页表发生修改时，开发人员需手动更新 TLB。

**更新 TLB 的方法**：

- **重新加载 CR3**：使整个 TLB 失效。
- **invlpg 指令**：针对某个虚拟地址对应的条目进行更新，确保地址有效性。

---

---

## 加载内核

### ★★★ 简单的内核程序（编译与链接过程）

- **c代码  ->（编译成）汇编代码  ->（汇编成）二进制目标文件  ->（链接成）二进制可执行文件**

- 示例代码：`main.c`
  
  ```c
  int main(void) {
      while(1);
      return 0;
  }
  ```
  - 该程序通过死循环保持 CPU 停止在此位置，以便演示 ELF 文件解析及加载内核。
  
  

#### 编译和链接步骤

1. **编译 C 语言代码为目标文件（gcc命令）**

   ```bash
   gcc -c -o kernel/main.o kernel/main.c
   ```
   - `-c`: 仅编译生成目标文件，不进行链接。
   - `-o`: 指定输出文件名为`kernel/main.o`。

   - 该步骤得到main.o的目标文件，也就是待**重定位文件**，此时文件里中所调用的函数及变量还**未安排地址**。编址一定是在链接阶段完成的。

   ![image-20240812113319675](/home/ZMR/.config/Typora/typora-user-images/image-20240812113319675.png)

   - 图中可得`main`函数的地址未被指定，故地址显示为全零; 查看`main.o`文件的属性，发现是relocatable，即未定位的。

2. **链接目标文件为可执行内核文件（ld命令）**

   ```bash
   ld kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin
   ```
   - `-Ttext 0xc0001500`: 指定起始虚拟地址为 0xc0001500。
   - `-e main`: 指定程序的入口地址为 `main` 函数。
   - `-o kernel/kernel.bin`: 输出链接后的可执行文件。

3. **查看目标文件和可执行文件属性（file命令）**

   - 使用 `file kernel/main.o` 查看目标文件状态（例如“可重定位”属性）。
   - 使用 `file kernel/kernel.bin` 查看最终生成的内核文件状态（应为可执行文件）。
   - ![image-20240812113815410](/home/ZMR/.config/Typora/typora-user-images/image-20240812113815410.png)

4. **查看符号地址（nm命令）**

   - 通过 `nm kernel/main.o` 检查目标文件中的符号是否已确定地址（编译后通常未确定地址）。
   - 链接后再次检查符号地址，确保已正确定位。
   - ![image-20240812114032526](/home/ZMR/.config/Typora/typora-user-images/image-20240812114032526.png)

5. **tree一下**

​		![image-20240812114633932](/home/ZMR/.config/Typora/typora-user-images/image-20240812114633932.png)

---

#### 链接器与程序入口

- **程序入口符号 `_start`**
  - 默认情况下，链接器使用 `_start` 作为程序入口符号。
  - 若不指定入口符号，则会引发警告。
  - 可通过 `-e` 参数指定入口符号，例如使用 `main` 作为入口

![image-20240812114933778](/home/ZMR/.config/Typora/typora-user-images/image-20240812114933778.png)![image-20240812115307563](/home/ZMR/.config/Typora/typora-user-images/image-20240812115307563.png)

- 直接gcc进行编译链接，不加-c参数，查看生成的二进制可执行文text，由于默认情况，所以用_start作为程序入口地址。
- 而像上面一样一步步地编译、链接，并指定main为入口地址，则不会出现_main，且代码量会少很多。

---

---

### elf格式的二进制文件

#### **文件头与程序体**

![image-20240812120510375](/home/ZMR/.config/Typora/typora-user-images/image-20240812120510375.png)

- **文件头的作用**：
  - 记录程序的入口地址、程序尺寸大小等信息，便于主调程序加载。
  - 文件头中的信息属于元数据，不应被 CPU 执行。

- **文件格式**：
  - 程序文件由文件头和文件体组成，文件头记录元数据，文件体包含程序的指令和数据。
  - 例子：火车站的列车时刻表（相当于文件头）与实际的火车（相当于文件体）。

#### **自定义程序文件头的实现**

- **示例代码**：
  - 汇编程序 `header.S` 用于演示自定义程序文件头：
    ```asm
    header:
    program_length  dd  program_end-program_start
    start_addr      dd  program_start
    
    body:
    program_start:
        mov ax, 0x1234
        jmp $
    program_end:
    ```

- **编译命令**：
  - 使用 `nasm` 编译生成二进制文件 `header.bin`：
    ```bash
    nasm -o header.bin header.S
    ```

- 查看header.bin
  
  ![image-20240812120824585](/home/ZMR/.config/Typora/typora-user-images/image-20240812120824585.png)
  
  - `05000000`: 程序长度（5 字节，小端字节序）。
  - `08000000`: 程序入口地址（第 8 字节，小端字节序）。
  - `B83412EB FE`: 程序指令 `mov ax, 0x1234` 和 `jmp $`。

---

#### **ELF文件**
**ELF文件是Linux下可执行文件的标准格式，与Windows的PE（Portable Executable）格式相对应**。(EXE是扩展名，属于文件名的一部分，只是名字的后缀，不是真正的格式)

**文件类型**

- ELF文件的类型包括：
  - **待重定位文件（Relocatable File）**：如Linux下的.o文件，编译后但未完成链接，用于与其他目标文件合并。
  - **共享目标文件（Shared Object File）**：即动态链接库，程序运行时动态加载。
  - **可执行文件（Executable File）**：编译链接后的可执行程序。
  
  

**文件结构**

![image-20240812121428997](/home/ZMR/.config/Typora/typora-user-images/image-20240812121428997.png)

- ELF文件具有层次化的结构，主要由段（Segment）和节（Section）组成：
  - **段（Segment）**：程序的基本单位，如代码段、数据段。
  - **节（Section）**：段的组成部分，多个节通过链接形成段。
- 主要结构包括：
  - **ELF Header**：位于文件开头，描述整个文件的结构，包括程序头表和节头表的位置及大小。
  - **Program Header Table（程序头表）**：描述程序的段信息。
  - **Section Header Table（节头表）**：描述程序的节信息。
  
  

 **ELF Header**

- ELF Header是ELF文件的全局描述，包含以下字段：
  - **e_ident**：标识信息，包括魔数（0x7f、'E'、'L'、'F'）以及文件的位数、字节序等。
  - **e_type**：文件类型，如可执行文件、重定位文件等。
  - **e_machine**：文件适用的体系结构类型，如Intel 80386、SPARC等。
  - **e_entry**：程序的入口点，即操作系统将控制权转交的地址。
  - **e_phoff**和**e_shoff**：程序头表和节头表在文件中的偏移量。
  - **e_phentsize**和**e_shentsize**：程序头表和节头表中每个条目的大小。
  - **e_phnum**和**e_shnum**：程序头表和节头表中的条目数量。
  
  

**Program Header（程序头）**

- Program Header用于描述段的信息，包括：
  - **p_type**：段的类型，如可加载段、动态链接信息等。
  - **p_offset**：段在文件中的偏移量。
  - **p_vaddr**：段在内存中的虚拟地址。
  - **p_filesz**和**p_memsz**：段在文件和内存中的大小。
  - **p_flags**：段的权限标志，如可读、可写、可执行。



**使用xxd.sh脚本逐字节查看**

xxd.sh

```sh
# usage: sh xxd.sh 文件 起始地址 长度
xxd -u -a -g 1 -s $2 -l $3 $1
```

查看main.c生成的可执行文件![image-20240812114633932](/home/ZMR/.config/Typora/typora-user-images/image-20240812114633932.png)

![image-20240812160522642](/home/ZMR/.config/Typora/typora-user-images/image-20240812160522642.png)

举例：第一行是 e_ident 数组，前 4 字节是固定的 elf 魔数，正如您看到的，它们是 0x7f 和字符 ELF 的 ASCII：0x45、0x4c、0x46。所以您**在显示区看到了 ELF 的三个字符**。紧跟其后的三个 1 分别是 e_ident[4]、e_ident[5]、e_ident[6]三个成员，代表的意义是 32 位 elf 文件、小端字节序、当前版本。后面的 9 个 00 是 e_ident[7]～e_ident[15]，这些确实都已经初始化为 0。

---

### ★★★ 将内核载入内存

#### ▶ 代码（从磁盘加载内核文件，根据elf创建内核映像，执行内核代码）



★★★ 功能：**loader.S从磁盘中加载编译好的kernel.bin二进制文件（elf格式），按照elf文件头的信息创建内核映像，然后执行内核代码。**

- kernel.bin文件来自于main.c经过gcc -o编译、ld链接后生成的可执行文件。（kernel.bin表示的是内核的二进制elf文件，虽说是可执行文件，但有文件头，不能直接运行，这就需要loader对该elf文件进行解析了）

![image-20240814093052035](/home/ZMR/.config/Typora/typora-user-images/image-20240814093052035.png)

- 因为内核被加载到内存后，loader需要根据elf结构将其展开到新的位置，所以内核在低端1M的内存中有两份，一份为解析前elf格式的kernel.bin源文件，一份为解析后在内存中生成的内核映像（这个映像为真正运行的内核，且有了内核映像后，解析前的源文件就没用了）。因此在框框的较高地址`0x70000`放刚加载进来的源文件，较低地址`0x1500`放解析后的内核映像，这样在后续内核往高地址拓展中也能正常地把位于它上面的源文件给覆盖了。（MBR在加载loader后就没用了，因此框框中间的512B此时也是可用的）

  ![image-20240814110352403](/home/ZMR/.config/Typora/typora-user-images/image-20240814110352403.png)![image-20240814114537075](/home/ZMR/.config/Typora/typora-user-images/image-20240814114537075.png)

★★★ 实现原理：先把kernel.bin从磁盘复制到内存指定位置，由于这个二进制文件kernel.bin是被编译好了的，是按照elf文件布局分布的，**加载到内存中不能直接运行（有文件头）**。我们要**根据elf文件头的信息，将kernel.bin文件中的各种段复制到内存中**。(通过elf header得到program header table信息，然后根据program header table信息找到program header信息，该结构描述了各个段的起始偏移，大小，目的虚拟地址，根据这些信息将各个段复制到内存的指定位置。这个位置是由我们指定的内核可执行代码入口地址0xc0001500后编译器根据实际代码情况自己指定的)。***即，将一开始加载到内存的kernel.bin文件再在内存中进行信息的移动，把解析后的内核映像放到相应的虚拟内存地址***，**最后跳过去执行内核代码**，此时loader.S 的任务就完成了。

> 为什么内核的入口虚拟地址是0xc0001500
>
> 答：因为在内存中选择 0x1500 作为内核映像的入口地址，页表中低端 1MB 的虚拟内存与物理内存是一一对应的，所以物理地址是 0x1500，对应的虚拟地址是 0xc0001500（这是4GB虚拟地址空间中3GB以上的地方）



main.c

一个简单到不能再简单的内核。

```c
int main(void){
    while(1);
    return 0;
} 
```



boot.inc

```assembly
...
LOADER_STACK_TOP equ LOADER_BASE_ADDR               ;这一条之前是在loader.S中定义，现在搬过来了
...
KERNEL_BIN_BASE_ADDR equ 0x70000                    ;★★定义内核在内存中的缓冲区，也就是将编译好的内核文件暂时存储在内存中的位置
KERNEL_START_SECTOR equ 0x9                         ;定义内核在磁盘的起始扇区
KERNEL_ENTRY_POINT equ 0xc0001500                   ;★★定义内核可执行代码的入口地址
...
```



loader.S

```assembly
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
    ; jmp loader_start					                ;loader一进来是下面一大堆GDT段描述符数据，无法执行，所以要跳过
                                                        ;虽然代码在执行时跳过了定义部分，但定义部分的数据已经被加载到内存中，并可以通过相关的指令来访问和使用
   
;-----------------   保护模式前的准备过程   -------------------
...
;-----------------   准备进入保护模式   ----------------------
...

; ----------------------------------   ★★★从磁盘加载kernel.bin到内存中  ---------------------------------------
    mov eax, KERNEL_START_SECTOR                        ; kernel.bin所在的扇区号
    mov ebx, KERNEL_BIN_BASE_ADDR                       ; 从磁盘读出后，写入到ebx指定的地址
    mov ecx, 200			                            ; 读入的扇区数
    call rd_disk_m_32									; 调用“读取硬盘n个扇区”函数


;--------------------   启用分页机制  ----------------------
 	call setup_page										; 调用“创建页目录及页表”函数
...


; --------------------------  解析kernel.bin的elf文件头，创建内核映像，跳入内核代码执行  ----------------------------------
enter_kernel:
    call kernel_init									; ★★★调用“解析kernel.bin的elf文件头，创建内核映像”函数
    mov esp, 0xc009f000
    jmp KERNEL_ENTRY_POINT                              ; ★★★使CPU跳转到内核的入口地址0xc0001500，开始执行内核代码

                           
;-------------   解析kernel.bin的elf文件头，创建内核映像（将kernel.bin中的各种段拷贝到编译的地址）   -----------
kernel_init:
    xor eax, eax                                        ;清空eax
    xor ebx, ebx		                                ;清空ebx, ebx记录程序头表地址
    xor ecx, ecx		                                ;清空ecx, cx记录程序头表中的program header数量
    xor edx, edx		                                ;清空edx, dx 记录program header尺寸

    mov dx, [KERNEL_BIN_BASE_ADDR + 42]	                ; 偏移文件42字节处的属性是e_phentsize,表示program header table中每个program header大小
    mov ebx, [KERNEL_BIN_BASE_ADDR + 28]                ; 偏移文件开始部分28字节的地方是e_phoff,表示program header table的偏移，ebx中是第1 个program header在文件中的偏移量
					                                    ; 其实该值是0x34,不过还是谨慎一点，这里来读取实际值
    add ebx, KERNEL_BIN_BASE_ADDR                       ; 现在ebx中存着第一个program header的内存地址
    mov cx, [KERNEL_BIN_BASE_ADDR + 44]                 ; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header
.each_segment:
    cmp byte [ebx + 0], PT_NULL		                    ; 若p_type等于 PT_NULL,说明此program header未使用。
    je .PTNULL

                                                        ;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)
    push dword [ebx + 16]		                        ; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size
    mov eax, [ebx + 4]			                        ; 距程序头偏移量为4字节的位置是p_offset，该值是本program header 所表示的段相对于文件的偏移
    add eax, KERNEL_BIN_BASE_ADDR	                    ; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址
    push eax				                            ; 压入函数memcpy的第二个参数:源地址
    push dword [ebx + 8]			                    ; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址
    call mem_cpy				                        ; ★★★调用mem_cpy完成段的复制
    add esp,12				                            ; 清理栈中压入的三个参数
.PTNULL:
   add ebx, edx				                            ; edx为program header大小,即e_phentsize,在此ebx指向下一个program header 
   loop .each_segment
   ret

                                                        ;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------
                                                        ;功能：将段内容复制到指定位置
                                                        ;输入:栈中三个参数(dst,src,size)
                                                        ;输出:无
                                                        ;---------------------------------------------------------
mem_cpy:		      
    cld                                                 ;将FLAG的方向标志位DF清零，rep在执行循环时候si，di就会加1
    push ebp                                            ;这两句指令是在进行栈框架构建
    mov ebp, esp
    push ecx		                                    ; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份
    mov edi, [ebp + 8]	                                ; dst，edi与esi作为偏移，没有指定段寄存器的话，默认是ss寄存器进行配合
    mov esi, [ebp + 12]	                                ; src
    mov ecx, [ebp + 16]	                                ; size
    rep movsb		                                    ; 逐字节拷贝

                                                        ;恢复环境
    pop ecx		
    pop ebp
    ret
       
       
;-----------   创建页目录及页表  --------------
setup_page:
...
 
                                                        
;-------------------------------  读取硬盘n个扇区  ----------------------------------------
rd_disk_m_32:	                                             
				                                        ; eax=LBA扇区号
				                                        ; ebx=将数据写入的内存地址
				                                        ; ecx=读入的扇区数
    mov esi,eax	                                        ;备份eax
    mov di,cx		                                    ;备份cx
                                                        ;读写硬盘:
                                                        ;第1步：选择特定通道的寄存器，设置要读取的扇区数
    mov dx,0x1f2
    mov al,cl
    out dx,al                                           ;读取的扇区数

    mov eax,esi	                                        ;恢复ax

                                                        ;第2步：在特定通道寄存器中放入要读取扇区的地址，将LBA地址存入0x1f3 ~ 0x1f6
                                                        ;LBA地址7~0位写入端口0x1f3
    mov dx,0x1f3                       
    out dx,al                          

                                                        ;LBA地址15~8位写入端口0x1f4
    mov cl,8
    shr eax,cl
    mov dx,0x1f4
    out dx,al

                                                        ;LBA地址23~16位写入端口0x1f5
    shr eax,cl
    mov dx,0x1f5
    out dx,al

    shr eax,cl
    and al,0x0f	                                        ;lba第24~27位
    or al,0xe0	                                        ; 设置7～4位为1110,表示lba模式
    mov dx,0x1f6
    out dx,al

                                                        ;第3步：向0x1f7端口写入读命令，0x20 
    mov dx,0x1f7
    mov al,0x20                        
    out dx,al

                                                        ;第4步：检测硬盘状态
.not_ready:
                                                        ;同一端口，写时表示写入命令字，读时表示读入硬盘状态
    nop
    in al,dx
    and al,0x88	                                        ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙
    cmp al,0x08
    jnz .not_ready	                                    ;若未准备好，继续等。

                                                        ;第5步：从0x1f0端口读数据
    mov ax, di                                          ;di当中存储的是要读取的扇区数
    mov dx, 256                                         ;每个扇区512字节，一次读取两个字节，所以一个扇区就要读取256次，与扇区数相乘，就等得到总读取次数
    mul dx                                              ;8位乘法与16位乘法知识查看书p133,注意：16位乘法会改变dx的值！！！！
    mov cx, ax	                                        ; 得到了要读取的总次数，然后将这个数字放入cx中
    mov dx, 0x1f0
.go_on_read:
    in ax,dx
    mov [ebx],ax                                        ;与rd_disk_m_16相比，就是把这两句的bx改成了ebx
    add ebx,2		        
                                                        ; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。
                                                        ; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，
                                                        ; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，
                                                        ; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，
                                                        ; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,
                                                        ; 故程序出会错,不知道会跑到哪里去。
                                                        ; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。
                                                        ; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.
                                                        ; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,
                                                        ; 也会认为要执行的指令是32位.
                                                        ; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，
                                                        ; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67，
                                                        ; 临时改变当前cpu模式到另外的模式下.
                                                        ; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.
                                                        ; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.
                                                        ; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址
                                                        ; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.
    loop .go_on_read
    ret

```

代码步骤：

A、在boot.inc中定义内核文件加载到内存中的位置：0x70000；定义内核文件在磁盘中的起始盘区：0x9；定义内核可执行代码的入口地址0xc0001500；把栈顶位置的宏定义从loader.S中移到boot.inc中。

B、写一个32位环境下读取磁盘的函数（这个函数我们直接去修改mbr.S中实现的16位读取磁盘的函数），然后传参调用此函数完成从磁盘中加载elf格式的内核文件到内存指定地址。

C、实现拷贝函数，用于将信息在内存中进行移动。

D、在boot.inc中定义program header type字段为空的宏，用此宏来判断program header描述的段是否需要被加载。

E、写一个解析elf文件的函数，该函数的功能：从指定位置的elf header中取出：1、program header table的偏移位置（加上内核文件在内存的起始位置就是物理地址），这为的是找到第一个program header；2、program header table中的program header（对于每个段的描述符）数量；3、program header table每个program header的大小。这三个信息为的是遍历每一个program header，如果该program header描述的段不是空段就从program header取出每个段的：1、段的大小；2、本段的偏移（加上内核文件在内存的起始位置就是物理地址）；3、段在内存中的虚拟地址（编译内核时我们会指定一个程序入口虚拟地址，编译器会根据指定的程序入口虚拟地址，计算出每个段虚拟地址。由于我们指定的虚拟地址就是真实加载的物理地址，所以取出的虚拟地址就是的段目的物理地址）。然后传参调用mem_cpy函数将段内容复制到指定位置。

F、调用E写的函数，完成内核映像的创建。然后跳入内核执行。

---

---

## 特权级（Privilege Level）

保护模式模式下，系统通过特权级来区分不同级别的操作权限，确保系统资源和数据的安全。

特权级将程序和数据分为不同的访问等级。特权级分为4个级别：0、1、2、3，其中**0级最高，3级最低。**

![image-20240813142130683](/home/ZMR/.config/Typora/typora-user-images/image-20240813142130683.png)

- **0级特权**：操作系统内核运行在这个级别，拥有对所有资源的访问权限。
- **1级特权**：通常由系统服务和驱动程序使用，具有一定的硬件访问权限。
- **2级特权**：较少使用，可以作为某些特定服务的运行级别。
- **3级特权**：用户程序运行在这个级别，访问权限受到严格限制。

### 任务状态段（TSS）
TSS（Task State Segment）是处理器**用于任务切换的数据结构**，它保存了任务的寄存器状态和特权级栈信息。TSS中**记录了不同特权级下的栈指针和段选择子**，确保在任务切换时能够正确地保存和恢复任务状态。

![image-20240813142700603](/home/ZMR/.config/Typora/typora-user-images/image-20240813142700603.png)

### CPL、DPL和RPL
- **CPL（Current Privilege Level）**：当前特权级，表示当前正在执行的代码的特权级别。
- **DPL（Descriptor Privilege Level）**：描述符特权级，用于内存段描述符中，定义了访问该段的最低特权要求。
- **RPL（Request Privilege Level）**：请求特权级，通常位于段选择子中，表示请求访问资源的程序的实际特权级。

### 特权级检查过程
当程序尝试访问资源时，处理器会进行特权级检查，确保访问者有足够的权限。检查规则如下：
- 对于代码段，CPL必须等于RPL，且**CPL必须 ≤ 目标代码段的DPL**。
- 对于数据段，**CPL和RPL都必须 ≤ 目标数据段的DPL**。

### IO特权级
IO特权级由eflags寄存器中的IOPL位和TSS中的IO位图共同决定。IOPL位定义了执行IO操作的最小特权级，而IO位图则提供了对特定IO端口的访问控制。

### I/O位图
I/O位图是一个位数组，每个位对应一个IO端口。位值为0表示允许访问该端口，为1则表示禁止访问。I/O位图允许在当前特权级高于IOPL的情况下，对特定端口进行访问控制。

![image-20240814120220728](/home/ZMR/.config/Typora/typora-user-images/image-20240814120220728.png)![image-20240814120259498](/home/ZMR/.config/Typora/typora-user-images/image-20240814120259498.png)

### 调用门和系统调用

用门提升特权级，就像站在高处的台子上往蹦床上跳一样，人会被蹦床弹得比台子还高。门的“门槛”是访问者特权级的下限，访问者的特权级再低也不能比门描述符的特权级 DPL 低，否则访问者连门都进不去，更谈不上使用调用门。

![image-20240814115631538](/home/ZMR/.config/Typora/typora-user-images/image-20240814115631538.png)

调用门是一种特殊的门描述符，用于实现从低特权级到高特权级的转移。

系统调用通常通过调用门来实现，用户程序通过调用门请求操作系统服务，操作系统在高特权级下执行相应的服务程序。

![image-20240814115236693](/home/ZMR/.config/Typora/typora-user-images/image-20240814115236693.png)

### 系统调用的执行流程
1. 用户程序通过调用门请求系统服务。
2. 处理器进行特权级检查，确保请求合法。
3. 如果检查通过，处理器将CPL提升到调用门目标代码段的DPL。
4. 处理器切换到相应的特权级栈，并将用户程序的参数复制到新栈。
5. 处理器加载目标代码段的选择子和偏移量，开始执行系统服务程序。
6. 系统服务程序执行完成后，使用retf指令返回用户程序，处理器进行特权级检查并恢复用户程序的执行环境。

---

---

---

# gap

## 地址映射关系变化

| **模式**                 | **线性地址计算方式**                       |      |      |
| ------------------------ | ------------------------------------------ | ---- | ---- |
| **实模式**               | 线性地址 = 物理地址                        |      |      |
| **保护模式（段机制）**   | 线性地址 = 段基址 + 段内偏移               |      |      |
| **保护模式（分页机制）** | 线性地址通过页目录表和页表映射到物理地址。 |      |      |
|                          |                                            |      |      |

实模式：CPU直接使用物理地址，地址空间为20位，最大可访问1MB内存。

保护模式段机制：段选择子和段描述符一起定义了段基址和段限长。

保护模式分页机制：每个进程有了独立的4GB的虚拟内存空间。

- **高10位**：页目录索引（指向页目录表中的一个表项）
- **中10位**：页表索引（指向页表中的一个表项）
- **低12位**：页内偏移（指向具体的物理地址）

- **线性地址 -> 页目录表 -> 页表 -> 物理地址**：通过页目录表和页表的查找，将线性地址映射到物理地址。

---

## 虚拟地址访问页表、第0和第768页目录项大讨论

![img](file:////home/ZMR/.config/QQ/nt_qq_d3200eb105406117abb0e0f8c3fd8841/nt_data/Pic/2024-08/Ori/5fed318412f246c7eed65f5677d32b54.jpeg)

![img](file:////home/ZMR/.config/QQ/nt_qq_d3200eb105406117abb0e0f8c3fd8841/nt_data/Pic/2024-08/Ori/09c7fe97439ceab6e30d0de074ddefb7.jpeg)

一个页表4KB，有1024个页表项，能索引1024×4KB=4MB的物理地址空间

一个页表项4字节，指向一个4KB的物理内存页

每个进程都有一个页目录表，一个页目录表可以索引4GB的大小



---

---

---

# 第六章 完善内核

## ★★★ 函数调用约定（esp、ebp在调用函数前后的变化）

函数调用约定（Calling Conventions）是指在调用函数时所遵循的一套规则或协议。这些规则规定了如何传递参数、返回值以及如何管理调用过程中使用的栈空间和寄存器。不同的调用约定在处理这些问题时可能会有所不同，尤其是在不同的编程语言、编译器或操作系统之间。

在 C 语言默认的 **`cdecl`（C Declaration）调用约定**中：

1. 参数传递	

   - **参数是从右到左依次压入栈中。**例如，上述代码中，`subtract(3, 2)` 的参数 `b`（即 2）会先被压入栈，然后是参数 `a`（即 3）。

   - 函数返回值通常存储在寄存器 `EAX` 中。

2. 寄存器的保存

   - 调用者需要保存通用寄存器的状态。

   - 寄存器 `EAX`、`ECX` 和 `EDX` 通常由调用者保存，其余的寄存器由被调用者负责保存。


3. 栈空间管理

   - **由调用者负责在函数调用后清理栈空间**。这意味着在函数返回后，调用者必须将栈顶指针调整回函数调用前的状态。

   

c语言代码：

```c
int subtract(int a, int b) {  // 被调用者
    return a - b;
}

int main() {
    int sub = subtract(3, 2); // 主调用者
    return 0;
}
```

![image-20240814172627880](/home/ZMR/.config/Typora/typora-user-images/image-20240814172627880.png)

cdecl 调用约定下产生的汇编代码：

```assembly
; 调用者
push 2            ; 将参数 b 压入栈
push 3            ; 将参数 a 压入栈
call subtract     ; 调用函数 subtract（★★当call一个函数时，cpu会自动把主调函数的返回地址入栈，当ret时将其出栈）
add esp, 8		  ; 回收清理栈空间（★★栈中只剩下a和b，共占用8字节，将栈顶指针esp+8,就相当于把ab给push了）


; 被调用者
subtract:
    push ebp      		; 保存旧的栈帧指针（★因为在调用subtract前，栈中也存在着ebp，作为前某段代码的基址，且ebp不会像esp一样一直指向栈顶）
    mov ebp, esp  		; 建立新的栈帧（★将 esp 赋值给 ebp，用 ebp 作为基址来访问栈中参数）
    
    mov eax, [ebp+8]  	; 将参数 a 载入 eax（偏移 8 字节处为第 1 个参数 a）
    sub eax, [ebp+12] 	; 用 eax 减去参数 b（偏移 12 字节处是第 2 个参数 b）
    
    mov esp,ebp			; 防止中间有入栈操作，用ebp恢复esp（因为在ebp入栈后没有push东西，所以该代码中没啥用）
    
    pop ebp      		; 恢复旧的栈帧指针（★将ebp恢复到调用subtract前的值）
    ret           		; 返回，调用者负责清理栈（★★把函数的返回地址出栈，此时栈中只剩下a和b）
```

在这个过程中，如果采用了不同的调用约定，例如 `stdcall`，那么栈的清理可能会由被调用者负责，而不是调用者。

---

---

## 汇编语言和 C 语言混合编程

​	汇编语言和 C 语言混合编程可分为两大类。
​	（1）单独的汇编代码文件与单独的 C 语言文件分别编译成目标文件后，一起链接成可执行程序。（本节内容）
​	（2）在 C 语言中嵌入汇编代码，直接编译生成可执行程序。

### 系统调用

​	系统调用是操作系统提供的功能接口，用于实现一些在用户态无法或不易实现的功能，如文件读写。**Linux系统调用通过一个统一的入口实现，即第0x80号中断**，并通过eax寄存器指定具体的子功能号。（BIOS 中断走的是中断向量表，所以有很多中断号给它用，而系统调用走的是中断描述符表中的一项而已，所以只用了第 0x80 项中断）

- 调用“系统调用”有两种方式。

​	（1）**将系统调用指令封装为 c 库函数，通过库函数进行系统调用**，操作简单。
​	（2）**不依赖任何库函数，直接通过汇编指令 int 与操作系统通信**。

- 在Linux系统中，系统调用定义在`/usr/include/asm/unistd_32.h`文件中，如第4号调用（即`__NR_write`）为write系统调用。

![image-20240814214949324](/home/ZMR/.config/Typora/typora-user-images/image-20240814214949324.png)



#### **第一种系统调用**

```c
#include <unistd.h>
int main(){
write(1,"hello,world\n",4);
return 0;
}
```



#### **★★ 第二种系统调用**（mov eax; int ox80)

跨过库函数直接与系统内核通信，这样最终的程序不需要与任何库文件链接

**步骤：**

1. **设置系统调用号**：通过 `eax` 寄存器传递。

   ```assembly
   mov eax, <syscall_number>
   ```

2. **参数传递**：通过 `ebx`、`ecx`、`edx` 等寄存器传递。

   ```assembly
   mov ebx, <arg1>  ; 第一个参数
   mov ecx, <arg2>  ; 第二个参数
   mov edx, <arg3>  ; 第三个参数
   ```

3. **触发系统调用**：通过 `int 0x80`（32 位）或 `syscall`（64 位）指令完成。

   ```assembly
   int 0x80  ; 触发中断，执行系统调用
   ```

   - 例子见下面的方式2  (下面两种都属于第二种系统调用)

```assembly
section .data
    str_c_lib: db "c library says: hello world!", 0xa  ; 0xa 为 LF ASCII 码
    str_c_lib_len equ $-str_c_lib

    str_syscall: db "syscall says: hello world!", 0xa
    str_syscall_len equ $-str_syscall

section .text
    global _start

_start:
    ; ----------------------方式 1: 模拟 C 语言中系统调用库函数 write------------------
    push str_c_lib_len          ; 按照 C 调用将 write 的三个参数（文件描述符、字符串地址、字符串长度）压入栈中
    push str_c_lib
    push 1
    call simu_write             ; 调用下面定义的 simu_write
    add esp, 12                 ; 回收栈空间

    ;----------------------- 方式 2: 跨过库函数，直接进行系统调用------------------------
    mov eax, 4                  ; 第 4 号子功能是 write 系统调用（不是 C 库函数 write）
    mov ebx, 1					; ebx=1 是文件描述符
    mov ecx, str_syscall		; ecx 是字符串地址
    mov edx, str_syscall_len	; edx 是字符串长度
    int 0x80                    ; 发起中断，通知 Linux 完成请求的功能

    ; ----------------------------------退出程序------------------------------------
    mov eax, 1                  ; 第 1 号子功能是 exit
    int 0x80                    ; 发起中断，通知 Linux 完成请求的功能


; --------------------下面自定义的 simu_write 用来模拟 C 库中系统调用函数 write----------------
simu_write:
    push ebp                    ; 备份 ebp
    mov ebp, esp
    mov eax, 4                  ; 第 4 号子功能是 write 系统调用（不是 C 库函数 write）
    mov ebx, [ebp+8]            ; 第 1 个参数
    mov ecx, [ebp+12]           ; 第 2 个参数
    mov edx, [ebp+16]           ; 第 3 个参数
    int 0x80                    ; 发起中断，通知 Linux 完成请求的功能
    pop ebp                     ; 恢复 ebp
    ret

```

![image-20240814220552464](/home/ZMR/.config/Typora/typora-user-images/image-20240814220552464.png)

---

### ★★ 汇编语言和 C 语言相互调用

不同编程语言通过编译器和链接器转换为机器码，这些机器码是所有编程语言的“共同语言”。因此，**汇编语言和 C 语言之间的互相调用本质上是它们都最终转换为机器码后进行的**。这个过程就像不同语言的人通过共同理解的“形象”来沟通一样。

![image-20240815105731635](/home/ZMR/.config/Typora/typora-user-images/image-20240815105731635.png)

汇编代码 C_with_S_S.S

```assembly
section .data
str: db "asm_print says hello world!", 0xa, 0
str_len equ $-str		; 计算并定义字符串的长度，长度为当前地址 ($) 减去字符串起始地址 (str)。


section .text
extern c_print			; ★★声明外部函数 c_print，这个函数在 C 代码中定义，汇编代码需要调用它。
global _start			; 将 _start 定义为全局符号，作为程序的入口点，使得链接器能够识别。

_start:
; ------------------------------ 调用c代码中的函数c_print ---------------------------------
    push str			; 将字符串的地址压入栈中，作为参数传递给 c_print 函数。
    call c_print		; ★★调用外部的 c_print 函数，c_print 会从栈中弹出字符串地址，并调用 asm_print。
    add esp, 4			; 调用 c_print 后，栈中还存留着我们传入的参数（字符串地址），
    					; 这里使用 add 指令调整栈指针，清理传入的参数，回收栈空间。

; ------------------------------------- 退出程序 ---------------------------------------
    mov eax, 1			; 第 1 号子功能是 exit 系统调用
    int 0x80			; 触发中断 0x80，调用内核的系统调用服务，此时会执行 exit 调用，终止程序。


; ---------------------------------- ★★定义asm_print函数 ------------------------------------
global asm_print		; 将 asm_print 函数导出为全局符号，使其可以被 C 代码调用。
asm_print:
    push ebp			; 保存当前的基址指针寄存器 (ebp)，为后续函数调用保存堆栈帧。
    mov ebp, esp		; 将当前的栈指针 (esp) 复制到基址指针 (ebp)，建立新的堆栈帧。

    mov eax, 4			; 第 4 号子功能是 write 系统调用
    mov ebx, 1			; 文件描述符 1 代表标准输出 (stdout)，即输出到屏幕。

    mov ecx, [ebp+8]	; 将字符串的地址（第 1 个参数）
    mov edx, [ebp+12]	; 将字符串的长度（第 2 个参数）
    
    int 0x80			; 发起中断，通知 Linux 完成请求的功能

    pop ebp				; 恢复之前保存的基址指针 (ebp)，还原栈帧。

    ret
```



c语言代码 C_with_S_c.c

```c
extern void asm_print(char*, int);		// ★★声明了一个外部函数 asm_print，该函数接收一个字符指针和一个整数。这个声明告诉编译器 asm_print 函数在其他文件中定义。

//---------------------------------- ★★定义c_print函数 ------------------------------------
void c_print(char* str) {
    int len = 0;
    while (str[len++]);
    asm_print(str, len);				// ★★ 调用asm_print函数
}
```



总结：

**在汇编代码中导出符号**：使用 `global` 关键字，使符号可以被外部文件引用。

**在汇编代码中引用外部符号**：使用 `extern` 关键字，声明外部符号供汇编代码使用。

**在 C 代码中引用外部符号**：使用 `extern` 关键字声明外部符号，并定义为全局变量或函数，使其能够被外部文件引用。

---

---

## 实现自己的打印函数

### 显卡的端口控制

**显卡的基本操作模式**

- **文本模式**：在文本模式下，显存直接映射到内存地址，通过向显存地址写入字符的 ASCII 码和属性（如颜色）即可实现字符显示。
- **图形模式**：在图形模式下，操作显卡则复杂得多，需要通过对多个寄存器和端口进行操作来控制图形的显示。这里不再是简单的 `mov` 操作，而需要用到特定的 I/O 指令 `in` 和 `out`。

**显卡寄存器的分组**

显卡寄存器根据其功能和位置被分为多个分组，主要包括：
- Graphics Registers
- Sequencer Registers
- Attribute Controller Registers
- CRT Controller Registers

这些寄存器分别对应不同的功能，如控制图形输出的参数、时钟、颜色属性等。

**寄存器的操作**

由于显卡上寄存器数量众多，设计上采用了分组的方式，并且使用了两个寄存器来实现对整个寄存器组的操作：
- **Address Register**：用于指定具体要操作的寄存器（类似数组的索引）。

- **Data Register**：用于读写指定的寄存器（通过 Address Register 指定）。

  ![image-20240815171153066](/home/ZMR/.config/Typora/typora-user-images/image-20240815171153066.png)

![image-20240815120714287](/home/ZMR/.config/Typora/typora-user-images/image-20240815120714287.png)

**示例操作**

**假设你需要对某个 CRT Controller Register 进行操作，首先需要通过 `Address Register` 指定寄存器索引，然后通过 `Data Register` 对该寄存器进行读写操作。**

例如，CRT Controller Registers 的端口地址根据 `Miscellaneous Output Register` 的 `Input/Output Address Select (I/OAS)` 字段来决定：
- 如果 `I/OAS` 为 0，`Address Register` 和 `Data Register` 的端口地址为 `0x3B4` 和 `0x3B5`。
- 如果 `I/OAS` 为 1，端口地址则为 `0x3D4` 和 `0x3D5`。

通过设置 `Address Register` 和 `Data Register`，可以访问和控制特定的 CRT 寄存器，如下是一个简单的流程：
1. 设置 `Address Register`，指定要操作的寄存器索引。

2. 通过 `Data Register` 进行数据读写。

   

---

### 实现单个字符打印

功能：写一个实现打印功能的汇编代码编译进入内核，来实现我们常见的显示字符功能。

实现原理：

​	A、通过对显存段操作，我们能够在屏幕上显示字符

​	B、通过与显卡寄存器打交道，我们可以获得光标位置（光标位置需要与VAG寄存器（显卡的寄存器）中CRT Controller Registers组中索引号为0Eh与0Fh寄存器来打交道）

​	C、结合A，能够实现我们平常见的那种先在光标处显示字符，然后光标向后移动的效果。

​	

#### ▶ 代码

为了开发方便，我们先要定义一些数据类型 (**myos/lib/stdint.h**)

```c
#ifndef __LIB_STDINT_H
#define __LIB_STDINT_H
typedef signed char int8_t;
typedef signed short int int16_t;
typedef signed int int32_t;
typedef signed long long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;
#endif
```



**/lib/kernel/print.S**

```assembly
TI_GDT equ  0                                               ;从这里开始三步是在定义显存段段描述符的选择子
RPL0  equ   0
SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0

[bits 32]                                                   ;采用32位编译
section .text                                               ;表明这是个代码段

;------------------------   put_char   -----------------------------
;功能描述:把栈中的1个字符写入光标所在处
;-------------------------------------------------------------------   
global put_char                                             ;将put_char导出为全局符号，这样其他文件也可以使用
put_char:
    pushad	                                                ;备份32位寄存器环境（指令将所有 32 位通用寄存器EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI压入栈中,以便在函数结束时恢复寄存器状态）
                                                            
    mov ax, SELECTOR_VIDEO	                                ;需要保证gs中为正确的视频段选择子,为保险起见,每次打印时都为gs赋值（不能直接把立即数送入段寄存器）
    mov gs, ax

                                                            ;-------------  获取当前光标位置 -------------
                                                            ;先获得高8位
    mov dx, 0x03d4                                          ;设置 dx 寄存器为 CRT 控制器的索引寄存器端口地址
    mov al, 0x0e	                                        ;指定要读取光标位置的高 8 位
    out dx, al												;将光标高 8 位索引输出到端口
    mov dx, 0x03d5                                          ;通过读写数据端口0x3d5来获得或设置光标位置 
    in al, dx	                                            ;得到了光标位置的高8位
    mov ah, al

                                                            ;再获取低8位
    mov dx, 0x03d4
    mov al, 0x0f
    out dx, al
    mov dx, 0x03d5 
    in al, dx                                                  
    mov bx, ax	                                            ;现在bx中存的是光标的位置
    
    														;-----------获取待打印字符并判断其类型----------
                                                            ;下面这行是在栈中获取待打印的字符
    mov ecx, [esp + 36]	                                    ;pushad压入4×8＝32字节,加上主调函数的返回地址4字节,故esp+36字节,现在ecx中是要打印的字符
    cmp cl, 0xd				                                ;判断是否是CR(回车)0x0d
    jz .is_carriage_return
    cmp cl, 0xa                                             ;判断是否是LF(换行)0x0a
    jz .is_line_feed

    cmp cl, 0x8				                                ;判断是否是BS(backspace退格)的asc码8
    jz .is_backspace
    jmp .put_other	   

      
                                                            ;--------------退格键处理-------------
.is_backspace:		
                                                            ; 当为backspace时,本质上只要将光标移向前一个显存位置即可.后面再输入的字符自然会覆盖此处的字符
                                                            ; 但有可能在键入backspace后并不再键入新的字符,这时在光标已经向前移动到待删除的字符位置,但字符还在原处
                                                            ; 这就显得好怪异,所以此处添加了空格或空字符0
    dec bx                                                  ;光标位置-1, 以符合我们的常识认知, 即按下退格符, 光标回退
    shl bx,1                                                ;光标的位置就转换成了对应字符的显存位置的偏移
    mov byte [gs:bx], 0x20		                            ;将待删除的字节补为0或空格皆可, 0x20是空格符的ascii码值 
    inc bx                                                  ;bx+1, 指向这个字符的属性位置, 也就是设定背景色, 字符颜色
    mov byte [gs:bx], 0x07                                  ;0x07, 就是黑底白字
    shr bx,1                                                ;bx虽然指向这个字符的颜色属性字节，但是除以2还是变回这个字符的光标位置
    jmp .set_cursor                                         ;去设置光标位置, 这样光标位置才能真正在视觉上更新


															;--------------可见字符处理-------------
 .put_other:
    shl bx, 1				                                ; 光标位置是用2字节表示,将光标值乘2,表示对应显存中的偏移字节
    mov [gs:bx], cl			                                ; ascii字符本身
    inc bx
    mov byte [gs:bx],0x07		                            ; 字符属性
    shr bx, 1				                                ; 恢复老的光标值
    inc bx				                                    ; 下一个光标值
    cmp bx, 2000		   
    jl .set_cursor			                                ; 若光标值小于2000,表示未写到显存的最后,则去设置新的光标值
					                                        ; 若超出屏幕字符数大小(2000)则换行处理
					                                        
															;--------------回车换行处理-------------
 .is_line_feed:				                                ; 是换行符LF(\n)
 .is_carriage_return:			                            ; 是回车符CR(\r)
					                                        ; 如果是CR(\r),只要把光标移到行首就行了。
    xor dx, dx				                                ;要进行16位除法，高16位置会放在dx中，要先清零
    mov ax, bx				                                ;ax是被除数的低16位.
    mov si, 80				                                ;用si寄存器来存储除数80 由于是效仿linux，linux中\n便表示下一行的行首，所以本系统中，
    div si				                                    ; 把\n和\r都处理为linux中\n的意思，也就是下一行的行首。ax/80后，ax中存商，dx中存储的是余数,汇编除法https://blog.csdn.net/loovejava/article/details/7044242
    sub bx, dx				                                ; 光标值减去除80的余数便是取整
					                                        ; 以上4行处理\r的代码

 .is_carriage_return_end:		                            ; 回车符CR处理结束
    add bx, 80
    cmp bx, 2000
 .is_line_feed_end:			                                ; 若是LF(\n),将光标移+80便可。  
    jl .set_cursor

                                                            ;屏幕行范围是0~24,滚屏的原理是将屏幕的1~24行搬运到0~23行,再将第24行用空格填充
.roll_screen:				                                ; 若超出屏幕大小，开始滚屏
    cld                                                     
    mov ecx, 960				                            ; 一共有2000-80=1920个字符要搬运,共1920*2=3840字节.一次搬4字节,共3840/4=960次 
    mov esi, 0xb80a0			                            ; 第1行行首
    mov edi, 0xb8000			                            ; 第0行行首
    rep movsd				                                ;rep movs word ptr es:[edi], word ptr ds:[esi] 简写为: rep movsw

                                                            ;将最后一行填充为空白
    mov ebx, 3840			                                ; 最后一行首字符的第一个字节偏移= 1920 * 2
    mov ecx, 80				                                ;一行是80字符(160字节),每次清空1字符(2字节),一行需要移动80次
 .cls:
    mov word [gs:ebx], 0x0720		                        ;0x0720是黑底白字的空格键
    add ebx, 2
    loop .cls 
    mov bx,1920				                                ;将光标值重置为1920,最后一行的首字符.

.set_cursor:   
					                                        ;将光标设为bx值
                                                            ;;;;;;; 1 先设置高8位 ;;;;;;;;
    mov dx, 0x03d4			                                ;索引寄存器
    mov al, 0x0e				                            ;用于提供光标位置的高8位
    out dx, al
    mov dx, 0x03d5			                                ;通过读写数据端口0x3d5来获得或设置光标位置 
    mov al, bh
    out dx, al

                                                            ;;;;;;; 2 再设置低8位 ;;;;;;;;;
    mov dx, 0x03d4
    mov al, 0x0f
    out dx, al
    mov dx, 0x03d5 
    mov al, bl
    out dx, al
.put_char_done: 
    popad
    ret
```



**为了方便其他函数调用我们写的print，我们为其建立一个头文件/lib/kernel/print.h**

```c
#ifndef __LIB_KERNEL_PRINT_H
#define __LIB_KERNEL_PRINT_H
#include "stdint.h"     //我们的stdint.h中定义了数据类型，包含进来
void put_char(uint8_t char_asci);      //在stdint.h中uint8_t得到了定义，就是unsigned char
#endif
```



**验证我们的打印函数是否能正常工作，编写一个内核文件 myos/kernel/main.c**

```c
#include "print.h"
void main(void)
{
    put_char('T');
    put_char('i');
    put_char('n');
    put_char('y');
    put_char('O');
    put_char('S');
    put_char('\n');
    put_char('1');
    put_char('2');
    put_char('\b');
    put_char('3');
    while(1);
    
}
```

![image-20240815170447925](/home/ZMR/.config/Typora/typora-user-images/image-20240815170447925.png)
