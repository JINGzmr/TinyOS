 # 第二章 BIOS与MBR

## 载入内存

- cpu的硬件电路只能运行处于内存中的程序
  - 优点:速度快,容量大,统一不同的存储介质
- 程序载入内存的步骤
  1. 程序被加载器加载到内存某个区域
  2. CPU的cs:ip寄存器指向该程序的起始地址

---

---

## BIOS

- Base Input & Output System，即基本输入输出系统。
- Intel 8086 有 20 条地址线，可以访问 1MB 的内存空间，即 2 的 20 次方=1048576=1MB，地址范围是 0x00000 到 0xFFFFF
  - 但这20条地址总线**不是全部都给内存条使用**
  - 20条中一部分给外设，一部分给显存，一部分给...剩下的可用地址给内存条，也就是物理内存
  - 所以：32位机，就算安装了4GB内存条，但显示其内存也只有3.8GB左右
- **实模式下的 1MB 内存**布局
  - ![image-20240730204222074](/home/ZMR/.config/Typora/typora-user-images/image-20240730204222074.png)
  - 顶部的 0xF0000～0xFFFFF，这 64KB 的内存是 ROM，存的是 **BIOS 的代码**
  - BIOS 的主要工作是**检测、初始化硬件**（硬件自己提供了一些初始化的功能调用，BIOS 直接调用就好了）
  - BIOS 在内存中的 0x000 至 0x3FF 区域**建立中断向量表**，可以通过**int 中断号**来实现相关的**硬件调用**，这是**`对硬件的 IO 操作，也就是输入输出`** ----> （解释了为什么 BIOS 叫做基本输入输出系统）

---

### BIOS的加载过程

1. BIOS是**计算机启动时第一个运行的软件**，它存储在只读存储器（ROM）中
2. **硬件加载**：BIOS 由硬件加载（ ROM 通过地址映射在低端 1MB 内存的顶部（地址 0xF0000 至 0xFFFFF））
3. **入口地址**：BIOS 的入口地址是 0xFFFF0。开机时，CPU 的**段寄存器（cs）和指令指针（ip）被强制初始化为 0xF000 和 0xFFF0**
4. **实模式下的地址计算**：在实模式下，段地址需要乘以 16，0xF000:0xFFF0 的**物理地址为 0xFFFF0**

### BIOS初始化过程

5. **跳转指令**：在 0xFFFF0 处的**跳转指令**（如 `jmp far f000:e05b`）指向 BIOS 代码的**实际位置**
6. **硬件检测**：BIOS 初始化后，会检测内存、显卡等硬件，当检测通过并初始化好硬件后，在内存中的 0x000 至 0x3FF 区域**建立中断向量表（IVT）**

### BIOS最后一项任务

7. 校验启动盘的**MBR**（主引导记录）
8. 检查MBR末尾的两个字节（魔数0x55和0xaa）来确认该扇区中存在可执行程序

---

---

## MBR

- 一开始位于启动盘**0盘 0道 1扇区**（固定该位置是为了节省启动时间）

- **MBR加载的位置**: 选择32KB内存的**最后1KB（即0x7c00）为MBR的加载地址**，确保不会覆盖系统的其他重要数据。

  - 32KB：**最小内存要求**: 操作系统（如DOS）需要32KB内存。

  - 1KB：MBR 的大小必须是 512 字节（但还要为其所用的栈分配点空间，就干脆给1KB）

    - 所以**0x55 和 0xaa 这两个魔数分别位与510和511字节处**

      ```assembly
      ;mbr.s文件
      SECTION MBR vstart=0x7c00 
      
      	...
      
          message db "hello MBR"      ;定义打印的字符串为hello MBR
          times 510-($-$$) db 0       ;$为本代码行的地址,$$为本section的起始地址,$-$$为本行到本 section的偏移量
                                      ;因为MBR 的最后两个字节是固定的内容，分别是 0x55 和 0xaa，要预留出这 2 个字节
                                      ;故本扇区内前 512-2=510 字节要填满, 所以db 0是用 0 将本扇区剩余空间填充
          db 0x55,0xaa                ;最后两个字节为固定的魔数,BIOS会检查这两个字节来识别这是一个有效的MBR
      ```

  - 0x7c00：与IBM PC 5150的BIOS设计有关，该位置是在BIOS中断处理程序（INT 19H）中硬编码的，旨在为加载MBR提供一个可靠的地址

### BIOS与MBR

#### 地址类型

1. **0xFFFF0**（BIOS 入口点）
   - **类型**：物理地址。
   - **说明**：在实模式下，BIOS 的入口地址通常为 0xFFFF0。这是 BIOS 固件在启动时的加载位置。
2. **0x7C00**（MBR）
   - **类型**：物理地址。
   - **说明**：MBR通常在磁盘的第一个扇区，加载到内存时的地址为 0x7C00。

#### 地址关系

- 都在物理内存：在计算机启动时，BIOS 会将 MBR 从磁盘中读取到物理内存的 0x7C00 位置

---

---

---

# 第三章 完善MBR

## CPU工作原理

![image-20240731102328181](/home/ZMR/.config/Typora/typora-user-images/image-20240731102328181.png)

- **控制单元**要取下一条待运行的指令，该指令的地址在**程序计数器 PC** 中，在 x86CPU 上，程序计数器就是 **cs：ip**
- 读取 **ip 寄存器**后，将此地址送上地址总线，CPU 根据此地址便得到了指令，并将其存入到**指令寄存器 IR** 中
- 这时候轮到**指令译码器**上场了，它根据指令格式检查指令寄存器中的指令，先确定操作码是什么，再检查操作数类型，若是在内存中，就将相应**操作数**从内存中取到自己的存储单元，若操作数是在寄存器中就直接用了，免了取操作数这一过程
- 操作码有了，操作数也齐了，**操作控制器**给运算单元下令，开工，于是**运算单元**便真正开始执行指令了。ip 寄存器的值被加上当前指令的大小，于是 ip 又指向了下一条指令的地址
- 接着控制单元又要取下一条指令了，流程回到了本段开头

---

## 实模式下 CPU 内存寻址方式

- 寄存器寻址
- 立即数寻址
- 内存寻址
  - 直接寻址
  - 基址寻址
  - 变址寻址
  - 基址变址寻址

### 寄存器寻址

```assembly
mov ax, 0x10
mov dx, 0x9
mul dx
```

- 第一、二条指令源操作数都是立即数，所以也属于立即数寻址

### 立即数寻址

```assembly
mov ax,0x18
mov ds, ax
mov ax, macro_selector ; 宏
mov ax, label_star 	   ; 标号
```

- 第一条指令中的源操作数 0x18 是立即数，目的操作数 ax 是寄存器，所以它既是立即数寻址，也是寄
  存器寻址

### 内存寻址

- 前面两种寻址方式，**操作数一个是在寄存器中，一个是在指令中直接给出，它们都不在内存中**。操作
  数在内存中的寻址方式称为内存寻址。
- ~~寄存器寻址弊端：CPU 给程序员用的寄存器并不是很多，所以操作数一多起来的时候，基本就倒腾不开了~~
- ~~立即数寻址弊端：得提前知道立即数是多少。而且，大多数时候操作数位于内存中的某个位置，只知道操作数所在的内存地址，不知道操作数的值~~

#### 直接寻址

- **数字作为内存地址**，通过中括号的形式告诉 CPU，取此地址中的值作为操作数

```assembly
mov ax, [0x1234]
mov ax, [fs:0x5678]
```

- 0x1234 是**段内偏移地址，默认的段地址是 DS**。这条指令是将内存地址 DS：0x1234 处的值写入 ax 寄存器
- 第二条指令中，由于使用了**段跨越前缀 fs**，0x5678 的**段基址则变成了 gs 寄存器**。最终的内存地址是gs 寄存器的值*16+0x5678，CPU 到此内存地址取值再存入 ax 寄存器

#### 基址寻址

- 使用 **BX** 或 **BP** 寄存器作为基址，进行内存地址的计算（实模式下只能用这两个，保护模式不限）
- **BX寄存器**：
  - 默认段寄存器为 **DS**（数据段）。
  - 例如：指令 `ADD WORD [BX], 0x1234` 意味着将内存地址 `DS:BX` 处的值与 `0x1234` 相加，并存回 `DS:BX`。
- **BP寄存器**：
  - 默认段寄存器为 **SS**（栈段）。
  - 主要用于栈的访问，尤其在函数调用和局部变量管理中。![image-20240731105233478](/home/ZMR/.config/Typora/typora-user-images/image-20240731105233478.png)
- 堆栈框架![image-20240731110313114](/home/ZMR/.config/Typora/typora-user-images/image-20240731110313114.png)

#### 变址寻址

- 和基址寻址类似，只是寄存器由 bx、bp 换成了 si 和 di，默认段寄存器是 ds

  ```assembly
  mov [di]，ax  		;将 AX 寄存器的值存储到由 DI 寄存器指向的内存地址
  mov [si+0x1234], ax  ;将 AX 寄存器的值存储到由 SI 寄存器加上偏移量 0x1234 计算得出的内存地址
  ```

#### 基址变址寻址

- 基址寄存器 bx 或 bp 加一个变址寄存器 si 或 di，默认段寄存器是 ds

  ```assembly
  mov [bx+di], ax  ;将 ax 中的值送入以 ds 为段基址，bx+di 为偏移地址的内存
  add [bx+si], ax  ;将 ax 与[ds：bx+si]处的值相加后存入内存[ds：bx+si]
  ```

---

## 实模式下的ret

### 近返回ret

1. ret（return）指令的功能：在栈顶（寄存器 ss：sp 所指向的地址）弹出 **2 字节**的内容来替换 **IP** 寄存器，并会使 sp 指针+2
2. 如果 call 是**近调用**，在目标函数中就要用 ret 来返回，因为**近调用的 call 只在栈中留下了 2 字节的返回地址**（IP 寄存器的值），ret 只是从栈顶取得 2 个字节作为偏移地址载入 IP 寄存器

### 远返回retf

1. retf（return far）：从栈顶取得 **4 字节**，栈顶处的 2 字节用来替换 **IP** 寄存器，另外的 2 字节用来替换**CS** 寄存器
2. 如果 call 是**远调用**，在目标函数中就要用 retf（ret far）来返回，因为**远调用的 call 指令在栈中留下了段基址和段内偏移地址**，retf 指令只会从栈中弹出 2 字节的偏移地址和 2 字节的段基址

---

## 实模式下的call

### 16 位实模式相对近调用

**1. 相对近调用概述**

- 相对近调用是指在同一个代码段内（即同一个 64KB 空间内）进行函数调用。
- 由于目标函数和当前指令位于同一个段，因此只需要给出目标函数的段内偏移地址，无需给出段基址。
- 这种调用方式使用 `call near` 指令，其中 `near` 可以省略。
- 指令格式为 `call near 立即数地址`，操作数为立即数。

**2. 相对近调用的操作数**

- 操作数不是目标函数的绝对地址，而**是目标函数地址相对于当前 `call` 指令地址的偏移量，即地址差**。
- 具体计算方法为：**目标函数地址 - 当前 `call` 指令地址 - 指令长度（3 字节）**。
- 操作数是一个有符号数，范围为 -32768 到 32767。

**3. 相对近调用的执行过程**

- **CPU 遇到 `call near` 指令时，会将当前 IP 寄存器值（即当前指令地址）压入堆栈，然后将操作数（相对地址增量）加到 IP 寄存器值上，并将结果作为新的 IP 寄存器值，从而跳转到目标函数的地址。**
- **目标函数执行完毕后，使用 `ret` 指令返回。`ret` 指令会从堆栈中弹出之前保存的 IP 寄存器值，并将其赋值给 IP 寄存器，从而返回到 `call` 指令的下一条指令处继续执行。**

**4. 相对近调用的优势**

- 由于操作数是相对地址，因此代码位置的改变不会影响指令的执行，提高了代码的可移植性。
- 相对地址的计算由编译器完成，简化了开发人员的工作。

**5. 示例代码分析**

```assembly
call near near_proc
jmp $
addr dd 4
near_proc：
	mov ax， 0x1234
	ret
```

`call near_proc` 指令的机器码为 `e8 06 00`。

- `e8` 是 `call near` 指令的操作码。
- `06 00` 是操作数，表示目标函数 `near_proc` 的地址相对于当前 `call` 指令地址的偏移量为 6。

bochs 的反汇编结果验证了这一点：

- 当前指令地址为 `0x900`。
- 目标函数地址为 `0x909`。
- 操作数为 `0x06`，即 `0x909 - 0x900 - 3 = 0x06`。

### 16 位实模式间接绝对近调用

**1. 间接绝对近调用概述**

- 间接绝对近调用是指通过寄存器或内存地址间接获取目标函数的绝对地址，并在同一个代码段内进行函数调用。
- 与“16 位相对近调用”不同，这种调用方式**不使用相对地址，而是直接使用目标函数的绝对地址**。
- 由于是近调用，目标函数和当前指令位于同一个代码段，因此只需要给出目标函数的段内偏移地址，无需给出段基址。

**2. 指令格式**

- 指令格式为 `call 寄存器寻址` 或 `call 内存寻址`。
- `call 寄存器寻址` 指令使用寄存器存放目标函数的地址，例如 `call ax`。
- `call 内存寻址` 指令使用内存地址存放目标函数的地址，例如 `call [0x1234]`。

**3. 操作码**

- `call 内存寻址` 指令的操作码为 `ff16`，机器码为 `ff16 + 16 位内存地址`。
- 寄存器寻址的机器码与寄存器名称有关，例如 `call ax` 的机器码为 `ffd0`，`call cx` 的机器码为 `ffd1`。

**4. 执行过程**

- **CPU 遇到 `call` 指令时，会将当前 IP 寄存器值（即当前指令地址）压入堆栈。**
- **然后根据指令格式，从寄存器或内存中获取目标函数的地址，并将其赋值给 IP 寄存器。**
- **最后，CPU 跳转到目标函数地址执行。**

**5. 示例代码分析**

```assembly
section call_test vstart=0x900
mov word [addr], near_proc
call [addr]
mov ax, near_proc
call ax
jmp $
addr dd 4
near_proc:
	mov ax, 0x1234
	ret
```

`call [addr]` 和 `call ax` 分别演示了间接绝对近调用的两种方式。

- 第 3 行 `call [addr]` 使用内存地址 `addr` 存放目标函数 `near_proc` 的地址。
- 第 5 行 `call ax` 使用 `ax` 寄存器存放目标函数 `near_proc` 的地址。

### 16 位实模式直接绝对远调用

### 16 位实模式间接绝对远调用



---

## 实模式下的 jmp

- `相对于call：jmp有去无返`

1. **短相对跳转 (jmp short)**：这种跳转类型使用一个有符号 8 位立即数作为偏移量，允许在当前指令的 -128 到 +127 字节内进行相对跳转。这条指令的操作码是 0xEB。

   ```assembly
   jmp short start
   ...
   start：
   	...
   ```

2. **近相对跳转 (jmp near)**：这种跳转类型使用一个有符号 16 位立即数作为偏移量，允许在当前指令的 -32,768 到 +32,767 字节内进行相对跳转。这条指令的操作码是 0xE9。

   ```assembly
   jmp near start
   ...
   start:
   	...
   ```

3. **近寄存器间接跳转 (jmp near reg)**：这种跳转类型使用一个寄存器中的 16 位值，例如 AX。这条指令的操作码是 0xFF。

   ```assembly
   mov ax， start
   jmp near ax
   ...
   start:
   	...
   ```

4. **直接绝对远转移 (jmp far)**：这种跳转类型直接提供目标地址的段基址和段内偏移地址。操作数是立即数形式的。操作数会被直接加载到 CS 寄存器和 IP 寄存器中，从而实现转移。

   ```assembly
   jmp 0：start
   ...
   start:
   	...
   ```

5. **间接绝对远转移 (jmp far mem)**：这种跳转类型的操作数在内存中。当不使用段跨越前缀时，段基址寄存器默认为 DS。操作数需要访问内存才能得到，因此需要知道寻址方式。操作数包含 4 个字节：段内偏移地址（2 字节）和段基址（2 字节）。由于是远转移，因此 CPU 的 CS 寄存器和 IP 寄存器都要被修改成操作数中指定的值。

   ```assembly
   jmp far [addr]
   ...
   addr dw start，0
   start:
   	...
   ```

---

## 标志寄存器 flags

![image-20240731155453687](/home/ZMR/.config/Typora/typora-user-images/image-20240731155453687.png)

- 第 0 位的是 CF 位，即 Carry Flag，意为进位。它可用于检测**无符号**数加减法**是否有溢出**，因为 CF 为 1 时，也就是最高位有进位或借位，肯定是溢出。
- 第 2 位为 PF 位，即 Parity Flag，意为奇偶位。用于标记结果低 8 位中 1 的个数，如果为偶数，PF 位为 1，否则为 0。
- 第 4 位为 AF 位，即 Auxiliary carry Flag，意为辅助进位标志，用来记录运算结果低 4 位的进、借位情况，即若低半字节有进、借位，AF 为 1，否则为 0。
- 第 6 位为 ZF 位，即 Zero Flag，意为零标志位。若计算结果为 0，此标志为 1，否则为 0。
- 第 7 位为 SF 位，即 Sign Flag，意为符号标志位。若运算结果为负，则 SF 位为 1，否则为 0。
- 第 8 位为 TF 位，即 Trap Flag，意为陷阱标志位。此位若为 1，用于让 CPU 进入单步运行方式，若为0，则为连续工作的方式。(debug 程序，在单步调试时，原理上就是让 TF 位为 1)
- 第 9 位为 IF 位，即 Interrupt Flag，意为中断标志位。若 IF 位为 1，表示中断开启，CPU 可以响应外部可屏蔽中断。若为 0，表示中断关闭，CPU 不再响应来自 CPU 外部的可屏蔽中断，但 CPU 内部的异常还是要响应的.
- 第 10 位为 DF 位，即 Direction Flag，意为方向标志位。此标志位用于字符串操作指令中，当 DF 为1 时，指令中的操作数地址会自动减少一个单位，当 DF 为 0 时，指令中的操作数地址会自动增加一个单位，意即给地址的变化提供个方向。
- 第 11 位为 OF 位，即 Overflow Flag，意为溢出标志位。若 OF 为 1，表示有溢出，为 0 则未发生溢出。专门用于检测**有符号数**运算结果**是否有溢出**现象。
- ...

---

## 有条件转移

![image-20240731160330979](/home/ZMR/.config/Typora/typora-user-images/image-20240731160330979.png)

a表示 above
b表示 below
c表示 carry
e表示 equal
g表示 great
j表示 jmp
l表示 less
n表示 not
o表示 overflow
p表示 parity

---

## 实模式的缺点

1. 实模式下没有特权级，用户程序和操作系统平起平坐
2. 程序可以随意修改自己的段基址，可以随意访问任意物理内存，包括访问操作系统所在的内存数据

----

