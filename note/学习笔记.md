 # 第二章 BIOS与MBR

## 载入内存

- cpu的硬件电路只能运行处于内存中的程序
  - 优点:速度快,容量大,统一不同的存储介质
- 程序载入内存的步骤
  1. 程序被加载器加载到内存某个区域
  2. CPU的cs:ip寄存器指向该程序的起始地址

---

---

## ★★ BIOS

- Base Input & Output System，即基本输入输出系统。
- Intel 8086 有 20 条地址线，可以访问 1MB 的内存空间，即 2 的 20 次方=1048576=1MB，地址范围是 0x00000 到 0xFFFFF
  - 但这20条地址总线**不是全部都给内存条使用**
  - 20条中一部分给外设，一部分给显存，一部分给...剩下的可用地址给内存条，也就是物理内存
  - 所以：32位机，就算安装了4GB内存条，但显示其内存也只有3.8GB左右
- **实模式下的 1MB 内存**布局
  - ![image-20240730204222074](/home/ZMR/.config/Typora/typora-user-images/image-20240730204222074.png)
  - 顶部的 0xF0000～0xFFFFF，这 64KB 的内存是 ROM，存的是 **BIOS 的代码**
  - BIOS 的主要工作是**检测、初始化硬件**（硬件自己提供了一些初始化的功能调用，BIOS 直接调用就好了）
  - BIOS 在内存中的 0x000 至 0x3FF 区域**建立中断向量表**，可以通过**int 中断号**来实现相关的**硬件调用**，这是**`对硬件的 IO 操作，也就是输入输出`** ----> （解释了为什么 BIOS 叫做基本输入输出系统）

---

### BIOS的加载过程

1. BIOS是**计算机启动时第一个运行的软件**，它存储在只读存储器（ROM）中
2. **硬件加载**：BIOS 由硬件加载（ ROM 通过地址映射在低端 1MB 内存的顶部（地址 0xF0000 至 0xFFFFF））
3. **入口地址**：BIOS 的入口地址是 0xFFFF0。开机时，CPU 的**段寄存器（cs）和指令指针（ip）被强制初始化为 0xF000 和 0xFFF0**
4. **实模式下的地址计算**：在实模式下，段地址需要乘以 16，0xF000:0xFFF0 的**物理地址为 0xFFFF0**

### BIOS初始化过程

5. **跳转指令**：在 0xFFFF0 处的**跳转指令**（如 `jmp far f000:e05b`）指向 BIOS 代码的**实际位置**
6. **硬件检测**：BIOS 初始化后，会检测内存、显卡等硬件，当检测通过并初始化好硬件后，在内存中的 0x000 至 0x3FF 区域**建立中断向量表（IVT）**

### BIOS最后一项任务

7. 校验启动盘的**MBR**（主引导记录）
8. 检查MBR末尾的两个字节（魔数0x55和0xaa）来确认该扇区中存在可执行程序

---

---

## ★★ MBR

- 一开始位于启动盘**0盘 0道 1扇区**（固定该位置是为了节省启动时间）

- **MBR加载的位置**: 选择32KB内存的**最后1KB（即0x7c00）为MBR的加载地址**，确保不会覆盖系统的其他重要数据。

  - 32KB：**最小内存要求**: 操作系统（如DOS）需要32KB内存。

  - 1KB：MBR 的大小必须是 512 字节（但还要为其所用的栈分配点空间，就干脆给1KB）

    - 所以**0x55 和 0xaa 这两个魔数分别位与510和511字节处**

      ```assembly
      ;mbr.s文件
      SECTION MBR vstart=0x7c00 
      
      	...
      
          message db "hello MBR"      ;定义打印的字符串为hello MBR
          times 510-($-$$) db 0       ;$为本代码行的地址,$$为本section的起始地址,$-$$为本行到本 section的偏移量
                                      ;因为MBR 的最后两个字节是固定的内容，分别是 0x55 和 0xaa，要预留出这 2 个字节
                                      ;故本扇区内前 512-2=510 字节要填满, 所以db 0是用 0 将本扇区剩余空间填充
          db 0x55,0xaa                ;最后两个字节为固定的魔数,BIOS会检查这两个字节来识别这是一个有效的MBR
      ```

  - 0x7c00：与IBM PC 5150的BIOS设计有关，该位置是在BIOS中断处理程序（INT 19H）中硬编码的，旨在为加载MBR提供一个可靠的地址

### ▶ 代码（通过BIOS输出hello MBR）

```assembly
;主引导程序 
SECTION MBR vstart=0x7c00       ;本程序在编译时，告诉编译器，把我的起始地址编译为 0x7c00
    mov ax,cs                   ;此时cs寄存器为0，可以用来将ax寄存器置0
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00               ;将栈指针sp寄存器初始化为0x7c00,让栈有足够的空间向低地址方向扩展。

    ;清屏
    ;利用0x06号功能，上卷全部行，则可清屏
    mov ax, 0x600               ;ah中输入功能号
    mov bx, 0x700               ;设置上卷行属性，0x70表示用黑底白字的属性填充空白行
    mov cx, 0                   ;左上角: (0, 0)
    mov dx, 0x184f	            ;右下角: (80,25),
			                    ;VGA文本模式中,一行只能容纳80个字符,共25行,下标从0开始,所以0x18=24,0x4f=79
    int 0x10                    

    ;下面这三行代码是获取光标位置
    mov ah, 3		            ;输入: 3号子功能是获取光标位置,需要存入ah寄存器
    mov bh, 0		            ;bh寄存器存储的是待获取光标的页号

    int 0x10		            ;执行BIOS 0x10号中断,输出: ch=光标开始行,cl=光标结束行,dh=光标所在行号,dl=光标所在列号

    ;打印字符串
    ;还是用10h中断,不过这次是调用13号子功能打印字符串
    mov ax, message 
    mov bp, ax		           
    mov cx, 9		            ;要打印的字符串的长度
    mov ax, 0x1301	            ;ah=13h,al=01h,表示要打印字符串
    mov bx, 0x2		            ;bh存储要显示的页号,此处是第0页,bl中是字符属性, 属性黑底绿字(bl = 02h,07是黑底白字)
    int 0x10		            ;执行BIOS 0x10 号中断,打印字符串

    jmp $		                ;使程序悬停在此,即死循环

    message db "hello MBR"      ;定义打印的字符串为hello MBR
    times 510-($-$$) db 0       ;$为本代码行的地址,$$为本section的起始地址,$-$$为本行到本 section的偏移量.
                                ;因为MBR 的最后两个字节是固定的内容，分别是 0x55 和 0xaa，要预留出这 2 个字节
                                ;故本扇区内前 512-2=510 字节要填满, 所以db 0是用 0 将本扇区剩余空间填充
    db 0x55,0xaa                ;最后两个字节为固定的魔数,BIOS会检查这两个字节来识别这是一个有效的MBR

```

### BIOS与MBR

#### 地址类型

1. **0xFFFF0**（BIOS 入口点）
   - **类型**：物理地址。
   - **说明**：在实模式下，BIOS 的入口地址通常为 0xFFFF0。这是 BIOS 固件在启动时的加载位置。
2. **0x7C00**（MBR）
   - **类型**：物理地址。
   - **说明**：MBR通常在磁盘的第一个扇区，加载到内存时的地址为 0x7C00。

#### 地址关系

- 都在物理内存：在计算机启动时，BIOS 会将 MBR 从磁盘中读取到物理内存的 0x7C00 位置

---

## ★★★计算机启动过程

**电源开启**：计算机通电，BIOS 开始执行。

**BIOS 初始化**：BIOS 执行上电自检（POST），初始化硬件，并查找引导设备。

**BIOS 加载 MBR**：BIOS 读取引导设备的 MBR，将其加载到内存，并将控制权转交给 MBR 中的引导代码。

**MBR 执行引导代码**：MBR 中的引导代码执行，加载操作系统的引导加载程序或操作系统本身。

---

---

---

# 第三章 完善MBR

## ★★★ CPU工作原理

![image-20240731102328181](/home/ZMR/.config/Typora/typora-user-images/image-20240731102328181.png)

- **控制单元**要取下一条待运行的指令，该指令的地址在**程序计数器 PC** 中，在 x86CPU 上，程序计数器就是 **cs：ip**
- 读取 **ip 寄存器**后，将此地址送上地址总线，CPU 根据此地址便得到了指令，并将其存入到**指令寄存器 IR** 中
- 这时候轮到**指令译码器**上场了，它根据指令格式检查指令寄存器中的指令，先确定操作码是什么，再检查操作数类型，若是在内存中，就将相应**操作数**从内存中取到自己的存储单元，若操作数是在寄存器中就直接用了，免了取操作数这一过程
- 操作码有了，操作数也齐了，**操作控制器**给运算单元下令，开工，于是**运算单元**便真正开始执行指令了。ip 寄存器的值被加上当前指令的大小，于是 ip 又指向了下一条指令的地址
- 接着控制单元又要取下一条指令了，流程回到了本段开头

---

## 实模式下 CPU 内存寻址方式

- 寄存器寻址
- 立即数寻址
- 内存寻址
  - 直接寻址
  - 基址寻址
  - 变址寻址
  - 基址变址寻址

### 寄存器寻址

```assembly
mov ax, 0x10
mov dx, 0x9
mul dx
```

- 第一、二条指令源操作数都是立即数，所以也属于立即数寻址

### 立即数寻址

```assembly
mov ax,0x18
mov ds, ax
mov ax, macro_selector ; 宏
mov ax, label_star 	   ; 标号
```

- 第一条指令中的源操作数 0x18 是立即数，目的操作数 ax 是寄存器，所以它既是立即数寻址，也是寄
  存器寻址

### 内存寻址

- 前面两种寻址方式，**操作数一个是在寄存器中，一个是在指令中直接给出，它们都不在内存中**。操作
  数在内存中的寻址方式称为内存寻址。
- ~~寄存器寻址弊端：CPU 给程序员用的寄存器并不是很多，所以操作数一多起来的时候，基本就倒腾不开了~~
- ~~立即数寻址弊端：得提前知道立即数是多少。而且，大多数时候操作数位于内存中的某个位置，只知道操作数所在的内存地址，不知道操作数的值~~

#### 直接寻址

- **数字作为内存地址**，通过中括号的形式告诉 CPU，取此地址中的值作为操作数

```assembly
mov ax, [0x1234]
mov ax, [fs:0x5678]
```

- 0x1234 是**段内偏移地址，默认的段地址是 DS**。这条指令是将内存地址 DS：0x1234 处的值写入 ax 寄存器
- 第二条指令中，由于使用了**段跨越前缀 fs**，0x5678 的**段基址则变成了 gs 寄存器**。最终的内存地址是gs 寄存器的值*16+0x5678，CPU 到此内存地址取值再存入 ax 寄存器

#### 基址寻址

- 使用 **BX** 或 **BP** 寄存器作为基址，进行内存地址的计算（实模式下只能用这两个，保护模式不限）
- **BX寄存器**：
  - 默认段寄存器为 **DS**（数据段）。
  - 例如：指令 `ADD WORD [BX], 0x1234` 意味着将内存地址 `DS:BX` 处的值与 `0x1234` 相加，并存回 `DS:BX`。
- **BP寄存器**：
  - 默认段寄存器为 **SS**（栈段）。
  - 主要用于栈的访问，尤其在函数调用和局部变量管理中。![image-20240731105233478](/home/ZMR/.config/Typora/typora-user-images/image-20240731105233478.png)
- 堆栈框架![image-20240731110313114](/home/ZMR/.config/Typora/typora-user-images/image-20240731110313114.png)

#### 变址寻址

- 和基址寻址类似，只是寄存器由 bx、bp 换成了 si 和 di，默认段寄存器是 ds

  ```assembly
  mov [di]，ax  		;将 AX 寄存器的值存储到由 DI 寄存器指向的内存地址
  mov [si+0x1234], ax  ;将 AX 寄存器的值存储到由 SI 寄存器加上偏移量 0x1234 计算得出的内存地址
  ```

#### 基址变址寻址

- 基址寄存器 bx 或 bp 加一个变址寄存器 si 或 di，默认段寄存器是 ds

  ```assembly
  mov [bx+di], ax  ;将 ax 中的值送入以 ds 为段基址，bx+di 为偏移地址的内存
  add [bx+si], ax  ;将 ax 与[ds：bx+si]处的值相加后存入内存[ds：bx+si]
  ```

---

## 实模式下的ret

### 近返回ret

1. ret（return）指令的功能：在栈顶（寄存器 ss：sp 所指向的地址）弹出 **2 字节**的内容来替换 **IP** 寄存器，并会使 sp 指针+2
2. 如果 call 是**近调用**，在目标函数中就要用 ret 来返回，因为**近调用的 call 只在栈中留下了 2 字节的返回地址**（IP 寄存器的值），ret 只是从栈顶取得 2 个字节作为偏移地址载入 IP 寄存器

### 远返回retf

1. retf（return far）：从栈顶取得 **4 字节**，栈顶处的 2 字节用来替换 **IP** 寄存器，另外的 2 字节用来替换**CS** 寄存器
2. 如果 call 是**远调用**，在目标函数中就要用 retf（ret far）来返回，因为**远调用的 call 指令在栈中留下了段基址和段内偏移地址**，retf 指令只会从栈中弹出 2 字节的偏移地址和 2 字节的段基址

---

## 实模式下的call

- 调用函数

### 16 位实模式相对近调用

**1. 相对近调用概述**

- 相对近调用是指在同一个代码段内（即同一个 64KB 空间内）进行函数调用。
- 由于目标函数和当前指令位于同一个段，因此只需要给出目标函数的段内偏移地址，无需给出段基址。
- 这种调用方式使用 `call near` 指令，其中 `near` 可以省略。
- 指令格式为 `call near 立即数地址`，操作数为立即数。

**2. 相对近调用的操作数**

- 操作数不是目标函数的绝对地址，而**是目标函数地址相对于当前 `call` 指令地址的偏移量，即地址差**。
- 具体计算方法为：**目标函数地址 - 当前 `call` 指令地址 - 指令长度（3 字节）**。
- 操作数是一个有符号数，范围为 -32768 到 32767。

**3. 相对近调用的执行过程**

- **CPU 遇到 `call near` 指令时，会将当前 IP 寄存器值（即当前指令地址）压入堆栈，然后将操作数（相对地址增量）加到 IP 寄存器值上，并将结果作为新的 IP 寄存器值，从而跳转到目标函数的地址。**
- **目标函数执行完毕后，使用 `ret` 指令返回。`ret` 指令会从堆栈中弹出之前保存的 IP 寄存器值，并将其赋值给 IP 寄存器，从而返回到 `call` 指令的下一条指令处继续执行。**

**4. 相对近调用的优势**

- 由于操作数是相对地址，因此代码位置的改变不会影响指令的执行，提高了代码的可移植性。
- 相对地址的计算由编译器完成，简化了开发人员的工作。

**5. 示例代码分析**

```assembly
call near near_proc
jmp $
addr dd 4
near_proc：
	mov ax， 0x1234
	ret
```

`call near_proc` 指令的机器码为 `e8 06 00`。

- `e8` 是 `call near` 指令的操作码。
- `06 00` 是操作数，表示目标函数 `near_proc` 的地址相对于当前 `call` 指令地址的偏移量为 6。

bochs 的反汇编结果验证了这一点：

- 当前指令地址为 `0x900`。
- 目标函数地址为 `0x909`。
- 操作数为 `0x06`，即 `0x909 - 0x900 - 3 = 0x06`。

### 16 位实模式间接绝对近调用

**1. 间接绝对近调用概述**

- 间接绝对近调用是指通过寄存器或内存地址间接获取目标函数的绝对地址，并在同一个代码段内进行函数调用。
- 与“16 位相对近调用”不同，这种调用方式**不使用相对地址，而是直接使用目标函数的绝对地址**。
- 由于是近调用，目标函数和当前指令位于同一个代码段，因此只需要给出目标函数的段内偏移地址，无需给出段基址。

**2. 指令格式**

- 指令格式为 `call 寄存器寻址` 或 `call 内存寻址`。
- `call 寄存器寻址` 指令使用寄存器存放目标函数的地址，例如 `call ax`。
- `call 内存寻址` 指令使用内存地址存放目标函数的地址，例如 `call [0x1234]`。

**3. 操作码**

- `call 内存寻址` 指令的操作码为 `ff16`，机器码为 `ff16 + 16 位内存地址`。
- 寄存器寻址的机器码与寄存器名称有关，例如 `call ax` 的机器码为 `ffd0`，`call cx` 的机器码为 `ffd1`。

**4. 执行过程**

- **CPU 遇到 `call` 指令时，会将当前 IP 寄存器值（即当前指令地址）压入堆栈。**
- **然后根据指令格式，从寄存器或内存中获取目标函数的地址，并将其赋值给 IP 寄存器。**
- **最后，CPU 跳转到目标函数地址执行。**

**5. 示例代码分析**

```assembly
section call_test vstart=0x900
mov word [addr], near_proc
call [addr]
mov ax, near_proc
call ax
jmp $
addr dd 4
near_proc:
	mov ax, 0x1234
	ret
```

`call [addr]` 和 `call ax` 分别演示了间接绝对近调用的两种方式。

- 第 3 行 `call [addr]` 使用内存地址 `addr` 存放目标函数 `near_proc` 的地址。
- 第 5 行 `call ax` 使用 `ax` 寄存器存放目标函数 `near_proc` 的地址。

### 16 位实模式直接绝对远调用

### 16 位实模式间接绝对远调用



---

## 实模式下的 jmp

- `相对于call：jmp有去无返`

1. **短相对跳转 (jmp short)**：这种跳转类型使用一个有符号 8 位立即数作为偏移量，允许在当前指令的 -128 到 +127 字节内进行相对跳转。这条指令的操作码是 0xEB。

   ```assembly
   jmp short start
   ...
   start：
   	...
   ```

2. **近相对跳转 (jmp near)**：这种跳转类型使用一个有符号 16 位立即数作为偏移量，允许在当前指令的 -32,768 到 +32,767 字节内进行相对跳转。这条指令的操作码是 0xE9。

   ```assembly
   jmp near start
   ...
   start:
   	...
   ```

3. **近寄存器间接跳转 (jmp near reg)**：这种跳转类型使用一个寄存器中的 16 位值，例如 AX。这条指令的操作码是 0xFF。

   ```assembly
   mov ax， start
   jmp near ax
   ...
   start:
   	...
   ```

4. **直接绝对远转移 (jmp far)**：这种跳转类型直接提供目标地址的段基址和段内偏移地址。操作数是立即数形式的。操作数会被直接加载到 CS 寄存器和 IP 寄存器中，从而实现转移。

   ```assembly
   jmp 0：start
   ...
   start:
   	...
   ```

5. **间接绝对远转移 (jmp far mem)**：这种跳转类型的操作数在内存中。当不使用段跨越前缀时，段基址寄存器默认为 DS。操作数需要访问内存才能得到，因此需要知道寻址方式。操作数包含 4 个字节：段内偏移地址（2 字节）和段基址（2 字节）。由于是远转移，因此 CPU 的 CS 寄存器和 IP 寄存器都要被修改成操作数中指定的值。

   ```assembly
   jmp far [addr]
   ...
   addr dw start，0
   start:
   	...
   ```

---

## 标志寄存器 flags

![image-20240731155453687](/home/ZMR/.config/Typora/typora-user-images/image-20240731155453687.png)

- 第 0 位的是 CF 位，即 Carry Flag，意为进位。它可用于检测**无符号**数加减法**是否有溢出**，因为 CF 为 1 时，也就是最高位有进位或借位，肯定是溢出。
- 第 2 位为 PF 位，即 Parity Flag，意为奇偶位。用于标记结果低 8 位中 1 的个数，如果为偶数，PF 位为 1，否则为 0。
- 第 4 位为 AF 位，即 Auxiliary carry Flag，意为辅助进位标志，用来记录运算结果低 4 位的进、借位情况，即若低半字节有进、借位，AF 为 1，否则为 0。
- 第 6 位为 ZF 位，即 Zero Flag，意为零标志位。若计算结果为 0，此标志为 1，否则为 0。
- 第 7 位为 SF 位，即 Sign Flag，意为符号标志位。若运算结果为负，则 SF 位为 1，否则为 0。
- 第 8 位为 TF 位，即 Trap Flag，意为陷阱标志位。此位若为 1，用于让 CPU 进入单步运行方式，若为0，则为连续工作的方式。(debug 程序，在单步调试时，原理上就是让 TF 位为 1)
- 第 9 位为 IF 位，即 Interrupt Flag，意为中断标志位。若 IF 位为 1，表示中断开启，CPU 可以响应外部可屏蔽中断。若为 0，表示中断关闭，CPU 不再响应来自 CPU 外部的可屏蔽中断，但 CPU 内部的异常还是要响应的.
- 第 10 位为 DF 位，即 Direction Flag，意为方向标志位。此标志位用于字符串操作指令中，当 DF 为1 时，指令中的操作数地址会自动减少一个单位，当 DF 为 0 时，指令中的操作数地址会自动增加一个单位，意即给地址的变化提供个方向。
- 第 11 位为 OF 位，即 Overflow Flag，意为溢出标志位。若 OF 为 1，表示有溢出，为 0 则未发生溢出。专门用于检测**有符号数**运算结果**是否有溢出**现象。
- ...

---

## 有条件转移

![image-20240731160330979](/home/ZMR/.config/Typora/typora-user-images/image-20240731160330979.png)

a表示 above
b表示 below
c表示 carry
e表示 equal
g表示 great
j表示 jmp
l表示 less
n表示 not
o表示 overflow
p表示 parity

---

## 实模式的缺点

1. 实模式下没有特权级，用户程序和操作系统平起平坐
2. 程序可以随意修改自己的段基址，可以随意访问任意物理内存，包括访问操作系统所在的内存数据

----

## IO接口

### 背景

CPU 与外部设备通信的挑战：

- 外部设备种类繁多，特性各异，数据格式、工作时序、信号电平等方面都存在差异。
- CPU 速度远高于外部设备，直接与每个设备交互会造成 CPU 等待时间过长，效率低下。

### 概述

IO 接口的引入：

- 作用： **CPU 和外部设备之间的代理，负责协调双方之间的差异，简化 CPU 的操作**。
- IO 接口可以是电路板、芯片或插槽，负责速度匹配、信号转换、数据格式转换、时序控制等功能。
- IO 接口可以分为硬件和软件两部分：
  - 硬件部分负责实际的协调转换工作。
  - 软件部分包括驱动程序和数据传输程序，控制接口电路的运作。

IO 接口的分类：

- 可编程接口芯片：可以根据需要设置工作模式，支持多种功能，允许多个设备共享同一个接口。
- 不可编程接口芯片：功能简单，不需要设定即可使用。

IO 接口的控制编程：

- 通过软件指令控制 IO 接口的功能和工作模式，实现定制化的功能。
- 使用端口读写指令 (in/out) 来实现 IO 接口的控制编程。

具体例子：

- ### USB 接口：用于连接外部设备，如键盘、鼠标、打印机等。

- ### PCI/PCIe 插槽：用于连接各种扩展卡，如显卡、网卡、声卡等。

### 功能

- 设置数据缓冲区，解决速度不匹配问题。
- 设置信号电平转换电路，解决信号电平差异问题。
- 设置数据格式转换电路，解决数据格式差异问题。
- 设置时序控制电路，同步 CPU 和外部设备的工作时序。
- 提供地址译码，实现对多个端口的访问。

### 其他

总线：

- 作用：**连接 CPU 和外部设备的物理链路，是一组电线，用于传输信号**。
- 主板上的各种插槽都是连接到总线上的。
- 总线可以分为不同的类型，如地址总线、数据总线、ISA 总线等。

南桥芯片：

- 作用：**仲裁 IO 接口的竞争，连接各种内部总线**。

- 南桥芯片负责连接各种低速设备，如硬盘、USB、PCI 设备等。

- 南桥芯片内部集成了一些 IO 接口，并提供 PCI 接口用于扩展其他设备。

  ![image-20240731200112351](/home/ZMR/.config/Typora/typora-user-images/image-20240731200112351.png)

端口：

- 作用：**是 IO 接口内部的寄存器，用于与 CPU 进行数据交互**。
- 为了区别于 CPU 内部的寄存器，IO 接口中的寄存器称为端口。
- in 指令用于从端口读取数据。
- out 指令用于向端口写入数据。

### ★★★ IO接口，cpu，外部设备，总线，南桥芯片，端口之间的关系

 IO 接口是连接 CPU 和硬件的桥梁，一端是 CPU，另一端是硬件。IO接口通过总线连接CPU和外部设备。当同时有很多的IO接口想与CPU通信时，需要南桥芯片来协调各个IO接口。而IO接口被设计成需要使用寄存器才能与CPU 通信，因此IO接口中的寄存器被称为端口，用于与 CPU 进行数据交互

---

## 显存、显卡、显示器

- 关系：**显卡（硬件组件，包括GPU）通过显存（显卡里的物理内存）进行图形数据的存取和处理，然后通过 I/O 接口（如PCI/PCIe 插槽）将处理后的图像输出到显示器**

- 黑白图形模式: 显存中的对应位置为 1，屏幕上的相应像素就被点亮，呈现的是白色。若该位为 0，该像素就不会被点亮，只要不管该像素就是黑色

- 真彩色: 24 个 bit 表示一个颜色，即24 位对应一个像素

### ▶ 代码（通过显卡输出hello MBR）

```assembly
;主引导程序 
SECTION MBR vstart=0x7c00      
    mov ax,cs                  
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00       

    ;往gs寄存器中存入段基址
    mov ax,0xb800   ;由于显存文本模式中，其内存地址是 0xb8000，实模式下内存分段访问策略是“段基址*16+段内偏移地址”
    mov gs,ax       ;所以由0xb8000得到的段基址是其除以16,也就是右移4位，得：0xb800

    mov ax, 0x600              
    mov bx, 0x700              
    mov cx, 0                  
    mov dx, 0x184f	           
			                   
    int 0x10
    
    ; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
    mov byte [gs:0x00],'h'              ; gs为段跨越前缀，指定gs为段基址
    mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色

    mov byte [gs:0x02],'e'
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'l'
    mov byte [gs:0x05],0xA4   

    mov byte [gs:0x06],'l'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'o'
    mov byte [gs:0x09],0xA4

    mov byte [gs:0x0a],' '
    mov byte [gs:0x0b],0xA4

    mov byte [gs:0x0c],'M'
    mov byte [gs:0x0d],0xA4

    mov byte [gs:0x0e],'B'
    mov byte [gs:0x0f],0xA4

    mov byte [gs:0x10],'R'
    mov byte [gs:0x11],0xA4

    jmp $

    times 510-($-$$) db 0
    db 0x55,0xaa
```

![image-20240801102626566](/home/ZMR/.config/Typora/typora-user-images/image-20240801102626566.png)

---

## bochs

### 简介

1. 是一个开源 x86 虚拟机软件，支持硬件级别上的调试
2. bochs 的调试风格参照 gdb 来设计
3. 八进制（零开头）：011
   十进制：11
   十六进制（0x开头）：0x11

### Bochs 调试命令分类

- **Debugger control** 类：控制调试器行为，例如退出调试状态、设置寄存器值、显示模式信息等。
- **Execution control** 类：控制程序执行，例如继续执行、单步执行、执行下一条指令等。
- **Breakpoint management** 类：管理断点，例如设置断点、删除断点、禁用/启用断点等。
- **CPU and memory contents** 类：查看 CPU 和内存内容，例如查看内存内容、查看寄存器值、查看堆栈信息等。

### 常用调试命令介绍

#### Debugger control类

- `q|quit|exit`: 退出调试状态，关闭虚拟机。
- `set`: 设置寄存器值或其他选项，例如 `set reg = val` 设置寄存器值，`set u on|off` 设置是否反汇编指令。
- `show`: 显示信息，例如 `show mode` 显示模式信息，`show int` 显示中断信息，`show call` 显示函数调用信息。
- `traceon|off`: 设置是否在单步调试时反汇编代码。
- `u|disasm`: 反汇编代码。
- `ctrl+c`: 中断执行，回到 Bochs 控制台。

#### Execution control类

- `c|cont|continue`: 继续执行。
- `s|step`: 单步执行。
- `p|n|next`: 执行下一条指令。

#### Breakpoint management类

- `vb|vbreak`: 设置虚拟地址断点。
- `lb|lbreak`: 设置线性地址断点。
- `pb|pbreak|b|break`: 设置物理地址断点。
- `sb`: 设置指令数断点。
- `sba`: 设置 CPU 执行指令数断点。
- `watch`: 设置读写断点。
- `blist`: 显示所有断点信息。
- `bpd|bpe`: 禁用/启用断点。
- `d|del|delete`: 删除断点。

#### CPU and memory contents类：

- `x`: 显示线性地址的内容。
- `xp`: 显示物理地址的内容。
- `setpmem`: 设置物理内存内容。
- `r|reg|regs|registers`: 显示寄存器值。
- `ptime`: 显示 Bochs 自启动之后，总执行指令数。
- `print-stack`: 显示堆栈信息。
- `?|calc`: 内置计算器。
- `info`: 显示信息，例如 `info pb` 查看断点信息，`info CPU` 显示 CPU 所有寄存器值，`info idt` 显示中断向量表 IDT，`info gdt` 显示全局描述符表 GDT，`info flags` 显示状态寄存器，`info tab` 显示页表信息。

### 常见调试步骤

> 调试 `#GP General Protection Exception` 的步骤如下

1. 启动调试

   - 使用 `show int` 命令查看中断状态。

   - 运行程序，使用 `c` 命令继续执行。


2. 查找异常
   - 观察控制台输出，注意到 `exception (not softint)` 行，确定异常发生的位置（如 `0008:c0001e1b`）。


3. 确定中断处理函数

   - 使用 `nm` 命令查找中断处理函数的符号信息：
     ```bash
     nm build/kernel.bin | grep 1e1b
     ```

   - 确认函数名（如 `intr##0x0d##entry`），这表明是 GP 异常的处理。


4. 设置断点

   - 在异常处理函数入口设置断点：
     ```bash
     lb 0xc0001e1b
     ```

   - 使用 `c` 命令继续执行，捕获到断点。


5. 查看寄存器状态
   - 使用 `r` 命令查看寄存器状态，特别是 `ebx` 和 `gs` 的值，检查是否存在无效的内存访问。


6. 检查内存

   - 使用 `sreg` 查看段寄存器的状态，确认 `gs` 段的基址和限制。

   - 使用 `x gs:ax` 检查内存，观察是否有超出范围的访问。


7. 分析段描述符
   - 使用 `info gdt 3` 查看 GDT 中的段描述符，确认段的 `limit` 是否足够。


8. 执行并验证

   - 逐步执行引发异常的指令：
     ```bash
     s
     ```

   - 如果再次触发 GP 异常，回到中断处理函数，分析错误原因。


9. 修复错误
   - 根据调试信息，修正代码中的越界访问错误，确保访问的内存地址在合法范围内。


10. 重复测试
    - 重新编译并测试程序，确保问题已解决，不再引发 GP 异常。


---

## 硬盘

- **硬盘控制器属于 IO 接口**，cpu通过硬盘控制器来与硬盘交流
- 因此硬盘控制器拥有端口，也就是它里面的寄存器。让硬盘工作，我们就需要读写硬盘控制器的端口

### ★★ 硬盘操作方法

- **硬盘读或写操作**的基本顺序
  1. **选择通道**：指定要操作的硬盘通道。
  2. **写入扇区数**：将待操作的扇区数写入 sector count 寄存器。
  3. **设置 LBA 地址**：将扇区起始地址的低 24 位写入 LBA 寄存器，并在 device 寄存器中设置 LBA 模式及选择硬盘。
  4. **写入命令**：将具体的操作命令（如读或写）写入 command 寄存器。
  5. **检查状态**：读取 status 寄存器，判断硬盘是否完成操作。
  6. **判断操作类型**：如果是读操作，继续下一步；如果是写操作，则结束。
  7. **读取数据**：从硬盘将数据读出。

- 硬盘工作完成后，它已经准备好了数据，通过下面**五种方式进行数据传送**

  （1）**无条件传送方式**：随时准备好了数据，CPU 随时取随时拿都没问题（如：寄存器、内存）

  （2）**查询传送方式**：也称为程序 I/O、PIO，传输之前，每次都由程序先去检测设备的状态（CPU花在查询上的时间多，效率低）

  （3）**中断传送方式**：也称为中断驱动 I/O，当数据源设备准备好数据后，硬盘控制器通过发中断来通知 CPU 来拿数据（避免CPU浪费时间在查询上，效率较高。但中断时，CPU就需要压栈出栈，浪费其资源）

  （4）**直接存储器存取方式（DMA）**：“直接”体现在 不让 CPU参与传输，完全由数据源设备和内存直接传输。CPU 直接到内存中拿数据就好了。（和中断比，它方便快捷。但DMA由硬件实现，需要DMA控制器）

  （5）**I/O 处理机传送方式**：在DMA基础上再引入I/O 处理机，专门用于处理 IO。（CPU彻底不用管了）

---

## 让MBR使用硬盘

### 代码

mbr.s

```assembly
;主引导程序 
%include "boot.inc"     ;nasm 编译器中的预处理指令,让编译器在编译之前把 boot.inc 文件包含进来
SECTION MBR vstart=0x7c00         
    mov ax,cs      
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00
    mov ax,0xb800
    mov gs,ax

    ; 清屏
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0                      
    mov dx, 184fh		           		                   
				                   
    int 10h                        

    ; 输出字符串:MBR
    mov byte [gs:0x00],'1'
    mov byte [gs:0x01],0xA4

    mov byte [gs:0x02],' '
    mov byte [gs:0x03],0xA4

    mov byte [gs:0x04],'M'
    mov byte [gs:0x05],0xA4	        ;A表示绿色背景闪烁，4表示前景色为红色

    mov byte [gs:0x06],'B'
    mov byte [gs:0x07],0xA4

    mov byte [gs:0x08],'R'
    mov byte [gs:0x09],0xA4
	 
    ;下面三行为rd_disk_m_16 函数传递参数（用寄存器传递，这里用到eax、bx、cx 寄存器）
    mov eax,LOADER_START_SECTOR	    ; 待读入的起始扇区lba地址
    mov bx,LOADER_BASE_ADDR         ; 数据从硬盘读进来后，将其写入的内存地址
    mov cx,1			            ; 待读入的扇区数，因为此时大小不会512字节，因此1扇区即可

    call rd_disk_m_16		        ; ★★★调用函数 rd_disk_m_16 读取硬盘的一个扇区，从硬盘读取 loader 程序到指定的内存地址
  
    jmp LOADER_BASE_ADDR            ; ★★★跳转到 loader 的起始地址，执行 loader 程序
       

; 功能: 读取硬盘 n 个扇区的函数
rd_disk_m_16:
    ; eax = LBA 扇区号
    ; ebx = 将数据写入的内存地址
    ; ecx = 读入的扇区数

    mov esi, eax  ; 备份 EAX 寄存器的值（LBA 扇区号）
    mov di, cx    ; 备份 ECX 寄存器的值（待读入的扇区数）

    ; 通过下面五步进行磁盘读取
    ; 第一步：选择特定通道的寄存器，设置要读取的扇区数
    mov dx, 0x1f2  ; 选择端口 0x1f2
    mov al, cl     ; 设置要读取的扇区数
    out dx, al     ; 写入到端口

    mov eax, esi   ; 恢复 EAX 寄存器的值

    ; 第二步：将 LBA 地址的各部分写入端口 0x1f3 ~ 0x1f6
    mov dx, 0x1f3  ; 设置 LBA 地址的低 8 位
    out dx, al     ; 写入到端口

    mov cl, 8      ; 将 EAX 寄存器右移 8 位，设置 LBA 地址的 15~8 位
    shr eax, cl
    mov dx, 0x1f4
    out dx, al

    shr eax, cl    ; 将 EAX 寄存器右移 8 位，设置 LBA 地址的 23~16 位
    mov dx, 0x1f5
    out dx, al

    shr eax, cl    ; 将 EAX 寄存器右移 8 位，设置 LBA 地址的 27~24 位
    and al, 0x0f   ; 只保留低 4 位
    or al, 0xe0    ; 设置高 4 位为 1110，表示 LBA 模式
    mov dx, 0x1f6
    out dx, al

    ; 第三步：向 0x1f7 端口写入读命令，0x20
    mov dx, 0x1f7
    mov al, 0x20  ; 设置读命令
    out dx, al   ; 写入到端口

    ; 第四步：检测硬盘状态，等待硬盘准备好数据传输
.not_ready:
    nop         ; 相当于 sleep，等待
    in al, dx   ; 从端口读取硬盘状态
    and al, 0x88  ; 检查第 4 位和第 7 位
    cmp al, 0x08  ; 如果第 4 位为 1，表示硬盘控制器已准备好数据传输
    jnz .not_ready  ; 如果未准备好，继续等待

    ; 第五步：从 0x1f0 端口读数据
    mov ax, di  ; 获取待读入的扇区数
    mov dx, 256  ; 每个扇区 512 字节，一次读取 2 字节，共需读取 256 次
    mul dx      ; 计算总读取次数
    mov cx, ax  ; 将总读取次数存入 CX 寄存器
    mov dx, 0x1f0  ; 设置数据端口

.go_on_read:
    in ax, dx    ; 从端口读取数据
    mov [bx], ax  ; 将数据写入内存
    add bx, 2    ; 增加内存地址指针
    loop .go_on_read  ; 循环读取，直到 CX 为 0

    ret  ; 返回，回到调用 rd_disk_m_16 的地方

    times 510-($-$$) db 0  ; 填充到 510 字节
    db 0x55, 0xaa  ; MBR 签名
```

loader.s

```assembly
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR  ; 定义代码段的起始地址为 LOADER_BASE_ADDR

; 输出背景色绿色，前景色红色，并且跳动的字符串"2 LOADER"
mov byte [gs:0x00],'2'
mov byte [gs:0x01],0xA4             ; A表示绿色背景闪烁，4表示前景色为红色

mov byte [gs:0x02],' '
mov byte [gs:0x03],0xA4

mov byte [gs:0x04],'L'
mov byte [gs:0x05],0xA4   

mov byte [gs:0x06],'O'
mov byte [gs:0x07],0xA4

mov byte [gs:0x08],'A'
mov byte [gs:0x09],0xA4

mov byte [gs:0x0a],'D'
mov byte [gs:0x0b],0xA4

mov byte [gs:0x0c],'E'
mov byte [gs:0x0d],0xA4

mov byte [gs:0x0e],'R'
mov byte [gs:0x0f],0xA4

jmp $		                        ; 通过死循环使程序悬停在此

```

boot.inc

```assembly
; loader和kernel
LOADER_BASE_ADDR equ 0x900 ;相当于c语言的#define LOADER_BASE_ADDR 0x900
                           ;定义了 loader 在内存中的位置,MBR 要把 loader 从硬盘读入后放到此处
                           ;即后面 loader 会存在内存地址 0x900 处
LOADER_START_SECTOR equ 0x2 ;loader 程序在硬盘上的起始扇区
```

![image-20240801212706705](/home/ZMR/.config/Typora/typora-user-images/image-20240801212706705.png)

## ★★★ 代码讲解

> `mbr.s` 的作用主要是引导计算机的启动过程。它位于硬盘的第一个扇区（MBR，主引导记录），由 BIOS 加载并执行。
>
> `mbr.s` **成功将 loader 程序从硬盘读取到内存中，并跳转到 loader 程序的起始地址开始执行**

1. **初始化硬件环境**：

   - 设置段寄存器（CS、DS、ES、SS、FS）和栈指针（SP），确保程序可以正确访问内存和使用栈。

2. **清屏操作**：

   - 使用 BIOS 中断清除屏幕，并设置屏幕显示的模式，以便后续的输出操作。

3. **输出信息**：

   - 在屏幕上显示一个简单的字符串（如 "1 MBR"），用于表明 MBR 程序已经成功加载并开始执行。

4. **准备读取 loader**：

   - 设置 `eax` 为 `LOADER_START_SECTOR`（loader 在硬盘上的起始扇区），`bx` 为 `LOADER_BASE_ADDR`（将数据从硬盘读入的内存地址），`cx` 为 `1`（待读入的扇区数）。

5. **★★★调用 `rd_disk_m_16` 函数**：

   - 调用 

     ```
     rd_disk_m_16
     ```

      函数读取硬盘上的 loader 程序。该函数执行以下步骤：

     - 设置待读取的扇区数。
     - 将 LBA 地址写入相应端口。
     - 向硬盘发送读命令。
     - 等待硬盘准备好数据传输。
     - 从硬盘读取数据并写入内存。

6. **★★★跳转到 loader 程序**：

   - 读取完成后，使用 `jmp LOADER_BASE_ADDR` 跳转到 loader 程序的起始地址（`0x900`）执行。

---

---

---

 # 保护模式入门

- 实模式，指的是 32 位的 CPU 运行在 16 位模式下的状态
- 开机时，32 位的 CPU 是先处于实模式，之后再进入保护模式的

## 保护模式相对于实模式的拓展

### 寄存器拓展

![image-20240802170318832](/home/ZMR/.config/Typora/typora-user-images/image-20240802170318832.png)

#### 80286

- 80286是8086的下一代，但**有了保护模式**
- 因为有保护模式，所以引入数据结构：**全局描述赋表**
  - 表中至少有一个表项，其中每一个表项称为段描述符，其大小为 64 字节，用来描述各个内存段的起始地址、大小、
    权限等信息。
  - 但：段描述符是**在内存中**，访问内存对 CPU 来说是比较慢的动作，**效率不高**。
  - 但：段描述符的格式很奇怪，一个**数据要分三个地方存**，所以将这些数据拼起来很**费时间**。
  - 综上：为了提高获取段信息的效率，引入**段描述符缓冲寄存器**，将段信息用一个寄存器来缓存。以后每次访问相同的段时，就直接读取该段寄存器对应的段描述符缓冲寄存器。该缓存内容的失效时间为：只要往段寄存器中赋值（即更新选择子），CPU 就会重新访问全局描述符表，再将获取的段信息重新放回段描述符缓冲寄存器
- 偏移地址和实模式一样
- 段寄存器中保存的不是段基址，而是**“选择子”**，该选择子就是个**数**，用这个数来**索引全局描述符表中的段描述符**（把全局描述符表当成数组，选择子就像数组下标一样）

#### ★★★ 8086、80286以及80386

| CPU型号 | 位数 | 地址线位数 | 内存大小              | 段基址位数 | 寄存器位宽 |
| ------- | ---- | ---------- | --------------------- | ---------- | ---------- |
| 8086    | 16位 | 20条       | 1 MB（20位地址空间）  | 16位       | 16位       |
| 80286   | 16位 | 24条       | 16 MB（24位地址空间） | 24位       | 16位       |
| 80386   | 32位 | 32条       | 4 GB（32位地址空间）  | 32位       | 32位       |

- 8086与80286被淘汰
  - **是 24 位段基址，段内相对偏移地址还是必不可少的。用于寻址的通用寄存器还是 16 位，即单独的一个寄存器还是只能访问 64KB 的空间。如果用寄存器作为段内偏移地址，段的大小还是 64KB，这就白白浪费了 24 位段基址的优势，要是想访问完整的 16MB 内存，依然要不断地变换段基址**，所以 80286 很快就被淘汰了
  -  **寻址限制**
    - **段大小限制**：在 80286 和 8086 的 16 位架构中，**段内偏移地址最大为 64KB**（因为寄存器位宽都为16位）。每个段的地址范围从 0 到 65535（2^16 - 1），这意味着**每个段无法超过 64KB**。
    - **影响大型应用**：对于现代应用程序，尤其是需要大量数据或执行复杂算法的程序，64KB 的限制显得非常狭窄。开发者必须分割数据和代码到多个段中，导致内存管理变得繁琐。
    - **额外的复杂性**：程序必须设计为跨多个段工作，这可能导致代码的复杂性增加。
  -  **频繁变换段基址**
    - **频繁调整段基址**：为了访问超过单个段的 64KB 内存，程序必须通过**改变段寄存器的值来访问不同的段**。
    - **性能开销**：每次变换段基址需要 CPU 执行额外的指令，消耗处理时间，降低性能。
    - **不适应多任务处理**：在多任务操作系统中，频繁切换段基址会导致上下文切换的效率降低，影响系统性能和速度。
- 80386的平坦模式
  - **段基址是 32 位，单独的一个寄存器也是 32 位，任意一个段都可以访问到 4GB 空间，不用再变化段基**
    **址了。**
  - 甚至段基址可以是 0，光用段内偏移就可以指向 4GB 空间任意角落。这就开启了“平坦模式”

---

### 寻址拓展

![image-20240802194950350](/home/ZMR/.config/Typora/typora-user-images/image-20240802194950350.png)

- 保护模式下：基址寄存器不再只是 bx、bp，而是所有 32 位的通用寄存器
- 变址寄存器也是一样，不再只是 si、di，而是除 esp 之外的所有 32 位通用寄存器
- 偏移量由实模式的 16 位变成了 32 位。并且，还可以对变址寄存器乘以一个比例因子

---

### 运行模式反转

#### bits 伪指令指定运行模式

- bits 的指令格式是[bits 16]或[bits 32]。
  [bits 16]是告诉编译器，下面的代码帮我编译成 16 位的机器码。
  [bits 32]是告诉编译器，下面的代码帮我编译成 32 位的机器码。

![image-20240802195256765](/home/ZMR/.config/Typora/typora-user-images/image-20240802195256765.png)

#### 0x66：操作数大小反转前缀

- 16 位实模式下可以用 32 位保护模式下的寄存器，需要**在指令前添加指令前缀 0x66**

  ![image-20240802195421174](/home/ZMR/.config/Typora/typora-user-images/image-20240802195421174.png)

  - 第 3 行用到了 32 位寄存器 eax，属于 32 位操作数，由于当前模式是 16 位，要用 0x66 将操作数大小转为
    32 位，故机器码是 66B834120000。其中 34120000 是另一操作数，B8 是操作码，0x66 便是操作数反转前缀。

#### 0x67：寻址方式反转前缀

- 使用对方模式下的寻址方式

  ![image-20240802200122325](/home/ZMR/.config/Typora/typora-user-images/image-20240802200122325.png)

  - 第 2 行的指令，从操作数和寻址方式来看，本身符合 16 位模式，无需添加任何反转前缀。
  - 第 3 行把eax 寄存器作为基址寻址，eax 寄存器不属于实模式，所以在机器码前添加了寻址方式反转前缀 0x67。
  - 第4 行同样是用 eax 寄存器作为基址寻址，并且用到了伪指令 dword，表示在 eax 所表示的内存处，连续写入 4 字节大小的数据。操作数大小也由默认的 2 字节变成了 4 字节，就会添加 0x66 的前缀

---

### 指令扩展

- 在实模式环境下：
  当压入 8 位立即数时，由于实模式下默认操作数是 16 位，CPU 会将其扩展为 16 位后再将其入栈，sp-2。
  当压入 16 位立即数时，CPU 会将其直接入栈，sp-2。
  当压入 32 位立即数时，CPU 会将其直接入栈，sp-4。

- 在保护模式下：
  当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp 指针减 4。
  当压入 16 位立即数时，CPU 直接压入 2 字节，esp 指针减 2。
  当压入 32 位立即数时，CPU 直接压入 4 字节，esp 指针减 4。

- 对于段寄存器入栈：

  即 cs、ds、es、fs、gs、ss，无论在哪种模式下，都是按当前模式的默认操作数大小压入的。例如，在 16 位模式下，CPU 直接压入 2 字节，栈指针 sp 减 2。在 32 位模式下，CPU 直接压入 4 字节，栈指针 esp 减 4。

- 对于通用寄存器和内存：无论是在实模式或保护模式
  y 如果压入的是 16 位数据，栈指针减 2。
  y 如果压入的是 32 位数据，栈指针减 4。

---

